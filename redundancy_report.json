{
  "summary": {
    "total_segments": 402,
    "exact_duplicates": 7,
    "near_duplicates": 16,
    "similar_content": 66,
    "conceptual_overlaps": 11,
    "redundancy_percentage": 5.721393034825871
  },
  "exact_duplicates": [
    {
      "segment1": {
        "content": "**\u2192 Next:** [Cryptography Implementation](#cryptography-implementation) - Secure coding patterns and crypto-specific implementations",
        "normalized_content": "\u2192 next: cryptography implementation - secure coding patterns and crypto-specific implementations",
        "hash": "d7b52c0d60cf0ac96379c5de588d1b6e",
        "line_start": 3738,
        "line_end": 3738,
        "section": "Advanced DMA-Safe Memory Management",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'specific', 'implementations', 'implementation', 'crypto', 'patterns', 'cryptography'}"
      },
      "segment2": {
        "content": "**\u2192 Next:** [Cryptography Implementation](#cryptography-implementation) - Secure coding patterns and crypto-specific implementations",
        "normalized_content": "\u2192 next: cryptography implementation - secure coding patterns and crypto-specific implementations",
        "hash": "d7b52c0d60cf0ac96379c5de588d1b6e",
        "line_start": 3744,
        "line_end": 3744,
        "section": "Advanced DMA-Safe Memory Management",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'specific', 'implementations', 'implementation', 'crypto', 'patterns', 'cryptography'}"
      },
      "similarity_score": 1.0,
      "match_type": "exact",
      "common_phrases": [],
      "diff_summary": "Identical content"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5707,
        "line_end": 5710,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5734,
        "line_end": 5737,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "similarity_score": 1.0,
      "match_type": "exact",
      "common_phrases": [],
      "diff_summary": "Identical content"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 1.0,
      "match_type": "exact",
      "common_phrases": [],
      "diff_summary": "Identical content"
    },
    {
      "segment1": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 5968,
        "line_end": 5974,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6031,
        "line_end": 6037,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 1.0,
      "match_type": "exact",
      "common_phrases": [],
      "diff_summary": "Identical content"
    },
    {
      "segment1": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 5968,
        "line_end": 5974,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6164,
        "line_end": 6170,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 1.0,
      "match_type": "exact",
      "common_phrases": [],
      "diff_summary": "Identical content"
    },
    {
      "segment1": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6031,
        "line_end": 6037,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6164,
        "line_end": 6170,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 1.0,
      "match_type": "exact",
      "common_phrases": [],
      "diff_summary": "Identical content"
    },
    {
      "segment1": {
        "content": "        let plaintext_block: [u8; 16] = plaintext.try_into().unwrap();\n        let result1 = ctx1.encrypt_block(&plaintext_block);\n        let result2 = ctx2.encrypt_block(&plaintext_block);",
        "normalized_content": "let plaintext_block: [u8; 16] = plaintext.try_into().unwrap(); let result1 = ctx1.encrypt_block(&plaintext_block); let result2 = ctx2.encrypt_block(&plaintext_block);",
        "hash": "086a5e86e1e0340f122903f464f98eb1",
        "line_start": 6593,
        "line_end": 6595,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 14,
        "key_terms": "{'encrypt_block', 'try_into', 'plaintext', 'result2', 'plaintext_block', 'result1'}"
      },
      "segment2": {
        "content": "        let plaintext_block: [u8; 16] = plaintext.try_into().unwrap();\n        let result1 = ctx1.encrypt_block(&plaintext_block);\n        let result2 = ctx2.encrypt_block(&plaintext_block);",
        "normalized_content": "let plaintext_block: [u8; 16] = plaintext.try_into().unwrap(); let result1 = ctx1.encrypt_block(&plaintext_block); let result2 = ctx2.encrypt_block(&plaintext_block);",
        "hash": "086a5e86e1e0340f122903f464f98eb1",
        "line_start": 6614,
        "line_end": 6616,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 14,
        "key_terms": "{'encrypt_block', 'try_into', 'plaintext', 'result2', 'plaintext_block', 'result1'}"
      },
      "similarity_score": 1.0,
      "match_type": "exact",
      "common_phrases": [],
      "diff_summary": "Identical content"
    }
  ],
  "near_duplicates": [
    {
      "segment1": {
        "content": "impl OpensslAes {\n    pub fn new_cbc(key: &[u8; 32], iv: &[u8; 16]) -> Result<Self, CryptoError> {\n        let ctx = unsafe { EVP_CIPHER_CTX_new() };\n        if ctx.is_null() {\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "impl opensslaes { pub fn new_cbc(key: &[u8; 32], iv: &[u8; 16]) -> result<self, cryptoerror> { let ctx = unsafe { evp_cipher_ctx_new() }; if ctx.is_null() { return err(cryptoerror::initializationfailed); }",
        "hash": "91f14937b95b35b7f66e0c59c2486440",
        "line_start": 5690,
        "line_end": 5695,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 28,
        "key_terms": "{'cryptoerror', 'is_null', 'evp_cipher_ctx_new', 'key', 'opensslaes', 'initializationfailed', 'unsafe', 'new_cbc'}"
      },
      "segment2": {
        "content": "    pub fn new_gcm(key: &[u8; 32], iv: &[u8; 12]) -> Result<Self, CryptoError> {\n        let ctx = unsafe { EVP_CIPHER_CTX_new() };\n        if ctx.is_null() {\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "pub fn new_gcm(key: &[u8; 32], iv: &[u8; 12]) -> result<self, cryptoerror> { let ctx = unsafe { evp_cipher_ctx_new() }; if ctx.is_null() { return err(cryptoerror::initializationfailed); }",
        "hash": "934c53b01511bd022ad875fc7d67bc60",
        "line_start": 5718,
        "line_end": 5722,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 25,
        "key_terms": "{'cryptoerror', 'is_null', 'evp_cipher_ctx_new', 'new_gcm', 'key', 'initializationfailed', 'unsafe'}"
      },
      "similarity_score": 0.9387755102040817,
      "match_type": "near_exact",
      "common_phrases": [
        "impl OpensslAes {\n    pub fn new_cbc(key: &[u8; 32], iv: &[u8; 16]) -> Result<Self, CryptoError> {\n ...",
        "is_null() {\n            return Err(CryptoError::InitializationFailed);\n        }"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,2 @@\n-impl OpensslAes {\n-    pub fn new_cbc(key: &[u8; 32], iv: &[u8; 16]) -> Result<Self, CryptoError> {\n+    pub fn new_gcm(key: &[u8; 32], iv: &[u8; 12]) -> Result<Self, CryptoError> {\n         let ctx = unsafe { EVP_CIPHER_CTX_new() };"
    },
    {
      "segment1": {
        "content": "        let result = unsafe {\n            EVP_EncryptInit_ex(\n                ctx,\n                EVP_aes_256_cbc(),\n                core::ptr::null_mut(),\n                key.as_ptr(),\n                iv.as_ptr(),\n            )\n        };",
        "normalized_content": "let result = unsafe { evp_encryptinit_ex( ctx, evp_aes_256_cbc(), core::ptr::null_mut(), key.as_ptr(), iv.as_ptr(), ) };",
        "hash": "3c0212bafd51ea6789cd16c9d999b2d6",
        "line_start": 5697,
        "line_end": 5705,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'null_mut', 'evp_aes_256_cbc', 'key', 'unsafe', 'evp_encryptinit_ex'}"
      },
      "segment2": {
        "content": "        let result = unsafe {\n            EVP_EncryptInit_ex(\n                ctx,\n                EVP_aes_256_gcm(),\n                core::ptr::null_mut(),\n                key.as_ptr(),\n                iv.as_ptr(),\n            )\n        };",
        "normalized_content": "let result = unsafe { evp_encryptinit_ex( ctx, evp_aes_256_gcm(), core::ptr::null_mut(), key.as_ptr(), iv.as_ptr(), ) };",
        "hash": "c2cfabb54e81dd6a8678e078ba17a46c",
        "line_start": 5724,
        "line_end": 5732,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'null_mut', 'evp_aes_256_gcm', 'key', 'unsafe', 'evp_encryptinit_ex'}"
      },
      "similarity_score": 0.9833333333333333,
      "match_type": "near_exact",
      "common_phrases": [
        "let result = unsafe {\n            EVP_EncryptInit_ex(\n                ctx,\n                EVP_aes_2...",
        "as_ptr(),\n                iv",
        "as_ptr(),\n                iv",
        "as_ptr(),\n            )\n        };",
        "as_ptr(),\n            )\n        };"
      ],
      "diff_summary": "--- \n+++ \n@@ -3,3 +3,3 @@\n                 ctx,\n-                EVP_aes_256_cbc(),\n+                EVP_aes_256_gcm(),\n                 core::ptr::null_mut(),"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5707,
        "line_end": 5710,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result != 1 {\n            unsafe { HMAC_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { hmac_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "8eaf5198d57ca160f1ba1c394b255a8e",
        "line_start": 5826,
        "line_end": 5829,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'hmac_ctx_free', 'initializationfailed', 'unsafe', 'cryptoerror'}"
      },
      "similarity_score": 0.9393939393939394,
      "match_type": "near_exact",
      "common_phrases": [
        "= 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::Initializ..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,3 @@\n         if result != 1 {\n-            unsafe { EVP_CIPHER_CTX_free(ctx) };\n+            unsafe { HMAC_CTX_free(ctx) };\n             return Err(CryptoError::InitializationFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5734,
        "line_end": 5737,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result != 1 {\n            unsafe { HMAC_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { hmac_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "8eaf5198d57ca160f1ba1c394b255a8e",
        "line_start": 5826,
        "line_end": 5829,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'hmac_ctx_free', 'initializationfailed', 'unsafe', 'cryptoerror'}"
      },
      "similarity_score": 0.9393939393939394,
      "match_type": "near_exact",
      "common_phrases": [
        "= 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::Initializ..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,3 @@\n         if result != 1 {\n-            unsafe { EVP_CIPHER_CTX_free(ctx) };\n+            unsafe { HMAC_CTX_free(ctx) };\n             return Err(CryptoError::InitializationFailed);"
    },
    {
      "segment1": {
        "content": "        if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }",
        "normalized_content": "if result == 1 { ok(()) } else { err(cryptoerror::encryptionfailed) } }",
        "hash": "d1d1659afec09240f0707cf90f5cbcde",
        "line_start": 5842,
        "line_end": 5847,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 5968,
        "line_end": 5974,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.9722222222222222,
      "match_type": "near_exact",
      "common_phrases": [
        "if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-        if result == 1 {\n+        if result == 0 {\n             Ok(())\n@@ -6 +6,2 @@\n     }\n+}"
    },
    {
      "segment1": {
        "content": "        if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }",
        "normalized_content": "if result == 1 { ok(()) } else { err(cryptoerror::encryptionfailed) } }",
        "hash": "d1d1659afec09240f0707cf90f5cbcde",
        "line_start": 5842,
        "line_end": 5847,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6031,
        "line_end": 6037,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.9722222222222222,
      "match_type": "near_exact",
      "common_phrases": [
        "if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-        if result == 1 {\n+        if result == 0 {\n             Ok(())\n@@ -6 +6,2 @@\n     }\n+}"
    },
    {
      "segment1": {
        "content": "        if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }",
        "normalized_content": "if result == 1 { ok(()) } else { err(cryptoerror::encryptionfailed) } }",
        "hash": "d1d1659afec09240f0707cf90f5cbcde",
        "line_start": 5842,
        "line_end": 5847,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6164,
        "line_end": 6170,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.9722222222222222,
      "match_type": "near_exact",
      "common_phrases": [
        "if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-        if result == 1 {\n+        if result == 0 {\n             Ok(())\n@@ -6 +6,2 @@\n     }\n+}"
    },
    {
      "segment1": {
        "content": "            if dma_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }",
        "normalized_content": "if dma_result != 0 { return err(cryptoerror::initializationfailed); }",
        "hash": "9ebeea2a38b39b46b1bf5ab32bb36342",
        "line_start": 6112,
        "line_end": 6114,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'initializationfailed', 'dma_result', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "similarity_score": 0.9571428571428572,
      "match_type": "near_exact",
      "common_phrases": [
        "if dma_result",
        "= 0 {\n                return Err(CryptoError::InitializationFailed);\n            }"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,4 @@\n-            if dma_result != 0 {\n+            if aes_result != 0 {\n                 return Err(CryptoError::InitializationFailed);\n             }\n+        }"
    },
    {
      "segment1": {
        "content": "fn build_openssl_bindings() {\n    let bindings = bindgen::Builder::default()\n        .header(\"wrapper_openssl.h\")\n        .parse_callbacks(Box::new(bindgen::CargoCallbacks))\n        .generate()\n        .expect(\"Unable to generate OpenSSL bindings\");",
        "normalized_content": "fn build_openssl_bindings() { let bindings = bindgen::builder::default() .header(\"wrapper_openssl.h\") .parse_callbacks(box::new(bindgen::cargocallbacks)) .generate() .expect(\"unable to generate openssl bindings\");",
        "hash": "8de7feeb747db9461bd63d1be78b85e0",
        "line_start": 6250,
        "line_end": 6255,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 15,
        "key_terms": "{'build_openssl_bindings', 'generate', 'cargocallbacks', 'parse_callbacks', 'bindgen', 'wrapper_openssl', 'openssl', 'builder', 'bindings', 'default'}"
      },
      "segment2": {
        "content": "fn build_mbedtls_bindings() {\n    let bindings = bindgen::Builder::default()\n        .header(\"wrapper_mbedtls.h\")\n        .parse_callbacks(Box::new(bindgen::CargoCallbacks))\n        .generate()\n        .expect(\"Unable to generate mbedTLS bindings\");",
        "normalized_content": "fn build_mbedtls_bindings() { let bindings = bindgen::builder::default() .header(\"wrapper_mbedtls.h\") .parse_callbacks(box::new(bindgen::cargocallbacks)) .generate() .expect(\"unable to generate mbedtls bindings\");",
        "hash": "5315757c7455a90a5d77f8ea5bc6e46d",
        "line_start": 6263,
        "line_end": 6268,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 15,
        "key_terms": "{'mbedtls', 'generate', 'cargocallbacks', 'parse_callbacks', 'bindgen', 'wrapper_mbedtls', 'builder', 'bindings', 'default', 'build_mbedtls_bindings'}"
      },
      "similarity_score": 0.9014084507042254,
      "match_type": "near_exact",
      "common_phrases": [
        "fn build_openssl_bindings() {\n    let bindings = bindgen::Builder::default()",
        "parse_callbacks(Box::new(bindgen::CargoCallbacks))",
        "generate()",
        "expect(\"Unable to generate OpenSSL bindings\");"
      ],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,6 +1,6 @@\n-fn build_openssl_bindings() {\n+fn build_mbedtls_bindings() {"
    },
    {
      "segment1": {
        "content": "    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"openssl_bindings.rs\"))\n        .expect(\"Couldn't write OpenSSL bindings!\");\n}",
        "normalized_content": "let out_path = pathbuf::from(env::var(\"out_dir\").unwrap()); bindings .write_to_file(out_path.join(\"openssl_bindings.rs\")) .expect(\"couldn't write openssl bindings!\"); }",
        "hash": "416c70758f4660d3ac4706c5260efa30",
        "line_start": 6257,
        "line_end": 6261,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'openssl_bindings', 'pathbuf', 'openssl', 'write_to_file', 'out_path', 'bindings', 'out_dir'}"
      },
      "segment2": {
        "content": "    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"mbedtls_bindings.rs\"))\n        .expect(\"Couldn't write mbedTLS bindings!\");\n}",
        "normalized_content": "let out_path = pathbuf::from(env::var(\"out_dir\").unwrap()); bindings .write_to_file(out_path.join(\"mbedtls_bindings.rs\")) .expect(\"couldn't write mbedtls bindings!\"); }",
        "hash": "1e2a636f8b958a6645d3915e6dd3d7ab",
        "line_start": 6270,
        "line_end": 6274,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'mbedtls', 'write_to_file', 'pathbuf', 'mbedtls_bindings', 'out_path', 'bindings', 'out_dir'}"
      },
      "similarity_score": 0.9404761904761905,
      "match_type": "near_exact",
      "common_phrases": [
        "let out_path = PathBuf::from(env::var(\"OUT_DIR\")",
        "unwrap());\n    bindings",
        "write_to_file(out_path",
        "expect(\"Couldn't write OpenSSL bindings"
      ],
      "diff_summary": "--- \n+++ \n@@ -2,4 +2,4 @@\n     bindings\n-        .write_to_file(out_path.join(\"openssl_bindings.rs\"))\n-        .expect(\"Couldn't write OpenSSL bindings!\");\n+        .write_to_file(out_path.join(\"mbedtls_bindings.rs\"))\n+        .expect(\"Couldn't write mbedTLS bindings!\");\n }"
    },
    {
      "segment1": {
        "content": "    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"openssl_bindings.rs\"))\n        .expect(\"Couldn't write OpenSSL bindings!\");\n}",
        "normalized_content": "let out_path = pathbuf::from(env::var(\"out_dir\").unwrap()); bindings .write_to_file(out_path.join(\"openssl_bindings.rs\")) .expect(\"couldn't write openssl bindings!\"); }",
        "hash": "416c70758f4660d3ac4706c5260efa30",
        "line_start": 6257,
        "line_end": 6261,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'openssl_bindings', 'pathbuf', 'openssl', 'write_to_file', 'out_path', 'bindings', 'out_dir'}"
      },
      "segment2": {
        "content": "    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"xilinx_bindings.rs\"))\n        .expect(\"Couldn't write Xilinx bindings!\");\n}",
        "normalized_content": "let out_path = pathbuf::from(env::var(\"out_dir\").unwrap()); bindings .write_to_file(out_path.join(\"xilinx_bindings.rs\")) .expect(\"couldn't write xilinx bindings!\"); }",
        "hash": "ec52a339a93065272d584e092cb3ca87",
        "line_start": 6289,
        "line_end": 6293,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'xilinx_bindings', 'pathbuf', 'write_to_file', 'out_path', 'bindings', 'out_dir'}"
      },
      "similarity_score": 0.9341317365269461,
      "match_type": "near_exact",
      "common_phrases": [
        "let out_path = PathBuf::from(env::var(\"OUT_DIR\")",
        "unwrap());\n    bindings",
        "write_to_file(out_path",
        "expect(\"Couldn't write OpenSSL bindings"
      ],
      "diff_summary": "--- \n+++ \n@@ -2,4 +2,4 @@\n     bindings\n-        .write_to_file(out_path.join(\"openssl_bindings.rs\"))\n-        .expect(\"Couldn't write OpenSSL bindings!\");\n+        .write_to_file(out_path.join(\"xilinx_bindings.rs\"))\n+        .expect(\"Couldn't write Xilinx bindings!\");\n }"
    },
    {
      "segment1": {
        "content": "    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"mbedtls_bindings.rs\"))\n        .expect(\"Couldn't write mbedTLS bindings!\");\n}",
        "normalized_content": "let out_path = pathbuf::from(env::var(\"out_dir\").unwrap()); bindings .write_to_file(out_path.join(\"mbedtls_bindings.rs\")) .expect(\"couldn't write mbedtls bindings!\"); }",
        "hash": "1e2a636f8b958a6645d3915e6dd3d7ab",
        "line_start": 6270,
        "line_end": 6274,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'mbedtls', 'write_to_file', 'pathbuf', 'mbedtls_bindings', 'out_path', 'bindings', 'out_dir'}"
      },
      "segment2": {
        "content": "    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"xilinx_bindings.rs\"))\n        .expect(\"Couldn't write Xilinx bindings!\");\n}",
        "normalized_content": "let out_path = pathbuf::from(env::var(\"out_dir\").unwrap()); bindings .write_to_file(out_path.join(\"xilinx_bindings.rs\")) .expect(\"couldn't write xilinx bindings!\"); }",
        "hash": "ec52a339a93065272d584e092cb3ca87",
        "line_start": 6289,
        "line_end": 6293,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'xilinx_bindings', 'pathbuf', 'write_to_file', 'out_path', 'bindings', 'out_dir'}"
      },
      "similarity_score": 0.9341317365269461,
      "match_type": "near_exact",
      "common_phrases": [
        "let out_path = PathBuf::from(env::var(\"OUT_DIR\")",
        "unwrap());\n    bindings",
        "write_to_file(out_path",
        "expect(\"Couldn't write mbedTLS bindings"
      ],
      "diff_summary": "--- \n+++ \n@@ -2,4 +2,4 @@\n     bindings\n-        .write_to_file(out_path.join(\"mbedtls_bindings.rs\"))\n-        .expect(\"Couldn't write mbedTLS bindings!\");\n+        .write_to_file(out_path.join(\"xilinx_bindings.rs\"))\n+        .expect(\"Couldn't write Xilinx bindings!\");\n }"
    },
    {
      "segment1": {
        "content": "        let ctx1 = AesContext::new(&key).unwrap();\n        let ctx2 = AesContext::new(&key).unwrap();",
        "normalized_content": "let ctx1 = aescontext::new(&key).unwrap(); let ctx2 = aescontext::new(&key).unwrap();",
        "hash": "b74cbcad448aa3f5c61fc216419364b3",
        "line_start": 6590,
        "line_end": 6591,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'key', 'aescontext'}"
      },
      "segment2": {
        "content": "        let ctx1 = AesContext::new(&key1).unwrap();\n        let ctx2 = AesContext::new(&key2).unwrap();",
        "normalized_content": "let ctx1 = aescontext::new(&key1).unwrap(); let ctx2 = aescontext::new(&key2).unwrap();",
        "hash": "4b2732e8720b764405dcb9299bb2ae91",
        "line_start": 6611,
        "line_end": 6612,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'aescontext'}"
      },
      "similarity_score": 0.9883720930232558,
      "match_type": "near_exact",
      "common_phrases": [
        "let ctx1 = AesContext::new(&key)",
        "unwrap();\n        let ctx2 = AesContext::new(&key)"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-        let ctx1 = AesContext::new(&key).unwrap();\n-        let ctx2 = AesContext::new(&key).unwrap();\n+        let ctx1 = AesContext::new(&key1).unwrap();\n+        let ctx2 = AesContext::new(&key2).unwrap();"
    },
    {
      "segment1": {
        "content": "        let hmac1 = calculate_hmac_sha256(&key, &message);\n        let hmac2 = calculate_hmac_sha256(&key, &message);",
        "normalized_content": "let hmac1 = calculate_hmac_sha256(&key, &message); let hmac2 = calculate_hmac_sha256(&key, &message);",
        "hash": "7e04ede8ec23a65a1c4e440c71c6bdaa",
        "line_start": 6629,
        "line_end": 6630,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 10,
        "key_terms": "{'calculate_hmac_sha256', 'key', 'message'}"
      },
      "segment2": {
        "content": "        let hmac1 = calculate_hmac_sha256(&key1, &message);\n        let hmac2 = calculate_hmac_sha256(&key2, &message);",
        "normalized_content": "let hmac1 = calculate_hmac_sha256(&key1, &message); let hmac2 = calculate_hmac_sha256(&key2, &message);",
        "hash": "7433228ca84c11f52fb1c3aaee18a6b5",
        "line_start": 6642,
        "line_end": 6643,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 10,
        "key_terms": "{'calculate_hmac_sha256', 'message'}"
      },
      "similarity_score": 0.9901960784313726,
      "match_type": "near_exact",
      "common_phrases": [
        "let hmac1 = calculate_hmac_sha256(&key, &message);\n        let hmac2 = calculate_hmac_sha256(&key, &..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-        let hmac1 = calculate_hmac_sha256(&key, &message);\n-        let hmac2 = calculate_hmac_sha256(&key, &message);\n+        let hmac1 = calculate_hmac_sha256(&key1, &message);\n+        let hmac2 = calculate_hmac_sha256(&key2, &message);"
    },
    {
      "segment1": {
        "content": "    for _ in 0..1000 {\n        let start = get_cycle_count();\n        let _ = aes_encrypt_constant_time(&key1, &plaintext);\n        let end = get_cycle_count();\n        timings1.push(end - start);",
        "normalized_content": "for _ in 0..1000 { let start = get_cycle_count(); let _ = aes_encrypt_constant_time(&key1, &plaintext); let end = get_cycle_count(); timings1.push(end - start);",
        "hash": "1f2131f630e978eda9b079ef977e695c",
        "line_start": 6795,
        "line_end": 6799,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 21,
        "key_terms": "{'get_cycle_count', 'plaintext', 'timings1', 'aes_encrypt_constant_time'}"
      },
      "segment2": {
        "content": "        let start = get_cycle_count();\n        let _ = aes_encrypt_constant_time(&key2, &plaintext);\n        let end = get_cycle_count();\n        timings2.push(end - start);\n    }",
        "normalized_content": "let start = get_cycle_count(); let _ = aes_encrypt_constant_time(&key2, &plaintext); let end = get_cycle_count(); timings2.push(end - start); }",
        "hash": "32c741c4e74554ac8e635af159b325a7",
        "line_start": 6801,
        "line_end": 6805,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 17,
        "key_terms": "{'get_cycle_count', 'plaintext', 'timings2', 'aes_encrypt_constant_time'}"
      },
      "similarity_score": 0.9174917491749175,
      "match_type": "near_exact",
      "common_phrases": [
        "1000 {\n        let start = get_cycle_count();\n        let _ = aes_encrypt_constant_time(&key1, &plai...",
        "push(end - start);"
      ],
      "diff_summary": "Large diff with 11 changes. First few:\n--- \n+++ \n@@ -1,5 +1,5 @@\n-    for _ in 0..1000 {\n         let start = get_cycle_count();"
    },
    {
      "segment1": {
        "content": "    // Add edge cases\n    vectors.push(TestVector {\n        description: \"All zeros\".to_string(),\n        key: hex::encode([0u8; 32]),\n        plaintext: hex::encode([0u8; 16]),\n        ciphertext: hex::encode(aes_encrypt_reference(&[0u8; 32], &[0u8; 16])),\n        iv: None,\n        tag: None,\n    });",
        "normalized_content": "// add edge cases vectors.push(testvector { description: \"all zeros\".to_string(), key: hex::encode([0u8; 32]), plaintext: hex::encode([0u8; 16]), ciphertext: hex::encode(aes_encrypt_reference(&[0u8; 32], &[0u8; 16])), iv: none, tag: none, });",
        "hash": "686ac35d3df290db68bac7fbf2b4781c",
        "line_start": 6895,
        "line_end": 6903,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 25,
        "key_terms": "{'testvector', 'aes_encrypt_reference', 'plaintext', 'vectors', 'to_string', 'key', 'description', 'ciphertext'}"
      },
      "segment2": {
        "content": "    vectors.push(TestVector {\n        description: \"All ones\".to_string(),\n        key: hex::encode([0xffu8; 32]),\n        plaintext: hex::encode([0xffu8; 16]),\n        ciphertext: hex::encode(aes_encrypt_reference(&[0xffu8; 32], &[0xffu8; 16])),\n        iv: None,\n        tag: None,\n    });",
        "normalized_content": "vectors.push(testvector { description: \"all ones\".to_string(), key: hex::encode([0xffu8; 32]), plaintext: hex::encode([0xffu8; 16]), ciphertext: hex::encode(aes_encrypt_reference(&[0xffu8; 32], &[0xffu8; 16])), iv: none, tag: none, });",
        "hash": "0d80ef550ad24e8a78e4512065f8d786",
        "line_start": 6905,
        "line_end": 6912,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 21,
        "key_terms": "{'testvector', 'aes_encrypt_reference', 'plaintext', 'vectors', 'to_string', 'key', 'description', 'ciphertext'}"
      },
      "similarity_score": 0.9224318658280922,
      "match_type": "near_exact",
      "common_phrases": [
        "push(TestVector {\n        description: \"All zeros\"",
        "to_string(),\n        key: hex::encode([0u8; 32]),\n        plaintext: hex::encode([0u8; 16]),\n       ..."
      ],
      "diff_summary": "Large diff with 14 changes. First few:\n--- \n+++ \n@@ -1,7 +1,6 @@\n-    // Add edge cases\n     vectors.push(TestVector {"
    }
  ],
  "similar_content": [
    {
      "segment1": {
        "content": "<details>\n<summary><strong>\u25b6\ufe0f Basic Declarations and Types</strong> - Essential syntax translations</summary>",
        "normalized_content": "<details> <summary><strong>\u25b6\ufe0f basic declarations and types</strong> - essential syntax translations</summary>",
        "hash": "213e17c82e637c5f643501586a9313ee",
        "line_start": 128,
        "line_end": 129,
        "section": "1.1 C-to-Rust Syntax Mapping",
        "segment_type": "paragraph",
        "word_count": 10,
        "key_terms": "{'summary', 'details', 'declarations', 'translations', 'essential'}"
      },
      "segment2": {
        "content": "<details>\n<summary><strong>\u25b6\ufe0f Functions and Control Flow</strong> - Function syntax and control structures</summary>",
        "normalized_content": "<details> <summary><strong>\u25b6\ufe0f functions and control flow</strong> - function syntax and control structures</summary>",
        "hash": "f9560a25455695573d999703f13f35a3",
        "line_start": 150,
        "line_end": 151,
        "section": "Functions and Control Flow",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'functions', 'structures', 'summary', 'details', 'control', 'function'}"
      },
      "similarity_score": 0.7111111111111111,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n <details>\n-<summary><strong>\u25b6\ufe0f Basic Declarations and Types</strong> - Essential syntax translations</summary>\n+<summary><strong>\u25b6\ufe0f Functions and Control Flow</strong> - Function syntax and control structures</summary>"
    },
    {
      "segment1": {
        "content": "<details>\n<summary><strong>\u25b6\ufe0f Basic Declarations and Types</strong> - Essential syntax translations</summary>",
        "normalized_content": "<details> <summary><strong>\u25b6\ufe0f basic declarations and types</strong> - essential syntax translations</summary>",
        "hash": "213e17c82e637c5f643501586a9313ee",
        "line_start": 128,
        "line_end": 129,
        "section": "1.1 C-to-Rust Syntax Mapping",
        "segment_type": "paragraph",
        "word_count": 10,
        "key_terms": "{'summary', 'details', 'declarations', 'translations', 'essential'}"
      },
      "segment2": {
        "content": "<details>\n<summary><strong>\u25b6\ufe0f Installation Commands</strong> - Copy-paste installation script</summary>",
        "normalized_content": "<details> <summary><strong>\u25b6\ufe0f installation commands</strong> - copy-paste installation script</summary>",
        "hash": "16461e113613b1c5817bd1ef964d0d17",
        "line_start": 654,
        "line_end": 655,
        "section": "2.1 Rust Installation and Toolchain",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'commands', 'summary', 'installation', 'details'}"
      },
      "similarity_score": 0.7169811320754716,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n <details>\n-<summary><strong>\u25b6\ufe0f Basic Declarations and Types</strong> - Essential syntax translations</summary>\n+<summary><strong>\u25b6\ufe0f Installation Commands</strong> - Copy-paste installation script</summary>"
    },
    {
      "segment1": {
        "content": "**\u26a0\ufe0f Critical Example - Automatic Key Zeroization:**",
        "normalized_content": "\u26a0\ufe0f critical example - automatic key zeroization:",
        "hash": "d50962a751f6c3a772246973ca8f0601",
        "line_start": 417,
        "line_end": 417,
        "section": "\u26a0\ufe0f Crypto-Specific Gotchas",
        "segment_type": "paragraph",
        "word_count": 7,
        "key_terms": "{'example', 'zeroization', 'key', 'critical', 'automatic'}"
      },
      "segment2": {
        "content": "**\u26a0\ufe0f Critical Example - Constant-Time Operations:**",
        "normalized_content": "\u26a0\ufe0f critical example - constant-time operations:",
        "hash": "c48ea803083a06ee06f728b82189bfd0",
        "line_start": 442,
        "line_end": 442,
        "section": "\u26a0\ufe0f Crypto-Specific Gotchas",
        "segment_type": "paragraph",
        "word_count": 6,
        "key_terms": "{'constant', 'example', 'critical', 'operations'}"
      },
      "similarity_score": 0.7368421052631579,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1 +1 @@\n-**\u26a0\ufe0f Critical Example - Automatic Key Zeroization:**\n+**\u26a0\ufe0f Critical Example - Constant-Time Operations:**"
    },
    {
      "segment1": {
        "content": "impl OpensslAes {\n    pub fn new_cbc(key: &[u8; 32], iv: &[u8; 16]) -> Result<Self, CryptoError> {\n        let ctx = unsafe { EVP_CIPHER_CTX_new() };\n        if ctx.is_null() {\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "impl opensslaes { pub fn new_cbc(key: &[u8; 32], iv: &[u8; 16]) -> result<self, cryptoerror> { let ctx = unsafe { evp_cipher_ctx_new() }; if ctx.is_null() { return err(cryptoerror::initializationfailed); }",
        "hash": "91f14937b95b35b7f66e0c59c2486440",
        "line_start": 5690,
        "line_end": 5695,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 28,
        "key_terms": "{'cryptoerror', 'is_null', 'evp_cipher_ctx_new', 'key', 'opensslaes', 'initializationfailed', 'unsafe', 'new_cbc'}"
      },
      "segment2": {
        "content": "impl OpensslHmac {\n    pub fn new_sha256(key: &[u8]) -> Result<Self, CryptoError> {\n        let ctx = unsafe { HMAC_CTX_new() };\n        if ctx.is_null() {\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "impl opensslhmac { pub fn new_sha256(key: &[u8]) -> result<self, cryptoerror> { let ctx = unsafe { hmac_ctx_new() }; if ctx.is_null() { return err(cryptoerror::initializationfailed); }",
        "hash": "a2bf912f104afb4974339a431602f856",
        "line_start": 5809,
        "line_end": 5814,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 24,
        "key_terms": "{'cryptoerror', 'is_null', 'key', 'opensslhmac', 'hmac_ctx_new', 'unsafe', 'initializationfailed', 'new_sha256'}"
      },
      "similarity_score": 0.884318766066838,
      "match_type": "similar",
      "common_phrases": [
        "impl OpensslAes {\n    pub fn new_cbc(key: &[u8; 32], iv: &[u8; 16]) -> Result<Self, CryptoError> {\n ...",
        "is_null() {\n            return Err(CryptoError::InitializationFailed);\n        }"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,4 @@\n-impl OpensslAes {\n-    pub fn new_cbc(key: &[u8; 32], iv: &[u8; 16]) -> Result<Self, CryptoError> {\n-        let ctx = unsafe { EVP_CIPHER_CTX_new() };\n+impl OpensslHmac {\n+    pub fn new_sha256(key: &[u8]) -> Result<Self, CryptoError> {\n+        let ctx = unsafe { HMAC_CTX_new() };\n         if ctx.is_null() {"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5707,
        "line_end": 5710,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if result != 0 {\n                mbedtls_aes_free(aes.ctx.as_mut_ptr() as *mut c_void);\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if result != 0 { mbedtls_aes_free(aes.ctx.as_mut_ptr() as *mut c_void); return err(cryptoerror::initializationfailed); } }",
        "hash": "a8446632319b1c4172e341a6d4e4ba9a",
        "line_start": 5943,
        "line_end": 5947,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'cryptoerror', 'as_mut_ptr', 'mbedtls_aes_free', 'initializationfailed', 'aes'}"
      },
      "similarity_score": 0.7142857142857143,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 11 changes. First few:\n--- \n+++ \n@@ -1,4 +1,5 @@\n-        if result != 1 {\n-            unsafe { EVP_CIPHER_CTX_free(ctx) };"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5707,
        "line_end": 5710,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if dma_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }",
        "normalized_content": "if dma_result != 0 { return err(cryptoerror::initializationfailed); }",
        "hash": "9ebeea2a38b39b46b1bf5ab32bb36342",
        "line_start": 6112,
        "line_end": 6114,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'initializationfailed', 'dma_result', 'cryptoerror'}"
      },
      "similarity_score": 0.7485380116959064,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,3 @@\n-        if result != 1 {\n-            unsafe { EVP_CIPHER_CTX_free(ctx) };\n-            return Err(CryptoError::InitializationFailed);\n-        }\n+            if dma_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5707,
        "line_end": 5710,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "similarity_score": 0.7398843930635838,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,4 @@\n-        if result != 1 {\n-            unsafe { EVP_CIPHER_CTX_free(ctx) };\n-            return Err(CryptoError::InitializationFailed);\n+            if aes_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }\n         }"
    },
    {
      "segment1": {
        "content": "        Ok(Self { \n            ctx,\n            _key: *key, // Store for secure cleanup\n        })\n    }",
        "normalized_content": "ok(self { ctx, _key: *key, // store for secure cleanup }) }",
        "hash": "a7f615346ce0a8f99746b5b471a2652f",
        "line_start": 5712,
        "line_end": 5716,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'cleanup', 'key'}"
      },
      "segment2": {
        "content": "        Ok(Self {\n            ctx,\n            _key: key.to_vec(), // Store key for secure cleanup\n        })\n    }",
        "normalized_content": "ok(self { ctx, _key: key.to_vec(), // store key for secure cleanup }) }",
        "hash": "85ba8dba5fe201045850b00db0b81340",
        "line_start": 5831,
        "line_end": 5835,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'cleanup', 'key'}"
      },
      "similarity_score": 0.8923076923076924,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,4 @@\n-        Ok(Self { \n+        Ok(Self {\n             ctx,\n-            _key: *key, // Store for secure cleanup\n+            _key: key.to_vec(), // Store key for secure cleanup\n         })"
    },
    {
      "segment1": {
        "content": "    pub fn new_gcm(key: &[u8; 32], iv: &[u8; 12]) -> Result<Self, CryptoError> {\n        let ctx = unsafe { EVP_CIPHER_CTX_new() };\n        if ctx.is_null() {\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "pub fn new_gcm(key: &[u8; 32], iv: &[u8; 12]) -> result<self, cryptoerror> { let ctx = unsafe { evp_cipher_ctx_new() }; if ctx.is_null() { return err(cryptoerror::initializationfailed); }",
        "hash": "934c53b01511bd022ad875fc7d67bc60",
        "line_start": 5718,
        "line_end": 5722,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 25,
        "key_terms": "{'cryptoerror', 'is_null', 'evp_cipher_ctx_new', 'new_gcm', 'key', 'initializationfailed', 'unsafe'}"
      },
      "segment2": {
        "content": "impl OpensslHmac {\n    pub fn new_sha256(key: &[u8]) -> Result<Self, CryptoError> {\n        let ctx = unsafe { HMAC_CTX_new() };\n        if ctx.is_null() {\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "impl opensslhmac { pub fn new_sha256(key: &[u8]) -> result<self, cryptoerror> { let ctx = unsafe { hmac_ctx_new() }; if ctx.is_null() { return err(cryptoerror::initializationfailed); }",
        "hash": "a2bf912f104afb4974339a431602f856",
        "line_start": 5809,
        "line_end": 5814,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 24,
        "key_terms": "{'cryptoerror', 'is_null', 'key', 'opensslhmac', 'hmac_ctx_new', 'unsafe', 'initializationfailed', 'new_sha256'}"
      },
      "similarity_score": 0.8409703504043127,
      "match_type": "similar",
      "common_phrases": [
        "is_null() {\n            return Err(CryptoError::InitializationFailed);\n        }"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,4 @@\n-    pub fn new_gcm(key: &[u8; 32], iv: &[u8; 12]) -> Result<Self, CryptoError> {\n-        let ctx = unsafe { EVP_CIPHER_CTX_new() };\n+impl OpensslHmac {\n+    pub fn new_sha256(key: &[u8]) -> Result<Self, CryptoError> {\n+        let ctx = unsafe { HMAC_CTX_new() };\n         if ctx.is_null() {"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5734,
        "line_end": 5737,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if result != 0 {\n                mbedtls_aes_free(aes.ctx.as_mut_ptr() as *mut c_void);\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if result != 0 { mbedtls_aes_free(aes.ctx.as_mut_ptr() as *mut c_void); return err(cryptoerror::initializationfailed); } }",
        "hash": "a8446632319b1c4172e341a6d4e4ba9a",
        "line_start": 5943,
        "line_end": 5947,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'cryptoerror', 'as_mut_ptr', 'mbedtls_aes_free', 'initializationfailed', 'aes'}"
      },
      "similarity_score": 0.7142857142857143,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 11 changes. First few:\n--- \n+++ \n@@ -1,4 +1,5 @@\n-        if result != 1 {\n-            unsafe { EVP_CIPHER_CTX_free(ctx) };"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5734,
        "line_end": 5737,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if dma_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }",
        "normalized_content": "if dma_result != 0 { return err(cryptoerror::initializationfailed); }",
        "hash": "9ebeea2a38b39b46b1bf5ab32bb36342",
        "line_start": 6112,
        "line_end": 6114,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'initializationfailed', 'dma_result', 'cryptoerror'}"
      },
      "similarity_score": 0.7485380116959064,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,3 @@\n-        if result != 1 {\n-            unsafe { EVP_CIPHER_CTX_free(ctx) };\n-            return Err(CryptoError::InitializationFailed);\n-        }\n+            if dma_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { EVP_CIPHER_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { evp_cipher_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "3d886e3b9a58ac644c5823d62bfa9242",
        "line_start": 5734,
        "line_end": 5737,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'evp_cipher_ctx_free', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "similarity_score": 0.7398843930635838,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,4 @@\n-        if result != 1 {\n-            unsafe { EVP_CIPHER_CTX_free(ctx) };\n-            return Err(CryptoError::InitializationFailed);\n+            if aes_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }\n         }"
    },
    {
      "segment1": {
        "content": "    pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> Result<usize, CryptoError> {\n        if ciphertext.len() < plaintext.len() + 16 {\n            return Err(CryptoError::InsufficientBuffer);\n        }",
        "normalized_content": "pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> result<usize, cryptoerror> { if ciphertext.len() < plaintext.len() + 16 { return err(cryptoerror::insufficientbuffer); }",
        "hash": "b7312002d80b9cb3eadef5d6cafce3c4",
        "line_start": 5745,
        "line_end": 5748,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 23,
        "key_terms": "{'cryptoerror', 'insufficientbuffer', 'plaintext', 'encrypt', 'ciphertext'}"
      },
      "segment2": {
        "content": "    pub fn encrypt_cbc(&mut self, iv: &mut [u8; 16], plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), CryptoError> {\n        if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 {\n            return Err(CryptoError::InvalidInput);\n        }",
        "normalized_content": "pub fn encrypt_cbc(&mut self, iv: &mut [u8; 16], plaintext: &[u8], ciphertext: &mut [u8]) -> result<(), cryptoerror> { if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 { return err(cryptoerror::invalidinput); }",
        "hash": "eb88315f0de52dd210501b1be80049bc",
        "line_start": 5952,
        "line_end": 5955,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 31,
        "key_terms": "{'cryptoerror', 'encrypt_cbc', 'plaintext', 'invalidinput', 'ciphertext'}"
      },
      "similarity_score": 0.7971360381861575,
      "match_type": "similar",
      "common_phrases": [
        "pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> Result<usize, CryptoError> {\n ...",
        "len() < plaintext"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,4 @@\n-    pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> Result<usize, CryptoError> {\n-        if ciphertext.len() < plaintext.len() + 16 {\n-            return Err(CryptoError::InsufficientBuffer);\n+    pub fn encrypt_cbc(&mut self, iv: &mut [u8; 16], plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), CryptoError> {\n+        if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 {\n+            return Err(CryptoError::InvalidInput);\n         }"
    },
    {
      "segment1": {
        "content": "    pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> Result<usize, CryptoError> {\n        if ciphertext.len() < plaintext.len() + 16 {\n            return Err(CryptoError::InsufficientBuffer);\n        }",
        "normalized_content": "pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> result<usize, cryptoerror> { if ciphertext.len() < plaintext.len() + 16 { return err(cryptoerror::insufficientbuffer); }",
        "hash": "b7312002d80b9cb3eadef5d6cafce3c4",
        "line_start": 5745,
        "line_end": 5748,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 23,
        "key_terms": "{'cryptoerror', 'insufficientbuffer', 'plaintext', 'encrypt', 'ciphertext'}"
      },
      "segment2": {
        "content": "    pub fn encrypt_hardware(&mut self, plaintext: &[u8], ciphertext: &mut [u8], iv: &[u8; 16]) -> Result<(), CryptoError> {\n        if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 {\n            return Err(CryptoError::InvalidInput);\n        }",
        "normalized_content": "pub fn encrypt_hardware(&mut self, plaintext: &[u8], ciphertext: &mut [u8], iv: &[u8; 16]) -> result<(), cryptoerror> { if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 { return err(cryptoerror::invalidinput); }",
        "hash": "38b0e0c49b66fa0b832a8d82419eff75",
        "line_start": 6149,
        "line_end": 6152,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 30,
        "key_terms": "{'cryptoerror', 'encrypt_hardware', 'plaintext', 'invalidinput', 'ciphertext'}"
      },
      "similarity_score": 0.7952380952380952,
      "match_type": "similar",
      "common_phrases": [
        "pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> Result<usize, CryptoError> {\n ...",
        "len() < plaintext"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,4 @@\n-    pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> Result<usize, CryptoError> {\n-        if ciphertext.len() < plaintext.len() + 16 {\n-            return Err(CryptoError::InsufficientBuffer);\n+    pub fn encrypt_hardware(&mut self, plaintext: &[u8], ciphertext: &mut [u8], iv: &[u8; 16]) -> Result<(), CryptoError> {\n+        if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 {\n+            return Err(CryptoError::InvalidInput);\n         }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result != 1 {\n            unsafe { HMAC_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { hmac_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "8eaf5198d57ca160f1ba1c394b255a8e",
        "line_start": 5826,
        "line_end": 5829,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'hmac_ctx_free', 'initializationfailed', 'unsafe', 'cryptoerror'}"
      },
      "similarity_score": 0.7133757961783439,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,4 @@\n         if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);\n+            unsafe { HMAC_CTX_free(ctx) };\n+            return Err(CryptoError::InitializationFailed);\n         }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }",
        "normalized_content": "if result == 1 { ok(()) } else { err(cryptoerror::encryptionfailed) } }",
        "hash": "d1d1659afec09240f0707cf90f5cbcde",
        "line_start": 5842,
        "line_end": 5847,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8181818181818182,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 11 changes. First few:\n--- \n+++ \n@@ -1,3 +1,6 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 1 && mac_len == 32 { ok(mac) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "bfbdd30b4518dcec81957aa0a8cbe0bd",
        "line_start": 5857,
        "line_end": 5863,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 17,
        "key_terms": "{'mac_len', 'cryptoerror', 'encryptionfailed'}"
      },
      "similarity_score": 0.7105263157894737,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,3 +1,7 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 5968,
        "line_end": 5974,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7910447761194029,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,3 +1,7 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6031,
        "line_end": 6037,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7910447761194029,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,3 +1,7 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if dma_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }",
        "normalized_content": "if dma_result != 0 { return err(cryptoerror::initializationfailed); }",
        "hash": "9ebeea2a38b39b46b1bf5ab32bb36342",
        "line_start": 6112,
        "line_end": 6114,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'initializationfailed', 'dma_result', 'cryptoerror'}"
      },
      "similarity_score": 0.8461538461538461,
      "match_type": "similar",
      "common_phrases": [
        "= 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,3 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);\n-        }\n+            if dma_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "similarity_score": 0.8333333333333334,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,4 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);\n+            if aes_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }\n         }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7058823529411765,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 11 changes. First few:\n--- \n+++ \n@@ -1,3 +1,6 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5764,
        "line_end": 5766,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6164,
        "line_end": 6170,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7910447761194029,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,3 +1,7 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        total_len += outlen as usize;",
        "normalized_content": "total_len += outlen as usize;",
        "hash": "eacb2c1b285c69bbb2c0fbb81a0c9a30",
        "line_start": 5768,
        "line_end": 5768,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 5,
        "key_terms": "{'total_len'}"
      },
      "segment2": {
        "content": "        total_len += outlen as usize;\n        Ok(total_len)\n    }\n}",
        "normalized_content": "total_len += outlen as usize; ok(total_len) } }",
        "hash": "9306ecd6d202aa0e673ae232242e71b8",
        "line_start": 5783,
        "line_end": 5786,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'total_len'}"
      },
      "similarity_score": 0.7631578947368421,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1 +1,4 @@\n         total_len += outlen as usize;\n+        Ok(total_len)\n+    }\n+}"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result != 1 {\n            unsafe { HMAC_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { hmac_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "8eaf5198d57ca160f1ba1c394b255a8e",
        "line_start": 5826,
        "line_end": 5829,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'hmac_ctx_free', 'initializationfailed', 'unsafe', 'cryptoerror'}"
      },
      "similarity_score": 0.7133757961783439,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,4 @@\n         if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);\n+            unsafe { HMAC_CTX_free(ctx) };\n+            return Err(CryptoError::InitializationFailed);\n         }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }",
        "normalized_content": "if result == 1 { ok(()) } else { err(cryptoerror::encryptionfailed) } }",
        "hash": "d1d1659afec09240f0707cf90f5cbcde",
        "line_start": 5842,
        "line_end": 5847,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8181818181818182,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 11 changes. First few:\n--- \n+++ \n@@ -1,3 +1,6 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 1 && mac_len == 32 { ok(mac) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "bfbdd30b4518dcec81957aa0a8cbe0bd",
        "line_start": 5857,
        "line_end": 5863,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 17,
        "key_terms": "{'mac_len', 'cryptoerror', 'encryptionfailed'}"
      },
      "similarity_score": 0.7105263157894737,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,3 +1,7 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 5968,
        "line_end": 5974,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7910447761194029,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,3 +1,7 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6031,
        "line_end": 6037,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7910447761194029,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,3 +1,7 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if dma_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }",
        "normalized_content": "if dma_result != 0 { return err(cryptoerror::initializationfailed); }",
        "hash": "9ebeea2a38b39b46b1bf5ab32bb36342",
        "line_start": 6112,
        "line_end": 6114,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'initializationfailed', 'dma_result', 'cryptoerror'}"
      },
      "similarity_score": 0.8461538461538461,
      "match_type": "similar",
      "common_phrases": [
        "= 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,3 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);\n-        }\n+            if dma_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "similarity_score": 0.8333333333333334,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,4 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);\n+            if aes_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }\n         }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7058823529411765,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 11 changes. First few:\n--- \n+++ \n@@ -1,3 +1,6 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            return Err(CryptoError::EncryptionFailed);\n        }",
        "normalized_content": "if result != 1 { return err(cryptoerror::encryptionfailed); }",
        "hash": "22b017160953d23e9853064b68f3152f",
        "line_start": 5779,
        "line_end": 5781,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6164,
        "line_end": 6170,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7910447761194029,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,3 +1,7 @@\n-        if result != 1 {\n-            return Err(CryptoError::EncryptionFailed);"
    },
    {
      "segment1": {
        "content": "impl Drop for OpensslAes {\n    fn drop(&mut self) {\n        unsafe {\n            EVP_CIPHER_CTX_free(self.ctx);\n        }\n        // _key is automatically zeroized by compiler-generated Drop\n    }\n}",
        "normalized_content": "impl drop for opensslaes { fn drop(&mut self) { unsafe { evp_cipher_ctx_free(self.ctx); } // _key is automatically zeroized by compiler-generated drop } }",
        "hash": "7a64f7c1b371ec0a3ecc45ba29fb7f40",
        "line_start": 5788,
        "line_end": 5795,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 23,
        "key_terms": "{'generated', 'opensslaes', 'automatically', 'unsafe', 'compiler', 'zeroized', 'evp_cipher_ctx_free'}"
      },
      "segment2": {
        "content": "impl Drop for OpensslHmac {\n    fn drop(&mut self) {\n        unsafe {\n            HMAC_CTX_free(self.ctx);\n        }\n        // Zeroize key material\n        use zeroize::Zeroize;\n        self._key.zeroize();\n    }\n}",
        "normalized_content": "impl drop for opensslhmac { fn drop(&mut self) { unsafe { hmac_ctx_free(self.ctx); } // zeroize key material use zeroize::zeroize; self._key.zeroize(); } }",
        "hash": "5993228fdd14a5d9237512227ea5ebef",
        "line_start": 5865,
        "line_end": 5874,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 22,
        "key_terms": "{'material', 'key', 'opensslhmac', 'hmac_ctx_free', 'unsafe', 'zeroize'}"
      },
      "similarity_score": 0.7119741100323624,
      "match_type": "similar",
      "common_phrases": [
        "impl Drop for OpensslAes {\n    fn drop(&mut self) {\n        unsafe {\n            EVP_CIPHER_CTX_free..."
      ],
      "diff_summary": "Large diff with 15 changes. First few:\n--- \n+++ \n@@ -1,7 +1,9 @@\n-impl Drop for OpensslAes {\n+impl Drop for OpensslHmac {"
    },
    {
      "segment1": {
        "content": "impl Drop for OpensslAes {\n    fn drop(&mut self) {\n        unsafe {\n            EVP_CIPHER_CTX_free(self.ctx);\n        }\n        // _key is automatically zeroized by compiler-generated Drop\n    }\n}",
        "normalized_content": "impl drop for opensslaes { fn drop(&mut self) { unsafe { evp_cipher_ctx_free(self.ctx); } // _key is automatically zeroized by compiler-generated drop } }",
        "hash": "7a64f7c1b371ec0a3ecc45ba29fb7f40",
        "line_start": 5788,
        "line_end": 5795,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 23,
        "key_terms": "{'generated', 'opensslaes', 'automatically', 'unsafe', 'compiler', 'zeroized', 'evp_cipher_ctx_free'}"
      },
      "segment2": {
        "content": "impl Drop for MbedTlsAes {\n    fn drop(&mut self) {\n        unsafe {\n            mbedtls_aes_free(self.ctx.as_mut_ptr() as *mut c_void);\n        }\n        // _key automatically zeroized\n    }\n}",
        "normalized_content": "impl drop for mbedtlsaes { fn drop(&mut self) { unsafe { mbedtls_aes_free(self.ctx.as_mut_ptr() as *mut c_void); } // _key automatically zeroized } }",
        "hash": "85e80a42bd804b7222dc6ebf7c3c294d",
        "line_start": 5976,
        "line_end": 5983,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 22,
        "key_terms": "{'mbedtlsaes', 'as_mut_ptr', 'mbedtls_aes_free', 'automatically', 'unsafe', 'zeroized'}"
      },
      "similarity_score": 0.7128712871287128,
      "match_type": "similar",
      "common_phrases": [
        "impl Drop for OpensslAes {\n    fn drop(&mut self) {\n        unsafe {\n            EVP_CIPHER_CTX_free..."
      ],
      "diff_summary": "Large diff with 13 changes. First few:\n--- \n+++ \n@@ -1,7 +1,7 @@\n-impl Drop for OpensslAes {\n+impl Drop for MbedTlsAes {"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { HMAC_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { hmac_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "8eaf5198d57ca160f1ba1c394b255a8e",
        "line_start": 5826,
        "line_end": 5829,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'hmac_ctx_free', 'initializationfailed', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if result != 0 {\n                mbedtls_aes_free(aes.ctx.as_mut_ptr() as *mut c_void);\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if result != 0 { mbedtls_aes_free(aes.ctx.as_mut_ptr() as *mut c_void); return err(cryptoerror::initializationfailed); } }",
        "hash": "a8446632319b1c4172e341a6d4e4ba9a",
        "line_start": 5943,
        "line_end": 5947,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'cryptoerror', 'as_mut_ptr', 'mbedtls_aes_free', 'initializationfailed', 'aes'}"
      },
      "similarity_score": 0.7339449541284404,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 11 changes. First few:\n--- \n+++ \n@@ -1,4 +1,5 @@\n-        if result != 1 {\n-            unsafe { HMAC_CTX_free(ctx) };"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { HMAC_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { hmac_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "8eaf5198d57ca160f1ba1c394b255a8e",
        "line_start": 5826,
        "line_end": 5829,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'hmac_ctx_free', 'initializationfailed', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if dma_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }",
        "normalized_content": "if dma_result != 0 { return err(cryptoerror::initializationfailed); }",
        "hash": "9ebeea2a38b39b46b1bf5ab32bb36342",
        "line_start": 6112,
        "line_end": 6114,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'initializationfailed', 'dma_result', 'cryptoerror'}"
      },
      "similarity_score": 0.7757575757575758,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,3 @@\n-        if result != 1 {\n-            unsafe { HMAC_CTX_free(ctx) };\n-            return Err(CryptoError::InitializationFailed);\n-        }\n+            if dma_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { HMAC_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { hmac_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "8eaf5198d57ca160f1ba1c394b255a8e",
        "line_start": 5826,
        "line_end": 5829,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'hmac_ctx_free', 'initializationfailed', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "similarity_score": 0.7664670658682635,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,4 @@\n-        if result != 1 {\n-            unsafe { HMAC_CTX_free(ctx) };\n-            return Err(CryptoError::InitializationFailed);\n+            if aes_result != 0 {\n+                return Err(CryptoError::InitializationFailed);\n+            }\n         }"
    },
    {
      "segment1": {
        "content": "        if result != 1 {\n            unsafe { HMAC_CTX_free(ctx) };\n            return Err(CryptoError::InitializationFailed);\n        }",
        "normalized_content": "if result != 1 { unsafe { hmac_ctx_free(ctx) }; return err(cryptoerror::initializationfailed); }",
        "hash": "8eaf5198d57ca160f1ba1c394b255a8e",
        "line_start": 5826,
        "line_end": 5829,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'hmac_ctx_free', 'initializationfailed', 'unsafe', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7017543859649122,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,4 +1,6 @@\n-        if result != 1 {\n-            unsafe { HMAC_CTX_free(ctx) };"
    },
    {
      "segment1": {
        "content": "        if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }",
        "normalized_content": "if result == 1 { ok(()) } else { err(cryptoerror::encryptionfailed) } }",
        "hash": "d1d1659afec09240f0707cf90f5cbcde",
        "line_start": 5842,
        "line_end": 5847,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 1 && mac_len == 32 { ok(mac) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "bfbdd30b4518dcec81957aa0a8cbe0bd",
        "line_start": 5857,
        "line_end": 5863,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 17,
        "key_terms": "{'mac_len', 'cryptoerror', 'encryptionfailed'}"
      },
      "similarity_score": 0.8518518518518519,
      "match_type": "similar",
      "common_phrases": [
        "if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n..."
      ],
      "diff_summary": "Large diff with 11 changes. First few:\n--- \n+++ \n@@ -1,3 +1,3 @@\n-        if result == 1 {\n-            Ok(())"
    },
    {
      "segment1": {
        "content": "        if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }",
        "normalized_content": "if result == 1 { ok(()) } else { err(cryptoerror::encryptionfailed) } }",
        "hash": "d1d1659afec09240f0707cf90f5cbcde",
        "line_start": 5842,
        "line_end": 5847,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "similarity_score": 0.704225352112676,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,6 +1,4 @@\n-        if result == 1 {\n-            Ok(())"
    },
    {
      "segment1": {
        "content": "        if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }",
        "normalized_content": "if result == 1 { ok(()) } else { err(cryptoerror::encryptionfailed) } }",
        "hash": "d1d1659afec09240f0707cf90f5cbcde",
        "line_start": 5842,
        "line_end": 5847,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8904109589041096,
      "match_type": "similar",
      "common_phrases": [
        "if result == 1 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,5 +1,5 @@\n-        if result == 1 {\n+        if result == 0 {\n             Ok(())\n         } else {\n-            Err(CryptoError::EncryptionFailed)\n+            Err(CryptoError::InitializationFailed)\n         }"
    },
    {
      "segment1": {
        "content": "        if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 1 && mac_len == 32 { ok(mac) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "bfbdd30b4518dcec81957aa0a8cbe0bd",
        "line_start": 5857,
        "line_end": 5863,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 17,
        "key_terms": "{'mac_len', 'cryptoerror', 'encryptionfailed'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 5968,
        "line_end": 5974,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8536585365853658,
      "match_type": "similar",
      "common_phrases": [
        "if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,3 @@\n-        if result == 1 && mac_len == 32 {\n-            Ok(mac)\n+        if result == 0 {\n+            Ok(())\n         } else {"
    },
    {
      "segment1": {
        "content": "        if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 1 && mac_len == 32 { ok(mac) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "bfbdd30b4518dcec81957aa0a8cbe0bd",
        "line_start": 5857,
        "line_end": 5863,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 17,
        "key_terms": "{'mac_len', 'cryptoerror', 'encryptionfailed'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6031,
        "line_end": 6037,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8536585365853658,
      "match_type": "similar",
      "common_phrases": [
        "if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,3 @@\n-        if result == 1 && mac_len == 32 {\n-            Ok(mac)\n+        if result == 0 {\n+            Ok(())\n         } else {"
    },
    {
      "segment1": {
        "content": "        if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 1 && mac_len == 32 { ok(mac) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "bfbdd30b4518dcec81957aa0a8cbe0bd",
        "line_start": 5857,
        "line_end": 5863,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 17,
        "key_terms": "{'mac_len', 'cryptoerror', 'encryptionfailed'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7590361445783133,
      "match_type": "similar",
      "common_phrases": [
        "if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::..."
      ],
      "diff_summary": "Large diff with 13 changes. First few:\n--- \n+++ \n@@ -1,7 +1,6 @@\n-        if result == 1 && mac_len == 32 {\n-            Ok(mac)"
    },
    {
      "segment1": {
        "content": "        if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 1 && mac_len == 32 { ok(mac) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "bfbdd30b4518dcec81957aa0a8cbe0bd",
        "line_start": 5857,
        "line_end": 5863,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 17,
        "key_terms": "{'mac_len', 'cryptoerror', 'encryptionfailed'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6164,
        "line_end": 6170,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8536585365853658,
      "match_type": "similar",
      "common_phrases": [
        "if result == 1 && mac_len == 32 {\n            Ok(mac)\n        } else {\n            Err(CryptoError::..."
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,3 @@\n-        if result == 1 && mac_len == 32 {\n-            Ok(mac)\n+        if result == 0 {\n+            Ok(())\n         } else {"
    },
    {
      "segment1": {
        "content": "impl Drop for OpensslHmac {\n    fn drop(&mut self) {\n        unsafe {\n            HMAC_CTX_free(self.ctx);\n        }\n        // Zeroize key material\n        use zeroize::Zeroize;\n        self._key.zeroize();\n    }\n}",
        "normalized_content": "impl drop for opensslhmac { fn drop(&mut self) { unsafe { hmac_ctx_free(self.ctx); } // zeroize key material use zeroize::zeroize; self._key.zeroize(); } }",
        "hash": "5993228fdd14a5d9237512227ea5ebef",
        "line_start": 5865,
        "line_end": 5874,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 22,
        "key_terms": "{'material', 'key', 'opensslhmac', 'hmac_ctx_free', 'unsafe', 'zeroize'}"
      },
      "segment2": {
        "content": "impl Drop for XilinxHardwareCrypto {\n    fn drop(&mut self) {\n        // Hardware cleanup if needed\n        // Zeroize key buffer\n        use zeroize::Zeroize;\n        self.key_buffer.zeroize();\n    }\n}",
        "normalized_content": "impl drop for xilinxhardwarecrypto { fn drop(&mut self) { // hardware cleanup if needed // zeroize key buffer use zeroize::zeroize; self.key_buffer.zeroize(); } }",
        "hash": "0099f773f6c93c38f6e241517fb90a1f",
        "line_start": 6172,
        "line_end": 6179,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 23,
        "key_terms": "{'cleanup', 'key', 'key_buffer', 'buffer', 'xilinxhardwarecrypto', 'zeroize', 'hardware'}"
      },
      "similarity_score": 0.7003154574132492,
      "match_type": "similar",
      "common_phrases": [
        "zeroize();\n    }\n}"
      ],
      "diff_summary": "Large diff with 16 changes. First few:\n--- \n+++ \n@@ -1,9 +1,7 @@\n-impl Drop for OpensslHmac {\n+impl Drop for XilinxHardwareCrypto {"
    },
    {
      "segment1": {
        "content": "impl MbedTlsAes {\n    pub fn new(key: &[u8; 32]) -> Result<Self, CryptoError> {\n        let mut aes = Self {\n            ctx: [0; MBEDTLS_AES_CONTEXT_SIZE],\n            _key: *key,\n        };",
        "normalized_content": "impl mbedtlsaes { pub fn new(key: &[u8; 32]) -> result<self, cryptoerror> { let mut aes = self { ctx: [0; mbedtls_aes_context_size], _key: *key, };",
        "hash": "883577826b1142a65de9b1e13bf8412b",
        "line_start": 5927,
        "line_end": 5932,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 24,
        "key_terms": "{'mbedtlsaes', 'cryptoerror', 'mbedtls_aes_context_size', 'key', 'aes'}"
      },
      "segment2": {
        "content": "impl MbedTlsRng {\n    pub fn new() -> Result<Self, CryptoError> {\n        let mut rng = Self {\n            ctr_drbg_ctx: [0; MBEDTLS_CTR_DRBG_CONTEXT_SIZE],\n            entropy_ctx: [0; MBEDTLS_ENTROPY_CONTEXT_SIZE],\n        };",
        "normalized_content": "impl mbedtlsrng { pub fn new() -> result<self, cryptoerror> { let mut rng = self { ctr_drbg_ctx: [0; mbedtls_ctr_drbg_context_size], entropy_ctx: [0; mbedtls_entropy_context_size], };",
        "hash": "2909a8d2c3b89f5e7fccb2742d0903a5",
        "line_start": 5993,
        "line_end": 5998,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 23,
        "key_terms": "{'entropy_ctx', 'cryptoerror', 'ctr_drbg_ctx', 'mbedtls_entropy_context_size', 'mbedtlsrng', 'mbedtls_ctr_drbg_context_size'}"
      },
      "similarity_score": 0.7212121212121212,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 14 changes. First few:\n--- \n+++ \n@@ -1,6 +1,6 @@\n-impl MbedTlsAes {\n-    pub fn new(key: &[u8; 32]) -> Result<Self, CryptoError> {"
    },
    {
      "segment1": {
        "content": "    pub fn encrypt_cbc(&mut self, iv: &mut [u8; 16], plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), CryptoError> {\n        if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 {\n            return Err(CryptoError::InvalidInput);\n        }",
        "normalized_content": "pub fn encrypt_cbc(&mut self, iv: &mut [u8; 16], plaintext: &[u8], ciphertext: &mut [u8]) -> result<(), cryptoerror> { if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 { return err(cryptoerror::invalidinput); }",
        "hash": "eb88315f0de52dd210501b1be80049bc",
        "line_start": 5952,
        "line_end": 5955,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 31,
        "key_terms": "{'cryptoerror', 'encrypt_cbc', 'plaintext', 'invalidinput', 'ciphertext'}"
      },
      "segment2": {
        "content": "    pub fn encrypt_hardware(&mut self, plaintext: &[u8], ciphertext: &mut [u8], iv: &[u8; 16]) -> Result<(), CryptoError> {\n        if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 {\n            return Err(CryptoError::InvalidInput);\n        }",
        "normalized_content": "pub fn encrypt_hardware(&mut self, plaintext: &[u8], ciphertext: &mut [u8], iv: &[u8; 16]) -> result<(), cryptoerror> { if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 { return err(cryptoerror::invalidinput); }",
        "hash": "38b0e0c49b66fa0b832a8d82419eff75",
        "line_start": 6149,
        "line_end": 6152,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 30,
        "key_terms": "{'cryptoerror', 'encrypt_hardware', 'plaintext', 'invalidinput', 'ciphertext'}"
      },
      "similarity_score": 0.7886710239651417,
      "match_type": "similar",
      "common_phrases": [
        "pub fn encrypt_cbc(&mut self, iv: &mut [u8; 16], plaintext: &[u8], ciphertext: &mut [u8]) -> Result<...",
        "= ciphertext",
        "len() || plaintext",
        "len() % 16",
        "= 0 {\n            return Err(CryptoError::InvalidInput);\n        }"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-    pub fn encrypt_cbc(&mut self, iv: &mut [u8; 16], plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), CryptoError> {\n+    pub fn encrypt_hardware(&mut self, plaintext: &[u8], ciphertext: &mut [u8], iv: &[u8; 16]) -> Result<(), CryptoError> {\n         if plaintext.len() != ciphertext.len() || plaintext.len() % 16 != 0 {"
    },
    {
      "segment1": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 5968,
        "line_end": 5974,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "similarity_score": 0.7083333333333334,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 13 changes. First few:\n--- \n+++ \n@@ -1,7 +1,4 @@\n-        if result == 0 {\n-            Ok(())"
    },
    {
      "segment1": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 5968,
        "line_end": 5974,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8918918918918919,
      "match_type": "similar",
      "common_phrases": [
        "if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n..."
      ],
      "diff_summary": "--- \n+++ \n@@ -3,5 +3,4 @@\n         } else {\n-            Err(CryptoError::EncryptionFailed)\n+            Err(CryptoError::InitializationFailed)\n         }\n     }\n-}"
    },
    {
      "segment1": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6031,
        "line_end": 6037,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "similarity_score": 0.7083333333333334,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 13 changes. First few:\n--- \n+++ \n@@ -1,7 +1,4 @@\n-        if result == 0 {\n-            Ok(())"
    },
    {
      "segment1": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6031,
        "line_end": 6037,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8918918918918919,
      "match_type": "similar",
      "common_phrases": [
        "if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n..."
      ],
      "diff_summary": "--- \n+++ \n@@ -3,5 +3,4 @@\n         } else {\n-            Err(CryptoError::EncryptionFailed)\n+            Err(CryptoError::InitializationFailed)\n         }\n     }\n-}"
    },
    {
      "segment1": {
        "content": "            if dma_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }",
        "normalized_content": "if dma_result != 0 { return err(cryptoerror::initializationfailed); }",
        "hash": "9ebeea2a38b39b46b1bf5ab32bb36342",
        "line_start": 6112,
        "line_end": 6114,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'initializationfailed', 'dma_result', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8055555555555556,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,3 +1,6 @@\n-            if dma_result != 0 {\n-                return Err(CryptoError::InitializationFailed);"
    },
    {
      "segment1": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.821917808219178,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 12 changes. First few:\n--- \n+++ \n@@ -1,4 +1,6 @@\n-            if aes_result != 0 {\n-                return Err(CryptoError::InitializationFailed);"
    },
    {
      "segment1": {
        "content": "            if aes_result != 0 {\n                return Err(CryptoError::InitializationFailed);\n            }\n        }",
        "normalized_content": "if aes_result != 0 { return err(cryptoerror::initializationfailed); } }",
        "hash": "374a48e32707b711f2a53e404cb9dd96",
        "line_start": 6122,
        "line_end": 6125,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 9,
        "key_terms": "{'initializationfailed', 'cryptoerror', 'aes_result'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6164,
        "line_end": 6170,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.7083333333333334,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 13 changes. First few:\n--- \n+++ \n@@ -1,4 +1,7 @@\n-            if aes_result != 0 {\n-                return Err(CryptoError::InitializationFailed);"
    },
    {
      "segment1": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFailed)\n        }\n    }",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::initializationfailed) } }",
        "hash": "4ca76b704ed23485c4c1dcabaf74e210",
        "line_start": 6142,
        "line_end": 6147,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'initializationfailed', 'cryptoerror'}"
      },
      "segment2": {
        "content": "        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "normalized_content": "if result == 0 { ok(()) } else { err(cryptoerror::encryptionfailed) } } }",
        "hash": "35207d2e7446a05471326229493cbf73",
        "line_start": 6164,
        "line_end": 6170,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encryptionfailed', 'cryptoerror'}"
      },
      "similarity_score": 0.8918918918918919,
      "match_type": "similar",
      "common_phrases": [
        "if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::InitializationFail..."
      ],
      "diff_summary": "--- \n+++ \n@@ -3,4 +3,5 @@\n         } else {\n-            Err(CryptoError::InitializationFailed)\n+            Err(CryptoError::EncryptionFailed)\n         }\n     }\n+}"
    },
    {
      "segment1": {
        "content": "[target.'cfg(feature = \"openssl\")'.dependencies]\nopenssl-sys = \"0.9\"",
        "normalized_content": "[target.'cfg(feature = \"openssl\")'.dependencies] openssl-sys = \"0.9\"",
        "hash": "ec5e974e25c68a23d211795392d64ee6",
        "line_start": 6210,
        "line_end": 6211,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 6,
        "key_terms": "{'openssl', 'dependencies', 'feature'}"
      },
      "segment2": {
        "content": "[target.'cfg(feature = \"mbedtls\")'.dependencies]\nmbedtls-sys = \"2.28\"",
        "normalized_content": "[target.'cfg(feature = \"mbedtls\")'.dependencies] mbedtls-sys = \"2.28\"",
        "hash": "d2b1f6e3cd5a2138afde85b59832e32e",
        "line_start": 6213,
        "line_end": 6214,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 6,
        "key_terms": "{'mbedtls', 'dependencies', 'feature'}"
      },
      "similarity_score": 0.8175182481751825,
      "match_type": "similar",
      "common_phrases": [
        "'cfg(feature = \"openssl\")'"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-[target.'cfg(feature = \"openssl\")'.dependencies]\n-openssl-sys = \"0.9\"\n+[target.'cfg(feature = \"mbedtls\")'.dependencies]\n+mbedtls-sys = \"2.28\""
    },
    {
      "segment1": {
        "content": "    if cfg!(feature = \"mbedtls\") {\n        build_mbedtls_bindings();\n    }",
        "normalized_content": "if cfg!(feature = \"mbedtls\") { build_mbedtls_bindings(); }",
        "hash": "b933ef52b8f36983e06502d2d31117a0",
        "line_start": 6232,
        "line_end": 6234,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 7,
        "key_terms": "{'mbedtls', 'feature', 'build_mbedtls_bindings'}"
      },
      "segment2": {
        "content": "    if cfg!(feature = \"xilinx-hardware\") {\n        build_xilinx_bindings();\n    }",
        "normalized_content": "if cfg!(feature = \"xilinx-hardware\") { build_xilinx_bindings(); }",
        "hash": "49cb32315da7cd6c1e8e1a236d78207f",
        "line_start": 6236,
        "line_end": 6238,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 7,
        "key_terms": "{'hardware', 'build_xilinx_bindings', 'feature'}"
      },
      "similarity_score": 0.7479674796747967,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,3 @@\n-    if cfg!(feature = \"mbedtls\") {\n-        build_mbedtls_bindings();\n+    if cfg!(feature = \"xilinx-hardware\") {\n+        build_xilinx_bindings();\n     }"
    },
    {
      "segment1": {
        "content": "    #[derive(Debug, Deserialize)]\n    struct NistTestSuite {\n        algorithm: String,\n        key_size: u32,\n        test_vectors: Vec<NistTestVector>,\n    }",
        "normalized_content": "#[derive(debug, deserialize)] struct nisttestsuite { algorithm: string, key_size: u32, test_vectors: vec<nisttestvector>, }",
        "hash": "cd40819d94800d1d52c371c6cf555b83",
        "line_start": 6401,
        "line_end": 6406,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'nisttestvector', 'algorithm', 'deserialize', 'string', 'test_vectors', 'key_size', 'nisttestsuite', 'struct'}"
      },
      "segment2": {
        "content": "struct TestSuite {\n    algorithm: String,\n    key_size: u32,\n    description: String,\n    vectors: Vec<TestVector>,\n}",
        "normalized_content": "struct testsuite { algorithm: string, key_size: u32, description: string, vectors: vec<testvector>, }",
        "hash": "8c20096ae5342dfa9b898fcc2e25a930",
        "line_start": 6862,
        "line_end": 6867,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'testvector', 'algorithm', 'vectors', 'string', 'description', 'key_size', 'testsuite', 'struct'}"
      },
      "similarity_score": 0.7410714285714286,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "Large diff with 15 changes. First few:\n--- \n+++ \n@@ -1,6 +1,6 @@\n-    #[derive(Debug, Deserialize)]\n-    struct NistTestSuite {"
    },
    {
      "segment1": {
        "content": "    fn test_aes_ecb(key: &[u8], plaintext: &[u8]) -> Vec<u8> {\n        let ctx = AesContext::new(key).unwrap();\n        let mut ciphertext = Vec::new();",
        "normalized_content": "fn test_aes_ecb(key: &[u8], plaintext: &[u8]) -> vec<u8> { let ctx = aescontext::new(key).unwrap(); let mut ciphertext = vec::new();",
        "hash": "7b486267994cc28f287e07dee25518ea",
        "line_start": 6461,
        "line_end": 6463,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 17,
        "key_terms": "{'aescontext', 'test_aes_ecb', 'plaintext', 'key', 'ciphertext'}"
      },
      "segment2": {
        "content": "    fn test_aes_cbc(key: &[u8], iv: &[u8], plaintext: &[u8]) -> Vec<u8> {\n        let mut ctx = AesContext::new(key).unwrap();\n        let mut iv_copy = [0u8; 16];\n        iv_copy.copy_from_slice(iv);",
        "normalized_content": "fn test_aes_cbc(key: &[u8], iv: &[u8], plaintext: &[u8]) -> vec<u8> { let mut ctx = aescontext::new(key).unwrap(); let mut iv_copy = [0u8; 16]; iv_copy.copy_from_slice(iv);",
        "hash": "3717fc73ee373c817e8626815bc5ba18",
        "line_start": 6475,
        "line_end": 6478,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 22,
        "key_terms": "{'copy_from_slice', 'aescontext', 'iv_copy', 'plaintext', 'test_aes_cbc', 'key'}"
      },
      "similarity_score": 0.7697368421052632,
      "match_type": "similar",
      "common_phrases": [
        "fn test_aes_ecb(key: &[u8], plaintext: &[u8]) -> Vec<u8> {\n        let ctx = AesContext::new(key)"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,4 @@\n-    fn test_aes_ecb(key: &[u8], plaintext: &[u8]) -> Vec<u8> {\n-        let ctx = AesContext::new(key).unwrap();\n-        let mut ciphertext = Vec::new();\n+    fn test_aes_cbc(key: &[u8], iv: &[u8], plaintext: &[u8]) -> Vec<u8> {\n+        let mut ctx = AesContext::new(key).unwrap();\n+        let mut iv_copy = [0u8; 16];\n+        iv_copy.copy_from_slice(iv);"
    },
    {
      "segment1": {
        "content": "        for (key, plaintext, expected) in &test_cases {\n            // Rust implementation\n            let rust_ctx = AesContext::new(key).unwrap();\n            let rust_output = rust_ctx.encrypt_block(plaintext);",
        "normalized_content": "for (key, plaintext, expected) in &test_cases { // rust implementation let rust_ctx = aescontext::new(key).unwrap(); let rust_output = rust_ctx.encrypt_block(plaintext);",
        "hash": "562759398a280a39cfeaa25a074de0aa",
        "line_start": 6501,
        "line_end": 6504,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 18,
        "key_terms": "{'encrypt_block', 'rust', 'aescontext', 'expected', 'plaintext', 'implementation', 'key', 'test_cases', 'rust_output', 'rust_ctx'}"
      },
      "segment2": {
        "content": "        // Generate expected ciphertext using reference implementation\n        let ctx = AesContext::new(&key).unwrap();\n        let ciphertext = ctx.encrypt_block(&plaintext);",
        "normalized_content": "// generate expected ciphertext using reference implementation let ctx = aescontext::new(&key).unwrap(); let ciphertext = ctx.encrypt_block(&plaintext);",
        "hash": "aad99dc26c4f029e3a048feffdc7f3b4",
        "line_start": 6881,
        "line_end": 6883,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 15,
        "key_terms": "{'encrypt_block', 'generate', 'aescontext', 'expected', 'plaintext', 'implementation', 'key', 'reference', 'ciphertext'}"
      },
      "similarity_score": 0.7102803738317757,
      "match_type": "similar",
      "common_phrases": [
        "encrypt_block(plaintext);"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,4 +1,3 @@\n-        for (key, plaintext, expected) in &test_cases {\n-            // Rust implementation\n-            let rust_ctx = AesContext::new(key).unwrap();\n-            let rust_output = rust_ctx.encrypt_block(plaintext);\n+        // Generate expected ciphertext using reference implementation\n+        let ctx = AesContext::new(&key).unwrap();\n+        let ciphertext = ctx.encrypt_block(&plaintext);"
    },
    {
      "segment1": {
        "content": "    // Compare with software implementation\n    let sw_ctx = AesContext::new(&key).unwrap();\n    let sw_result = sw_ctx.encrypt_block(&plaintext);",
        "normalized_content": "// compare with software implementation let sw_ctx = aescontext::new(&key).unwrap(); let sw_result = sw_ctx.encrypt_block(&plaintext);",
        "hash": "1fb51b7e3c71a60e5d1f29fb36f3bcc7",
        "line_start": 6778,
        "line_end": 6780,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'encrypt_block', 'compare', 'aescontext', 'plaintext', 'software', 'implementation', 'key', 'sw_result'}"
      },
      "segment2": {
        "content": "        // Generate expected ciphertext using reference implementation\n        let ctx = AesContext::new(&key).unwrap();\n        let ciphertext = ctx.encrypt_block(&plaintext);",
        "normalized_content": "// generate expected ciphertext using reference implementation let ctx = aescontext::new(&key).unwrap(); let ciphertext = ctx.encrypt_block(&plaintext);",
        "hash": "aad99dc26c4f029e3a048feffdc7f3b4",
        "line_start": 6881,
        "line_end": 6883,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 15,
        "key_terms": "{'encrypt_block', 'generate', 'aescontext', 'expected', 'plaintext', 'implementation', 'key', 'reference', 'ciphertext'}"
      },
      "similarity_score": 0.7552447552447552,
      "match_type": "similar",
      "common_phrases": [
        "encrypt_block(&plaintext);"
      ],
      "diff_summary": "--- \n+++ \n@@ -1,3 +1,3 @@\n-    // Compare with software implementation\n-    let sw_ctx = AesContext::new(&key).unwrap();\n-    let sw_result = sw_ctx.encrypt_block(&plaintext);\n+        // Generate expected ciphertext using reference implementation\n+        let ctx = AesContext::new(&key).unwrap();\n+        let ciphertext = ctx.encrypt_block(&plaintext);"
    },
    {
      "segment1": {
        "content": "echo \"Running unit tests...\"\ncargo test --lib",
        "normalized_content": "echo \"running unit tests...\" cargo test --lib",
        "hash": "3404a4ee4a45f1f1bc09ed479dd4852d",
        "line_start": 6955,
        "line_end": 6956,
        "section": "1. Unit tests",
        "segment_type": "paragraph",
        "word_count": 7,
        "key_terms": "{'running'}"
      },
      "segment2": {
        "content": "echo \"Running integration tests...\"\ncargo test --test integration_tests",
        "normalized_content": "echo \"running integration tests...\" cargo test --test integration_tests",
        "hash": "9bcc955e282b0a265db16804659cb98f",
        "line_start": 6959,
        "line_end": 6960,
        "section": "2. Integration tests",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'running', 'integration', 'integration_tests'}"
      },
      "similarity_score": 0.7068965517241379,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-echo \"Running unit tests...\"\n-cargo test --lib\n+echo \"Running integration tests...\"\n+cargo test --test integration_tests"
    },
    {
      "segment1": {
        "content": "echo \"Running integration tests...\"\ncargo test --test integration_tests",
        "normalized_content": "echo \"running integration tests...\" cargo test --test integration_tests",
        "hash": "9bcc955e282b0a265db16804659cb98f",
        "line_start": 6959,
        "line_end": 6960,
        "section": "2. Integration tests",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'running', 'integration', 'integration_tests'}"
      },
      "segment2": {
        "content": "echo \"Running property-based tests...\"\ncargo test --test property_tests",
        "normalized_content": "echo \"running property-based tests...\" cargo test --test property_tests",
        "hash": "a44e28eef12450c45bc1f03929816a8d",
        "line_start": 6963,
        "line_end": 6964,
        "section": "3. Property-based tests",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'running', 'property_tests', 'property'}"
      },
      "similarity_score": 0.7323943661971831,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-echo \"Running integration tests...\"\n-cargo test --test integration_tests\n+echo \"Running property-based tests...\"\n+cargo test --test property_tests"
    },
    {
      "segment1": {
        "content": "echo \"Running property-based tests...\"\ncargo test --test property_tests",
        "normalized_content": "echo \"running property-based tests...\" cargo test --test property_tests",
        "hash": "a44e28eef12450c45bc1f03929816a8d",
        "line_start": 6963,
        "line_end": 6964,
        "section": "3. Property-based tests",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'running', 'property_tests', 'property'}"
      },
      "segment2": {
        "content": "echo \"Running security-focused tests...\"\ncargo test --features security-tests",
        "normalized_content": "echo \"running security-focused tests...\" cargo test --features security-tests",
        "hash": "b503a3ae37d18704c49830450d1e11b9",
        "line_start": 6978,
        "line_end": 6979,
        "section": "6. Security tests",
        "segment_type": "paragraph",
        "word_count": 8,
        "key_terms": "{'security', 'running', 'features', 'focused'}"
      },
      "similarity_score": 0.7702702702702703,
      "match_type": "similar",
      "common_phrases": [],
      "diff_summary": "--- \n+++ \n@@ -1,2 +1,2 @@\n-echo \"Running property-based tests...\"\n-cargo test --test property_tests\n+echo \"Running security-focused tests...\"\n+cargo test --features security-tests"
    }
  ],
  "conceptual_overlaps": [
    {
      "segment1": {
        "content": "**For systematic learning:** Follow the linear path: [Environment Setup](#environment-setup) \u2192 [Core Concepts](#core-language-concepts) \u2192 [Embedded Patterns](#embedded-specific-patterns) \u2192 [Crypto Implementation](#cryptography-implementation)",
        "normalized_content": "for systematic learning: follow the linear path: environment setup \u2192 core concepts \u2192 embedded patterns \u2192 crypto implementation",
        "hash": "6fc96dd6c9ffa963d3f2f17749b8c624",
        "line_start": 11,
        "line_end": 11,
        "section": "\ud83d\ude80 Quick Start Navigation",
        "segment_type": "paragraph",
        "word_count": 18,
        "key_terms": "{'language', 'specific', 'environment', 'embedded', 'concepts', 'learning', 'crypto', 'implementation', 'systematic', 'cryptography', 'patterns'}"
      },
      "segment2": {
        "content": "- Start with [Environment Setup](#environment-setup) if you're new to Rust\n- Progress through [Core Concepts](#core-language-concepts) for foundational understanding\n- Continue to [Embedded Patterns](#embedded-specific-patterns) for embedded-specific knowledge\n- Finish with [Crypto Implementation](#cryptography-implementation) for advanced topics",
        "normalized_content": "- start with environment setup if you're new to rust - progress through core concepts for foundational understanding - continue to embedded patterns for embedded-specific knowledge - finish with crypto implementation for advanced topics",
        "hash": "ca214282be269a494dc7fb8b46dc02a9",
        "line_start": 31,
        "line_end": 35,
        "section": "Document Usage Modes",
        "segment_type": "list",
        "word_count": 34,
        "key_terms": "{'rust', 'specific', 'foundational', 'language', 'progress', 'environment', 'embedded', 'knowledge', 'concepts', 'crypto', 'understanding', 'continue', 'implementation', 'through', 'cryptography', 'advanced', 'patterns'}"
      },
      "similarity_score": 0.47368421052631576,
      "match_type": "conceptual",
      "common_phrases": [
        "language",
        "specific",
        "environment",
        "embedded",
        "concepts",
        "crypto",
        "implementation",
        "patterns",
        "cryptography"
      ],
      "diff_summary": "Shares 9 key terms: language, specific, environment, embedded, concepts"
    },
    {
      "segment1": {
        "content": "**For systematic learning:** Follow the linear path: [Environment Setup](#environment-setup) \u2192 [Core Concepts](#core-language-concepts) \u2192 [Embedded Patterns](#embedded-specific-patterns) \u2192 [Crypto Implementation](#cryptography-implementation)",
        "normalized_content": "for systematic learning: follow the linear path: environment setup \u2192 core concepts \u2192 embedded patterns \u2192 crypto implementation",
        "hash": "6fc96dd6c9ffa963d3f2f17749b8c624",
        "line_start": 11,
        "line_end": 11,
        "section": "\ud83d\ude80 Quick Start Navigation",
        "segment_type": "paragraph",
        "word_count": 18,
        "key_terms": "{'language', 'specific', 'environment', 'embedded', 'concepts', 'learning', 'crypto', 'implementation', 'systematic', 'cryptography', 'patterns'}"
      },
      "segment2": {
        "content": "**\u2192 Next:** [Cryptography Implementation](#cryptography-implementation) - Secure coding patterns and crypto-specific implementations",
        "normalized_content": "\u2192 next: cryptography implementation - secure coding patterns and crypto-specific implementations",
        "hash": "d7b52c0d60cf0ac96379c5de588d1b6e",
        "line_start": 3738,
        "line_end": 3738,
        "section": "Advanced DMA-Safe Memory Management",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'specific', 'implementations', 'implementation', 'crypto', 'patterns', 'cryptography'}"
      },
      "similarity_score": 0.4166666666666667,
      "match_type": "conceptual",
      "common_phrases": [
        "specific",
        "implementation",
        "crypto",
        "patterns",
        "cryptography"
      ],
      "diff_summary": "Shares 5 key terms: specific, implementation, crypto, patterns, cryptography"
    },
    {
      "segment1": {
        "content": "**For systematic learning:** Follow the linear path: [Environment Setup](#environment-setup) \u2192 [Core Concepts](#core-language-concepts) \u2192 [Embedded Patterns](#embedded-specific-patterns) \u2192 [Crypto Implementation](#cryptography-implementation)",
        "normalized_content": "for systematic learning: follow the linear path: environment setup \u2192 core concepts \u2192 embedded patterns \u2192 crypto implementation",
        "hash": "6fc96dd6c9ffa963d3f2f17749b8c624",
        "line_start": 11,
        "line_end": 11,
        "section": "\ud83d\ude80 Quick Start Navigation",
        "segment_type": "paragraph",
        "word_count": 18,
        "key_terms": "{'language', 'specific', 'environment', 'embedded', 'concepts', 'learning', 'crypto', 'implementation', 'systematic', 'cryptography', 'patterns'}"
      },
      "segment2": {
        "content": "**\u2192 Next:** [Cryptography Implementation](#cryptography-implementation) - Secure coding patterns and crypto-specific implementations",
        "normalized_content": "\u2192 next: cryptography implementation - secure coding patterns and crypto-specific implementations",
        "hash": "d7b52c0d60cf0ac96379c5de588d1b6e",
        "line_start": 3744,
        "line_end": 3744,
        "section": "Advanced DMA-Safe Memory Management",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'specific', 'implementations', 'implementation', 'crypto', 'patterns', 'cryptography'}"
      },
      "similarity_score": 0.4166666666666667,
      "match_type": "conceptual",
      "common_phrases": [
        "specific",
        "implementation",
        "crypto",
        "patterns",
        "cryptography"
      ],
      "diff_summary": "Shares 5 key terms: specific, implementation, crypto, patterns, cryptography"
    },
    {
      "segment1": {
        "content": "- Jump to any section using the table of contents\n- Use browser search (Ctrl+F) to find specific C patterns or Rust concepts\n- Each section is self-contained with complete examples\n- Quick reference tables provide immediate answers",
        "normalized_content": "- jump to any section using the table of contents - use browser search (ctrl+f) to find specific c patterns or rust concepts - each section is self-contained with complete examples - quick reference tables provide immediate answers",
        "hash": "282f8ce3ad5dba3c33d4003990dc89b0",
        "line_start": 25,
        "line_end": 29,
        "section": "Document Usage Modes",
        "segment_type": "list",
        "word_count": 38,
        "key_terms": "{'section', 'immediate', 'specific', 'rust', 'examples', 'provide', 'contained', 'concepts', 'contents', 'complete', 'reference', 'patterns', 'answers', 'browser'}"
      },
      "segment2": {
        "content": "- Use Ctrl+F (Cmd+F) to search for specific C patterns or Rust concepts\n- Each section is designed to be self-contained for reference use\n- Code examples are complete and can be compiled directly\n- All crypto examples use production-ready crates and patterns",
        "normalized_content": "- use ctrl+f (cmd+f) to search for specific c patterns or rust concepts - each section is designed to be self-contained for reference use - code examples are complete and can be compiled directly - all crypto examples use production-ready crates and patterns",
        "hash": "01882aa93cd37d84da978a997669dfc5",
        "line_start": 627,
        "line_end": 631,
        "section": "Cross-Reference System",
        "segment_type": "list",
        "word_count": 43,
        "key_terms": "{'section', 'rust', 'specific', 'designed', 'examples', 'compiled', 'directly', 'production', 'contained', 'concepts', 'crypto', 'reference', 'complete', 'patterns'}"
      },
      "similarity_score": 0.47368421052631576,
      "match_type": "conceptual",
      "common_phrases": [
        "section",
        "rust",
        "specific",
        "examples",
        "contained",
        "concepts",
        "reference",
        "complete",
        "patterns"
      ],
      "diff_summary": "Shares 9 key terms: section, rust, specific, examples, contained"
    },
    {
      "segment1": {
        "content": "- [3.1 Ownership and Memory Management](#ownership-and-memory-management)\n- [3.2 Error Handling Without Exceptions](#error-handling-without-exceptions)\n- [3.3 Type System Advantages](#type-system-advantages)\n- [3.4 Memory Model Differences](#memory-model-differences)\n- [3.5 Safety Guarantees for Crypto](#safety-guarantees-for-crypto)",
        "normalized_content": "- 3.1 ownership and memory management - 3.2 error handling without exceptions - 3.3 type system advantages - 3.4 memory model differences - 3.5 safety guarantees for crypto",
        "hash": "2985317dff994b1a9bee528e91f0f6e2",
        "line_start": 71,
        "line_end": 76,
        "section": "[3. Core Language Concepts](#core-language-concepts)",
        "segment_type": "list",
        "word_count": 28,
        "key_terms": "{'guarantees', 'differences', 'exceptions', 'ownership', 'management', 'crypto', 'advantages', 'memory', 'without', 'handling'}"
      },
      "segment2": {
        "content": "1. **Start here:** [Ownership and Memory Management](#ownership-and-memory-management) - The foundation of Rust\n2. **Then:** [Error Handling](#error-handling-without-exceptions) - Replace errno with Result types\n3. **Next:** [Type System](#type-system-advantages) - Leverage compile-time safety\n4. **Finally:** [Safety Guarantees](#safety-guarantees-for-crypto) - Apply to crypto development",
        "normalized_content": "1. start here: ownership and memory management - the foundation of rust 2. then: error handling - replace errno with result types 3. next: type system - leverage compile-time safety 4. finally: safety guarantees - apply to crypto development",
        "hash": "b0476495c4f3a2cbad9509b30d6d8467",
        "line_start": 867,
        "line_end": 871,
        "section": "Learning Path",
        "segment_type": "list",
        "word_count": 39,
        "key_terms": "{'replace', 'rust', 'guarantees', 'exceptions', 'ownership', 'management', 'finally', 'development', 'leverage', 'crypto', 'advantages', 'memory', 'foundation', 'without', 'handling', 'compile'}"
      },
      "similarity_score": 0.5294117647058824,
      "match_type": "conceptual",
      "common_phrases": [
        "guarantees",
        "exceptions",
        "ownership",
        "management",
        "crypto",
        "advantages",
        "memory",
        "without",
        "handling"
      ],
      "diff_summary": "Shares 9 key terms: guarantees, exceptions, ownership, management, crypto"
    },
    {
      "segment1": {
        "content": "**\u2705 Setup Complete** - Your environment is ready for embedded Rust crypto development.",
        "normalized_content": "\u2705 setup complete - your environment is ready for embedded rust crypto development.",
        "hash": "50cde2b00330e30a0d8da7ba1945895c",
        "line_start": 855,
        "line_end": 855,
        "section": "Minimal Verification Application",
        "segment_type": "paragraph",
        "word_count": 13,
        "key_terms": "{'rust', 'environment', 'embedded', 'development', 'crypto', 'complete'}"
      },
      "segment2": {
        "content": "Essential debugging techniques and tools for embedded Rust crypto development.",
        "normalized_content": "essential debugging techniques and tools for embedded rust crypto development.",
        "hash": "7119543a952e6f0737d2caab87505b9f",
        "line_start": 7064,
        "line_end": 7064,
        "section": "6.4 Debugging and Tooling",
        "segment_type": "paragraph",
        "word_count": 10,
        "key_terms": "{'rust', 'techniques', 'embedded', 'development', 'debugging', 'crypto', 'essential'}"
      },
      "similarity_score": 0.4444444444444444,
      "match_type": "conceptual",
      "common_phrases": [
        "crypto",
        "rust",
        "embedded",
        "development"
      ],
      "diff_summary": "Shares 4 key terms: crypto, rust, embedded, development"
    },
    {
      "segment1": {
        "content": "**\u2192 Next:** [Core Language Concepts](#core-language-concepts) - Essential Rust concepts for crypto development",
        "normalized_content": "\u2192 next: core language concepts - essential rust concepts for crypto development",
        "hash": "c7bcf539a964eada5bbe15568241d750",
        "line_start": 857,
        "line_end": 857,
        "section": "Minimal Verification Application",
        "segment_type": "paragraph",
        "word_count": 12,
        "key_terms": "{'language', 'rust', 'development', 'concepts', 'crypto', 'essential'}"
      },
      "segment2": {
        "content": "Essential debugging techniques and tools for embedded Rust crypto development.",
        "normalized_content": "essential debugging techniques and tools for embedded rust crypto development.",
        "hash": "7119543a952e6f0737d2caab87505b9f",
        "line_start": 7064,
        "line_end": 7064,
        "section": "6.4 Debugging and Tooling",
        "segment_type": "paragraph",
        "word_count": 10,
        "key_terms": "{'rust', 'techniques', 'embedded', 'development', 'debugging', 'crypto', 'essential'}"
      },
      "similarity_score": 0.4444444444444444,
      "match_type": "conceptual",
      "common_phrases": [
        "crypto",
        "rust",
        "development",
        "essential"
      ],
      "diff_summary": "Shares 4 key terms: crypto, rust, development, essential"
    },
    {
      "segment1": {
        "content": "Rust's type system encodes security invariants at compile time, preventing entire classes of cryptographic vulnerabilities that are common in C implementations.",
        "normalized_content": "rust's type system encodes security invariants at compile time, preventing entire classes of cryptographic vulnerabilities that are common in c implementations.",
        "hash": "303a8d2d52b7fef6d85f19f49bf5b25f",
        "line_start": 1266,
        "line_end": 1266,
        "section": "3.3 Type System Advantages for Security",
        "segment_type": "paragraph",
        "word_count": 21,
        "key_terms": "{'rust', 'compile', 'implementations', 'preventing', 'encodes', 'invariants', 'cryptographic', 'classes', 'vulnerabilities', 'security'}"
      },
      "segment2": {
        "content": "Rust eliminates entire classes of vulnerabilities that plague C cryptographic implementations:",
        "normalized_content": "rust eliminates entire classes of vulnerabilities that plague c cryptographic implementations:",
        "hash": "03f976933fea5d90c95553fdcdab94b5",
        "line_start": 3768,
        "line_end": 3768,
        "section": "Memory Safety Advantages for Cryptography",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'rust', 'implementations', 'cryptographic', 'classes', 'vulnerabilities', 'eliminates'}"
      },
      "similarity_score": 0.45454545454545453,
      "match_type": "conceptual",
      "common_phrases": [
        "rust",
        "implementations",
        "cryptographic",
        "classes",
        "vulnerabilities"
      ],
      "diff_summary": "Shares 5 key terms: rust, implementations, cryptographic, classes, vulnerabilities"
    },
    {
      "segment1": {
        "content": "This section consolidates all static memory management patterns for deterministic embedded crypto applications, providing comprehensive coverage of memory pool management, compile-time allocation, and secure memory handling.",
        "normalized_content": "this section consolidates all static memory management patterns for deterministic embedded crypto applications, providing comprehensive coverage of memory pool management, compile-time allocation, and secure memory handling.",
        "hash": "eddebfa7f9d85048fed3693b0234d544",
        "line_start": 2792,
        "line_end": 2792,
        "section": "4.4 Static Memory Management",
        "segment_type": "paragraph",
        "word_count": 26,
        "key_terms": "{'section', 'consolidates', 'applications', 'comprehensive', 'management', 'deterministic', 'embedded', 'crypto', 'coverage', 'allocation', 'memory', 'patterns', 'providing', 'handling', 'compile'}"
      },
      "segment2": {
        "content": "This section consolidates all DMA and hardware integration patterns for high-performance crypto operations, providing comprehensive coverage of DMA-safe memory management, hardware crypto acceleration, and performance optimization.",
        "normalized_content": "this section consolidates all dma and hardware integration patterns for high-performance crypto operations, providing comprehensive coverage of dma-safe memory management, hardware crypto acceleration, and performance optimization.",
        "hash": "163dacf8f4c3db54e9c6bf5cea2c2ee2",
        "line_start": 3277,
        "line_end": 3277,
        "section": "4.5 DMA and Hardware Integration",
        "segment_type": "paragraph",
        "word_count": 26,
        "key_terms": "{'section', 'consolidates', 'comprehensive', 'management', 'integration', 'acceleration', 'operations', 'crypto', 'coverage', 'memory', 'hardware', 'optimization', 'patterns', 'performance', 'providing', 'dma'}"
      },
      "similarity_score": 0.4090909090909091,
      "match_type": "conceptual",
      "common_phrases": [
        "section",
        "consolidates",
        "comprehensive",
        "management",
        "crypto",
        "coverage",
        "memory",
        "patterns",
        "providing"
      ],
      "diff_summary": "Shares 9 key terms: section, consolidates, comprehensive, management, crypto"
    },
    {
      "segment1": {
        "content": "    pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> Result<usize, CryptoError> {\n        if ciphertext.len() < plaintext.len() + 16 {\n            return Err(CryptoError::InsufficientBuffer);\n        }",
        "normalized_content": "pub fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> result<usize, cryptoerror> { if ciphertext.len() < plaintext.len() + 16 { return err(cryptoerror::insufficientbuffer); }",
        "hash": "b7312002d80b9cb3eadef5d6cafce3c4",
        "line_start": 5745,
        "line_end": 5748,
        "section": "Migration Validation Checklist",
        "segment_type": "paragraph",
        "word_count": 23,
        "key_terms": "{'cryptoerror', 'insufficientbuffer', 'plaintext', 'encrypt', 'ciphertext'}"
      },
      "segment2": {
        "content": "        // Encrypt then decrypt\n        let mut ciphertext = vec![0u8; plaintext.len()];\n        let mut decrypted = vec![0u8; plaintext.len()];",
        "normalized_content": "// encrypt then decrypt let mut ciphertext = vec![0u8; plaintext.len()]; let mut decrypted = vec![0u8; plaintext.len()];",
        "hash": "de068edd08a7079ca37d2d514310ba55",
        "line_start": 6559,
        "line_end": 6561,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 16,
        "key_terms": "{'plaintext', 'decrypt', 'decrypted', 'encrypt', 'ciphertext'}"
      },
      "similarity_score": 0.42857142857142855,
      "match_type": "conceptual",
      "common_phrases": [
        "plaintext",
        "ciphertext",
        "encrypt"
      ],
      "diff_summary": "Shares 3 key terms: plaintext, ciphertext, encrypt"
    },
    {
      "segment1": {
        "content": "fn test_cross_compilation_targets() {\n    let targets = [\n        \"thumbv7em-none-eabihf\",\n        \"armv7r-none-eabihf\",\n        \"thumbv8m.main-none-eabihf\",\n    ];",
        "normalized_content": "fn test_cross_compilation_targets() { let targets = [ \"thumbv7em-none-eabihf\", \"armv7r-none-eabihf\", \"thumbv8m.main-none-eabihf\", ];",
        "hash": "c04ab89b6f6129f7668cc19ccab9129c",
        "line_start": 6660,
        "line_end": 6665,
        "section": "Link to crypto libraries based on features",
        "segment_type": "paragraph",
        "word_count": 11,
        "key_terms": "{'targets', 'thumbv7em', 'thumbv8m', 'test_cross_compilation_targets'}"
      },
      "segment2": {
        "content": "    - name: Install embedded targets\n      run: |\n        rustup target add thumbv7em-none-eabihf\n        rustup target add armv7r-none-eabihf\n        rustup target add thumbv8m.main-none-eabihf",
        "normalized_content": "- name: install embedded targets run: | rustup target add thumbv7em-none-eabihf rustup target add armv7r-none-eabihf rustup target add thumbv8m.main-none-eabihf",
        "hash": "140b9d66779c07c8a42b3e0989d3cfff",
        "line_start": 7023,
        "line_end": 7027,
        "section": ".github/workflows/crypto_tests.yml",
        "segment_type": "paragraph",
        "word_count": 19,
        "key_terms": "{'embedded', 'targets', 'thumbv7em', 'thumbv8m', 'install'}"
      },
      "similarity_score": 0.5,
      "match_type": "conceptual",
      "common_phrases": [
        "targets",
        "thumbv7em",
        "thumbv8m"
      ],
      "diff_summary": "Shares 3 key terms: targets, thumbv7em, thumbv8m"
    }
  ],
  "redundancy_statistics": {
    "total_segments": 402,
    "exact_duplicates": 7,
    "near_duplicates": 16,
    "similar_content": 66,
    "conceptual_overlaps": 11,
    "total_redundancy_issues": 100,
    "paragraph_segments": 284,
    "list_segments": 26,
    "table_segments": 12,
    "code_rust_segments": 58,
    "code_bash_segments": 3,
    "code_toml_segments": 3,
    "code_segments": 16
  },
  "section_analysis": {
    "Embedded Rust Tutorial for Cryptography Engineers": {
      "total_segments": 1,
      "paragraph": 1
    },
    "\ud83d\ude80 Quick Start Navigation": {
      "total_segments": 3,
      "paragraph": 3
    },
    "\ud83d\udccb Table of Contents": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Document Usage Modes": {
      "total_segments": 6,
      "paragraph": 3,
      "list": 3
    },
    "Navigation Features": {
      "total_segments": 2,
      "list": 2
    },
    "[1. Quick Reference](#quick-reference)": {
      "total_segments": 1,
      "list": 1
    },
    "[2. Environment Setup](#environment-setup)": {
      "total_segments": 1,
      "list": 1
    },
    "[3. Core Language Concepts](#core-language-concepts)": {
      "total_segments": 1,
      "list": 1
    },
    "[4. Embedded-Specific Patterns](#embedded-specific-patterns)": {
      "total_segments": 1,
      "list": 1
    },
    "[5. Cryptography Implementation](#cryptography-implementation)": {
      "total_segments": 1,
      "list": 1
    },
    "[6. Migration and Integration](#migration-and-integration)": {
      "total_segments": 1,
      "list": 1
    },
    "Introduction": {
      "total_segments": 5,
      "paragraph": 3,
      "list": 2
    },
    "1. Quick Reference": {
      "total_segments": 1,
      "paragraph": 1
    },
    "1.1 C-to-Rust Syntax Mapping": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Basic Declarations and Types": {
      "total_segments": 1,
      "table": 1
    },
    "Functions and Control Flow": {
      "total_segments": 2,
      "paragraph": 1,
      "table": 1
    },
    "1.2 Memory and Pointer Patterns": {
      "total_segments": 1,
      "table": 1
    },
    "Error Handling Patterns": {
      "total_segments": 1,
      "table": 1
    },
    "Result Type Usage": {
      "total_segments": 1,
      "code_rust": 1
    },
    "1.5 Crypto-Specific Quick Reference": {
      "total_segments": 1,
      "table": 1
    },
    "Secure Key Management Example": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Hardware and System Programming": {
      "total_segments": 1,
      "table": 1
    },
    "Memory Management and Collections": {
      "total_segments": 1,
      "table": 1
    },
    "Crypto Hardware Integration": {
      "total_segments": 1,
      "table": 1
    },
    "No-std Complete Template": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Xilinx-Specific Patterns": {
      "total_segments": 1,
      "table": 1
    },
    "\u26a0\ufe0f Memory Management Gotchas": {
      "total_segments": 3,
      "table": 1,
      "paragraph": 1,
      "code_rust": 1
    },
    "\u26a0\ufe0f Crypto-Specific Gotchas": {
      "total_segments": 5,
      "table": 1,
      "paragraph": 2,
      "code_rust": 2
    },
    "\u26a0\ufe0f Embedded-Specific Gotchas": {
      "total_segments": 5,
      "table": 1,
      "paragraph": 2,
      "code_rust": 2
    },
    "\u26a0\ufe0f Common Migration Pitfalls": {
      "total_segments": 4,
      "code_rust": 3,
      "paragraph": 1
    },
    "Cross-Reference System": {
      "total_segments": 3,
      "paragraph": 1,
      "list": 2
    },
    "2. Environment Setup": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Quick Setup Checklist": {
      "total_segments": 3,
      "list": 1,
      "paragraph": 2
    },
    "2.1 Rust Installation and Toolchain": {
      "total_segments": 2,
      "paragraph": 1,
      "code_bash": 1
    },
    "2.2 Target Configuration": {
      "total_segments": 2,
      "paragraph": 2
    },
    "2.2.1 Xilinx Ultrascale+ (Cortex-R5)": {
      "total_segments": 2,
      "code_toml": 1,
      "code_rust": 1
    },
    "2.2.2 ARM Cortex-M Series": {
      "total_segments": 1,
      "code_toml": 1
    },
    "2.2.3 Other Embedded Targets": {
      "total_segments": 1,
      "code_bash": 1
    },
    "2.3 Project Structure and Dependencies": {
      "total_segments": 2,
      "code_toml": 1,
      "code": 1
    },
    "2.4 Build Configuration": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Step-by-Step Setup Verification": {
      "total_segments": 1,
      "code_bash": 1
    },
    "Minimal Verification Application": {
      "total_segments": 3,
      "code_rust": 1,
      "paragraph": 2
    },
    "3. Core Language Concepts": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Learning Path": {
      "total_segments": 1,
      "list": 1
    },
    "Key Differences from C": {
      "total_segments": 1,
      "list": 1
    },
    "Quick Reference Links": {
      "total_segments": 2,
      "list": 1,
      "paragraph": 1
    },
    "3.1 Ownership and Memory Management": {
      "total_segments": 1,
      "paragraph": 1
    },
    "The Three Rules of Ownership": {
      "total_segments": 4,
      "list": 2,
      "paragraph": 2
    },
    "Ownership in Embedded Crypto Context": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Borrowing Rules for Crypto Operations": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Memory Management Patterns for Embedded": {
      "total_segments": 1,
      "code_rust": 1
    },
    "3.2 Error Handling Without Exceptions": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Comprehensive Crypto Error Types": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Error Propagation in Crypto Pipelines": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Option Types for Safe Nullable Crypto State": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Error Recovery Patterns for Embedded Crypto": {
      "total_segments": 1,
      "code_rust": 1
    },
    "3.3 Type System Advantages for Security": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Type-Safe Protocol State Machines": {
      "total_segments": 3,
      "code_rust": 2,
      "paragraph": 1
    },
    "Const Generics for Compile-Time Crypto Parameters": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Newtype Pattern for Domain-Specific Security": {
      "total_segments": 2,
      "code_rust": 1,
      "paragraph": 1
    },
    "4. Embedded-Specific Patterns": {
      "total_segments": 1,
      "paragraph": 1
    },
    "4.1 No-std Programming Essentials": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Complete No-std Project Template": {
      "total_segments": 1,
      "code_rust": 1
    },
    "No-std Memory Management Patterns": {
      "total_segments": 1,
      "code_rust": 1
    },
    "No-std Error Handling and Result Types": {
      "total_segments": 1,
      "code_rust": 1
    },
    "4.2 Hardware Abstraction Patterns": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Peripheral Access Crate (PAC) Usage": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Hardware Abstraction Layer (HAL) Patterns": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Cross-Platform Hardware Abstraction": {
      "total_segments": 1,
      "code_rust": 1
    },
    "4.3 Interrupt Handling": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Safe Interrupt Handling Fundamentals": {
      "total_segments": 1,
      "code_rust": 1
    },
    "RTIC Framework for Real-Time Crypto": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Interrupt Priority and Timing Considerations": {
      "total_segments": 1,
      "code_rust": 1
    },
    "4.4 Static Memory Management": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Advanced Static Memory Pool Management": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Compile-Time Memory Layout with Security Features": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Memory Layout Optimization for Crypto Performance": {
      "total_segments": 1,
      "code_rust": 1
    },
    "4.5 DMA and Hardware Integration": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Advanced DMA-Safe Memory Management": {
      "total_segments": 8,
      "code_rust": 1,
      "paragraph": 6,
      "list": 1
    },
    "5.1 Secure Coding Patterns": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Memory Safety Advantages for Cryptography": {
      "total_segments": 2,
      "paragraph": 1,
      "code_rust": 1
    },
    "Automatic Key Zeroization Patterns": {
      "total_segments": 4,
      "paragraph": 2,
      "code_rust": 2
    },
    "Rust-Specific Security Advantages": {
      "total_segments": 2,
      "paragraph": 1,
      "code_rust": 1
    },
    "5.2 Constant-Time Implementations": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Understanding Side-Channel Vulnerabilities": {
      "total_segments": 2,
      "paragraph": 1,
      "code_rust": 1
    },
    "Using the `subtle` Crate for Constant-Time Operations": {
      "total_segments": 2,
      "paragraph": 1,
      "code_rust": 1
    },
    "Advanced Constant-Time Patterns": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Manual Constant-Time Implementations": {
      "total_segments": 2,
      "paragraph": 1,
      "code_rust": 1
    },
    "Embedded-Specific Constant-Time Considerations": {
      "total_segments": 1,
      "code_rust": 1
    },
    "5.3 Key Management and Zeroization": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Hierarchical Key Derivation with Automatic Cleanup": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Secure Random Number Generation with Hardware Integration": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Key Lifecycle Management": {
      "total_segments": 1,
      "code_rust": 1
    },
    "5.4 Hardware Crypto Acceleration": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Generic Hardware Abstraction": {
      "total_segments": 1,
      "code_rust": 1
    },
    "5.5 Side-Channel Mitigations": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Power Analysis Protection": {
      "total_segments": 1,
      "code_rust": 1
    },
    "6. Migration and Integration": {
      "total_segments": 1,
      "paragraph": 1
    },
    "6.1 Incremental Migration Strategies": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Step 1: Assessment and Planning": {
      "total_segments": 1,
      "list": 1
    },
    "Step 2: Module-by-Module Migration": {
      "total_segments": 2,
      "paragraph": 1,
      "code_rust": 1
    },
    "Step 3: Protocol-Level Migration": {
      "total_segments": 2,
      "paragraph": 1,
      "code_rust": 1
    },
    "Step 4: Application Integration Migration": {
      "total_segments": 2,
      "paragraph": 1,
      "code_rust": 1
    },
    "Step 5: Hardware Abstraction Layer Migration": {
      "total_segments": 2,
      "paragraph": 1,
      "code_rust": 1
    },
    "Migration Validation Checklist": {
      "total_segments": 84,
      "list": 1,
      "code": 5,
      "paragraph": 78
    },
    "Feature flags for different crypto backends": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Link to crypto libraries based on features": {
      "total_segments": 122,
      "paragraph": 114,
      "code": 8
    },
    "scripts/run_crypto_tests.sh - Comprehensive test runner": {
      "total_segments": 1,
      "paragraph": 1
    },
    "1. Unit tests": {
      "total_segments": 1,
      "paragraph": 1
    },
    "2. Integration tests": {
      "total_segments": 1,
      "paragraph": 1
    },
    "3. Property-based tests": {
      "total_segments": 1,
      "paragraph": 1
    },
    "4. Cross-compilation tests": {
      "total_segments": 1,
      "paragraph": 1
    },
    "5. Performance benchmarks": {
      "total_segments": 1,
      "paragraph": 1
    },
    "6. Security tests": {
      "total_segments": 1,
      "paragraph": 1
    },
    "7. Hardware tests (if available)": {
      "total_segments": 1,
      "paragraph": 1
    },
    "8. Memory usage analysis": {
      "total_segments": 1,
      "paragraph": 1
    },
    "9. Test coverage": {
      "total_segments": 3,
      "paragraph": 2,
      "code": 1
    },
    ".github/workflows/crypto_tests.yml": {
      "total_segments": 9,
      "paragraph": 8,
      "code": 1
    },
    "6.4 Debugging and Tooling": {
      "total_segments": 1,
      "paragraph": 1
    },
    "RTT Debugging for Crypto": {
      "total_segments": 1,
      "code_rust": 1
    },
    "6.5 Performance Considerations": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Benchmarking and Profiling": {
      "total_segments": 1,
      "code_rust": 1
    },
    "Conclusion": {
      "total_segments": 1,
      "paragraph": 1
    },
    "Key Benefits of This Structure": {
      "total_segments": 1,
      "list": 1
    },
    "Next Steps": {
      "total_segments": 2,
      "list": 1,
      "paragraph": 1
    }
  }
}