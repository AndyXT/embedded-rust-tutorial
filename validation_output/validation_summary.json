{
  "document_path": "embedded-rust-tutorial.md",
  "validation_timestamp": "2025-07-14T22:33:59.280456",
  "total_issues": 218,
  "critical_issues": 70,
  "warnings": 148,
  "code_validation": {
    "total_examples": 98,
    "syntax_valid": 28,
    "compiles": 28,
    "success_rate": 0.2857142857142857,
    "failed_examples": 70,
    "critical_failures": 70,
    "report_path": "validation_output/code_validation_report.md",
    "details": [
      {
        "section": "Quick Syntax Reference",
        "line_number": 102,
        "language": "rust",
        "code": "// Variable declarations\nlet x = 5;              // Immutable\nlet mut y = 10;         // Mutable\nconst MAX: u32 = 100;   // Compile-time constant\n\n// Arrays and slices\nlet arr = [1, 2, 3, 4, 5];           // Fixed-size array\nlet slice = &arr[1..4];              // Slice (view into array)\nlet mut vec = vec![1, 2, 3];         // Dynamic array (heap)\n\n// Functions\nfn add(a: i32, b: i32) -> i32 {\n    a + b  // No semicolon = return value\n}\n\n// Structs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\n// Enums (much more powerful than C)\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n}\n\n// Pattern matching\nmatch message {\n    Message::Quit => println!(\"Quit\"),\n    Message::Move { x, y } => println!(\"Move to ({}, {})\", x, y),\n    Message::Write(text) => println!(\"Text: {}\", text),\n}\n\n// Error handling\nfn divide(a: f64, b: f64) -> Result<f64, &'static str> {\n    if b == 0.0 {\n        Err(\"Division by zero\")\n    } else {\n        Ok(a / b)\n    }\n}\n\n// Using results\nmatch divide(10.0, 2.0) {\n    Ok(result) => println!(\"Result: {}\", result),\n    Err(error) => println!(\"Error: {}\", error),\n}\n\n// Or with ? operator\nfn calculate() -> Result<f64, &'static str> {\n    let result = divide(10.0, 2.0)?;  // Propagates error automatically\n    Ok(result * 2.0)\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Embedded-Specific Quick Reference",
        "line_number": 162,
        "language": "rust",
        "code": "// No-std setup\n#![no_std]\n#![no_main]\n\n// Panic handler (required in no-std)\nuse panic_halt as _;\n\n// Entry point\nuse cortex_m_rt::entry;\n\n#[entry]\nfn main() -> ! {\n    // Your code here\n    loop {\n        // Main loop\n    }\n}\n\n// Hardware register access\nuse core::ptr;\n\nconst GPIO_BASE: *mut u32 = 0x4000_0000 as *mut u32;\n\nunsafe {\n    ptr::write_volatile(GPIO_BASE, 0x1234);\n    let value = ptr::read_volatile(GPIO_BASE);\n}\n\n// Interrupt handlers\nuse cortex_m_rt::exception;\n\n#[exception]\nfn SysTick() {\n    // SysTick interrupt handler\n}\n\n// Static allocation (no heap)\nuse heapless::Vec;\n\nlet mut buffer: Vec<u8, 256> = Vec::new();  // Max 256 elements\nbuffer.push(42).unwrap();",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "For static collections",
        "line_number": 245,
        "language": "toml",
        "code": "# Cargo.toml\n[package]\nname = \"my_crypto_app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n# Core embedded dependencies\ncortex-m = \"0.7\"\ncortex-m-rt = \"0.7\"\npanic-halt = \"0.2\"\nembedded-hal = \"0.2\"\n\n# HAL for your specific MCU (examples):\n# stm32f4xx-hal = { version = \"0.14\", features = [\"stm32f411\"] }\n# nrf52840-hal = \"0.16\"\n# rp2040-hal = \"0.9\"\n\n# Crypto dependencies\nchacha20poly1305 = { version = \"0.10\", default-features = false }\naes-gcm = { version = \"0.10\", default-features = false }\nsha2 = { version = \"0.10\", default-features = false }\nhmac = { version = \"0.12\", default-features = false }\nsubtle = { version = \"2.5\", default-features = false }\n\n# For static collections\nheapless = \"0.7\"\n\n[profile.release]\nopt-level = \"z\"     # Optimize for size\nlto = true          # Link-time optimization\ndebug = true        # Keep debug symbols for debugging\nstrip = false       # Don't strip symbols",
        "syntax_valid": true,
        "compiles": true,
        "errors": [],
        "warnings": []
      },
      {
        "section": "target = \"armv7r-none-eabi\"",
        "line_number": 285,
        "language": "toml",
        "code": "# .cargo/config.toml for Xilinx Ultrascale+ Cortex-R5\n[target.armv7r-none-eabihf]\n# Xilinx typically uses JTAG debugging through Vitis/XSCT\n# You may need custom runners or use Xilinx tools directly\nrunner = \"echo 'Use Xilinx Vitis or XSCT for debugging'\"\nrustflags = [\n  \"-C\", \"link-arg=-Tlink.x\",\n  \"-C\", \"target-cpu=cortex-r5\",\n  # Enable VFP if using floating point\n  \"-C\", \"target-feature=+vfp3\",\n]\n\n[build]\ntarget = \"armv7r-none-eabihf\"\n\n# Alternative for non-FPU version\n# [target.armv7r-none-eabi]\n# runner = \"echo 'Use Xilinx Vitis or XSCT for debugging'\"\n# rustflags = [\n#   \"-C\", \"link-arg=-Tlink.x\",\n#   \"-C\", \"target-cpu=cortex-r5\",\n# ]\n# [build]\n# target = \"armv7r-none-eabi\"",
        "syntax_valid": true,
        "compiles": true,
        "errors": [],
        "warnings": []
      },
      {
        "section": "target = \"armv7r-none-eabi\"",
        "line_number": 312,
        "language": "rust",
        "code": "// memory.x - Xilinx Ultrascale+ ZynqMP Cortex-R5 memory layout\n// This example is for ZynqMP with typical R5 configuration\nMEMORY\n{\n  /* Cortex-R5 TCM (Tightly Coupled Memory) - fastest access */\n  ATCM : ORIGIN = 0x00000000, LENGTH = 64K   /* Instruction TCM */\n  BTCM : ORIGIN = 0x00020000, LENGTH = 64K   /* Data TCM */\n  \n  /* OCM (On-Chip Memory) - shared between cores */\n  OCM : ORIGIN = 0xFFFC0000, LENGTH = 256K\n  \n  /* DDR - external memory (if configured) */\n  DDR : ORIGIN = 0x00100000, LENGTH = 2G\n}\n\n/* Use BTCM for stack (fastest access) */\n_stack_start = ORIGIN(BTCM) + LENGTH(BTCM);\n\n/* Crypto workspace in OCM for shared operations */\n_crypto_workspace = ORIGIN(OCM);\n_crypto_workspace_size = 32K;",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Linker script"
        ],
        "warnings": []
      },
      {
        "section": "Cortex-R5 specific optimizations",
        "line_number": 338,
        "language": "toml",
        "code": "# Cargo.toml for Xilinx Ultrascale+ Cortex-R5\n[package]\nname = \"zynqmp_crypto_app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n# Core embedded dependencies for Cortex-R5\ncortex-r = \"0.1\"           # Cortex-R specific runtime\npanic-halt = \"0.2\"\nembedded-hal = \"0.2\"\n\n# Note: No official Xilinx HAL crate yet, you may need to:\n# 1. Use raw register access via PAC\n# 2. Create your own HAL wrapper\n# 3. Use Xilinx's C libraries via FFI\n\n# Crypto dependencies (no-std compatible)\nchacha20poly1305 = { version = \"0.10\", default-features = false }\naes-gcm = { version = \"0.10\", default-features = false }\nsha2 = { version = \"0.10\", default-features = false }\nhmac = { version = \"0.12\", default-features = false }\nsubtle = { version = \"2.5\", default-features = false }\n\n# For static collections\nheapless = \"0.7\"\n\n# Optional: If you need to interface with Xilinx C libraries\n[dependencies.xilinx-sys]\n# This would be a custom crate wrapping Xilinx BSP\n# path = \"../xilinx-sys\"  # Your custom wrapper\n\n[profile.release]\nopt-level = \"z\"     # Optimize for size\nlto = true          # Link-time optimization\ndebug = true        # Keep debug symbols for Xilinx tools\nstrip = false       # Don't strip symbols (Xilinx tools need them)\n\n# Cortex-R5 specific optimizations\n[profile.release.package.\"*\"]\nopt-level = \"z\"",
        "syntax_valid": true,
        "compiles": true,
        "errors": [],
        "warnings": []
      },
      {
        "section": "Binary Crates vs Library Crates for Embedded Cryptography",
        "line_number": 398,
        "language": "rust",
        "code": "// src/main.rs - Binary crate for crypto firmware\n#![no_std]\n#![no_main]\n\nuse panic_halt as _;\nuse cortex_m_rt::entry;\n\nmod crypto;      // Cryptographic algorithms\nmod protocol;    // Communication protocols\nmod hardware;    // Hardware abstraction\nmod security;    // Security policies and key management\n\n#[entry]\nfn main() -> ! {\n    let mut crypto_engine = crypto::Engine::new();\n    let mut protocol_handler = protocol::SecureComm::new();\n\n    loop {\n        // Main firmware loop\n        if let Some(message) = protocol_handler.receive() {\n            let response = crypto_engine.process_secure_message(message);\n            protocol_handler.send(response);\n        }\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Binary Crates vs Library Crates for Embedded Cryptography",
        "line_number": 432,
        "language": "rust",
        "code": "// src/lib.rs - Library crate for reusable crypto components\n#![no_std]\n\npub mod algorithms {\n    pub mod aes;\n    pub mod chacha20;\n    pub mod sha256;\n}\n\npub mod protocols {\n    pub mod tls;\n    pub mod noise;\n}\n\npub mod hardware {\n    pub mod rng;\n    pub mod crypto_accelerator;\n}\n\n// Re-export commonly used items\npub use algorithms::aes::Aes256;\npub use protocols::tls::TlsContext;\npub use hardware::rng::HardwareRng;\n\n// Library-wide error type\n#[derive(Debug)]\npub enum CryptoError {\n    InvalidKey,\n    InvalidNonce,\n    AuthenticationFailed,\n    HardwareError,\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Module Organization Patterns",
        "line_number": 521,
        "language": "rust",
        "code": "// src/crypto/mod.rs\npub mod aes;\npub mod chacha20;\npub mod hash;\n\n// Re-export commonly used items for convenience\npub use aes::{Aes128, Aes256};\npub use chacha20::ChaCha20;\npub use hash::{Sha256, Blake3};\n\n// Module-level configuration\npub const DEFAULT_KEY_SIZE: usize = 32;\npub const MAX_NONCE_SIZE: usize = 24;",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Module Organization Patterns",
        "line_number": 552,
        "language": "rust",
        "code": "// src/crypto.rs (replaces crypto/mod.rs)\npub mod aes;\npub mod chacha20;\npub mod hash;\n\npub use aes::{Aes128, Aes256};\npub use chacha20::ChaCha20;\npub use hash::{Sha256, Blake3};",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Structuring Cryptographic Algorithms Across Modules",
        "line_number": 567,
        "language": "rust",
        "code": "// src/lib.rs - Top-level organization\n#![no_std]\n\n// Core cryptographic primitives\npub mod primitives {\n    pub mod symmetric;    // Block and stream ciphers\n    pub mod asymmetric;   // Public key cryptography\n    pub mod hash;         // Hash functions and MACs\n    pub mod random;       // Random number generation\n}\n\n// Higher-level protocols\npub mod protocols {\n    pub mod tls;          // TLS/SSL implementation\n    pub mod noise;        // Noise protocol framework\n    pub mod opaque;       // OPAQUE password protocol\n}\n\n// Hardware-specific implementations\npub mod hardware {\n    pub mod accelerator;  // Crypto accelerator drivers\n    pub mod secure_element; // Secure element interface\n    pub mod rng;          // Hardware RNG\n}\n\n// Security utilities\npub mod security {\n    pub mod zeroize;      // Secure memory clearing\n    pub mod constant_time; // Constant-time operations\n    pub mod side_channel; // Side-channel mitigations\n}\n\n// Common types and errors\npub mod types;\npub mod error;",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Detailed Module Organization Example",
        "line_number": 609,
        "language": "rust",
        "code": "// src/primitives/symmetric.rs\nuse crate::types::{Key, Nonce, Block};\nuse crate::error::CryptoError;\n\npub struct Aes256 {\n    key: Key<32>,\n}\n\nimpl Aes256 {\n    pub fn new(key: &[u8; 32]) -> Self {\n        Self { key: Key::new(*key) }\n    }\n\n    pub fn encrypt_block(&self, plaintext: &Block) -> Block {\n        // AES encryption implementation\n        *plaintext // Placeholder\n    }\n}\n\n// src/primitives/hash.rs\npub struct Sha256 {\n    state: [u32; 8],\n    buffer: [u8; 64],\n    len: u64,\n}\n\nimpl Sha256 {\n    pub fn new() -> Self {\n        Self {\n            state: [\n                0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n                0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n            ],\n            buffer: [0; 64],\n            len: 0,\n        }\n    }\n\n    pub fn update(&mut self, data: &[u8]) {\n        // SHA-256 update implementation\n    }\n\n    pub fn finalize(self) -> [u8; 32] {\n        // SHA-256 finalization\n        [0; 32] // Placeholder\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Visibility Levels",
        "line_number": 665,
        "language": "rust",
        "code": "// src/lib.rs\npub mod crypto {\n    // Public module - accessible from outside the crate\n    pub mod algorithms;\n\n    // Private module - only accessible within this crate\n    mod internal;\n\n    // Public function - part of the public API\n    pub fn encrypt_data(data: &[u8]) -> Vec<u8> {\n        internal::process_with_security_checks(data)\n    }\n\n    // Private function - implementation detail\n    fn validate_input(data: &[u8]) -> bool {\n        !data.is_empty()\n    }\n}\n\n// src/crypto/algorithms.rs\npub struct CryptoEngine {\n    // Public field - accessible to users of the struct\n    pub algorithm: Algorithm,\n\n    // Private field - internal implementation detail\n    key_material: [u8; 32],\n\n    // Public field with restricted access\n    pub(crate) debug_mode: bool,  // Only accessible within this crate\n}\n\nimpl CryptoEngine {\n    // Public constructor\n    pub fn new(algorithm: Algorithm) -> Self {\n        Self {\n            algorithm,\n            key_material: [0; 32],\n            debug_mode: false,\n        }\n    }\n\n    // Public method\n    pub fn set_key(&mut self, key: &[u8; 32]) {\n        self.key_material = *key;\n        self.clear_intermediate_state();  // Private method call\n    }\n\n    // Private method - implementation detail\n    fn clear_intermediate_state(&mut self) {\n        // Clear sensitive intermediate values\n    }\n\n    // Crate-visible method - for internal testing\n    pub(crate) fn get_internal_state(&self) -> &[u8; 32] {\n        &self.key_material\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum Algorithm {\n    Aes256,\n    ChaCha20,\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Security-Focused Visibility Patterns",
        "line_number": 733,
        "language": "rust",
        "code": "// src/security/mod.rs\npub mod key_management {\n    // Public interface for key operations\n    pub use self::secure_key::SecureKey;\n    pub use self::key_derivation::derive_key;\n\n    // Private modules containing implementation details\n    mod secure_key;\n    mod key_derivation;\n    mod zeroization;\n\n    // Re-export only safe, high-level operations\n    pub fn generate_session_key() -> SecureKey<32> {\n        secure_key::SecureKey::generate()\n    }\n}\n\n// src/security/key_management/secure_key.rs\nuse super::zeroization::SecureZeroize;\n\npub struct SecureKey<const N: usize> {\n    // Private field - key material should never be directly accessible\n    key: [u8; N],\n}\n\nimpl<const N: usize> SecureKey<N> {\n    // Public constructor with validation\n    pub fn new(key_material: [u8; N]) -> Self {\n        Self { key: key_material }\n    }\n\n    // Safe public interface - returns reference, not owned data\n    pub fn as_bytes(&self) -> &[u8; N] {\n        &self.key\n    }\n\n    // Private method for internal operations\n    fn validate_key_strength(&self) -> bool {\n        // Check for weak keys, all zeros, etc.\n        !self.key.iter().all(|&b| b == 0)\n    }\n}\n\nimpl<const N: usize> Drop for SecureKey<N> {\n    fn drop(&mut self) {\n        // Automatically zeroize on drop\n        self.key.secure_zeroize();\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Absolute vs Relative Paths",
        "line_number": 791,
        "language": "rust",
        "code": "// src/lib.rs\npub mod crypto;\npub mod protocol;\npub mod hardware;\n\n// src/crypto/mod.rs\npub mod aes;\npub mod hash;\n\nuse crate::hardware::rng::HardwareRng;  // Absolute path from crate root\nuse self::aes::Aes256;                  // Relative path from current module\nuse super::protocol::tls::TlsContext;   // Relative path to parent module\n\n// Alternative absolute paths\nuse crate::crypto::aes::Aes256;         // Explicit absolute path\nuse crate::crypto::hash::Sha256;        // Another absolute path\n\npub struct CryptoManager {\n    aes: Aes256,\n    rng: HardwareRng,\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Use Statement Patterns for Crypto Libraries",
        "line_number": 817,
        "language": "rust",
        "code": "// src/lib.rs - Library root with organized re-exports\n#![no_std]\n\n// Internal modules\nmod primitives;\nmod protocols;\nmod hardware;\nmod security;\n\n// Public API re-exports - carefully curated\npub use primitives::{\n    Aes128, Aes256,           // Symmetric ciphers\n    ChaCha20, ChaCha20Poly1305, // Stream ciphers with AEAD\n    Sha256, Sha512,           // Hash functions\n    HmacSha256,               // MAC functions\n};\n\npub use protocols::{\n    TlsContext,               // TLS protocol handler\n    NoiseSession,             // Noise protocol session\n};\n\npub use security::{\n    SecureKey,                // Secure key management\n    ConstantTimeEq,           // Constant-time operations\n};\n\n// Error types\npub use crate::error::{CryptoError, Result};\n\n// Common traits\npub use primitives::traits::{\n    BlockCipher,\n    StreamCipher,\n    HashFunction,\n};\n\n// src/primitives/mod.rs - Primitive algorithms organization\npub mod symmetric {\n    pub mod aes;\n    pub mod chacha20;\n\n    // Re-export main types\n    pub use aes::{Aes128, Aes256};\n    pub use chacha20::{ChaCha20, ChaCha20Poly1305};\n}\n\npub mod hash {\n    pub mod sha2;\n    pub mod blake3;\n\n    pub use sha2::{Sha256, Sha512};\n    pub use blake3::Blake3;\n}\n\npub mod traits;\n\n// Re-export everything for internal use\npub use symmetric::*;\npub use hash::*;",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Advanced Use Patterns for Large Crypto Projects",
        "line_number": 882,
        "language": "rust",
        "code": "// src/protocols/tls/mod.rs - Complex protocol organization\nuse crate::primitives::{\n    Aes256, ChaCha20Poly1305,     // Symmetric ciphers\n    Sha256, HmacSha256,           // Hash and MAC\n    EcdsaP256, X25519,            // Asymmetric crypto\n};\nuse crate::security::{\n    SecureKey, ConstantTimeEq,    // Security utilities\n    SecureRandom,                 // RNG abstraction\n};\nuse crate::hardware::rng::HardwareRng;\n\n// Group related imports\nuse heapless::{\n    Vec as HVec,                  // Rename to avoid confusion\n    String as HString,\n    FnvIndexMap,\n};\n\n// Conditional imports based on features\n#[cfg(feature = \"std\")]\nuse std::collections::HashMap;\n\n#[cfg(not(feature = \"std\"))]\nuse heapless::FnvIndexMap as HashMap;\n\n// Import traits separately for clarity\nuse crate::primitives::traits::{\n    BlockCipher,\n    StreamCipher,\n    KeyExchange,\n};\n\npub struct TlsContext<R: SecureRandom> {\n    cipher_suite: CipherSuite,\n    rng: R,\n    session_keys: Option<SessionKeys>,\n}\n\n// Use type aliases for complex types\ntype SessionKeys = (SecureKey<32>, SecureKey<32>, SecureKey<12>, SecureKey<12>);\ntype CryptoResult<T> = Result<T, crate::error::CryptoError>;",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Comprehensive `build.rs` Usage for Embedded Projects",
        "line_number": 933,
        "language": "rust",
        "code": "// build.rs - Advanced build script for crypto projects\nuse std::env;\nuse std::fs;\nuse std::path::Path;\n\nfn main() {\n    // Get target information\n    let target = env::var(\"TARGET\").unwrap();\n    let target_arch = env::var(\"CARGO_CFG_TARGET_ARCH\").unwrap();\n    let target_os = env::var(\"CARGO_CFG_TARGET_OS\").unwrap();\n\n    println!(\"cargo:rerun-if-changed=build.rs\");\n    println!(\"cargo:rerun-if-changed=crypto_config.toml\");\n    println!(\"cargo:rerun-if-env-changed=CRYPTO_BACKEND\");\n\n    // Configure crypto backend based on target\n    configure_crypto_backend(&target, &target_arch);\n\n    // Generate lookup tables for crypto algorithms\n    generate_crypto_tables();\n\n    // Configure hardware-specific features\n    configure_hardware_features(&target);\n\n    // Set up linker configuration\n    configure_linker(&target);\n\n    // Generate constant-time implementations\n    generate_constant_time_code();\n}\n\nfn configure_crypto_backend(target: &str, arch: &str) {\n    // Enable hardware acceleration when available\n    if target.contains(\"thumbv8m\") {\n        // Cortex-M33/M35P with TrustZone and crypto extensions\n        println!(\"cargo:rustc-cfg=feature=\\\"hw_crypto\\\"\");\n        println!(\"cargo:rustc-cfg=feature=\\\"trustzone\\\"\");\n    }\n\n    if arch == \"aarch64\" && target.contains(\"apple\") {\n        // Apple Silicon with crypto extensions\n        println!(\"cargo:rustc-cfg=feature=\\\"apple_crypto\\\"\");\n    }\n\n    if target.contains(\"x86_64\") {\n        // x86_64 with AES-NI and other extensions\n        println!(\"cargo:rustc-cfg=feature=\\\"aes_ni\\\"\");\n        println!(\"cargo:rustc-cfg=feature=\\\"sha_ni\\\"\");\n    }\n\n    // Configure based on environment variable\n    if let Ok(backend) = env::var(\"CRYPTO_BACKEND\") {\n        match backend.as_str() {\n            \"software\" => println!(\"cargo:rustc-cfg=crypto_backend=\\\"software\\\"\"),\n            \"hardware\" => println!(\"cargo:rustc-cfg=crypto_backend=\\\"hardware\\\"\"),\n            \"hybrid\" => println!(\"cargo:rustc-cfg=crypto_backend=\\\"hybrid\\\"\"),\n            _ => panic!(\"Invalid CRYPTO_BACKEND: {}\", backend),\n        }\n    }\n}\n\nfn generate_crypto_tables() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"crypto_tables.rs\");\n\n    // Generate AES S-box and inverse S-box\n    let mut code = String::new();\n    code.push_str(\"// Auto-generated crypto lookup tables\\n\\n\");\n\n    // AES S-box\n    code.push_str(\"pub const AES_SBOX: [u8; 256] = [\\n\");\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        code.push_str(&format!(\"0x{:02x},\", aes_sbox(i as u8)));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n\n    // AES inverse S-box\n    code.push_str(\"pub const AES_INV_SBOX: [u8; 256] = [\\n\");\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        code.push_str(&format!(\"0x{:02x},\", aes_inv_sbox(i as u8)));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n\n    // Generate multiplication tables for GF(2^8)\n    generate_gf256_tables(&mut code);\n\n    fs::write(&dest_path, code).unwrap();\n}\n\nfn configure_hardware_features(target: &str) {\n    // Configure memory layout based on target\n    if target.contains(\"stm32f4\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}\n        println!(\"cargo:rustc-cfg=flash_size=\\\"512k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"128k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    } else if target.contains(\"nrf52840\") {\n        println!(\"cargo:rustc-cfg=flash_size=\\\"1024k\\\"\");\n        println!(\"cargo:rustc-cfg=ram_size=\\\"256k\\\"\");\n        println!(\"cargo:rustc-cfg=has_hw_crypto\");\n        println!(\"cargo:rustc-cfg=has_hw_rng\");\n    }\n\n    // Configure crypto-specific features\n    if target.contains(\"cortex-m33\") {\n        println!(\"cargo:rustc-cfg=has_trustzone\");\n        println!(\"cargo:rustc-cfg=has_mpu\");\n    }\n}\n\nfn configure_linker(target: &str) {\n    // Set linker script based on target\n    if target.contains(\"thumbv\") {\n        println!(\"cargo:rustc-link-arg=-Tlink.x\");\n\n        // Add crypto-specific linker sections\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_start=0x08010000\");\n        println!(\"cargo:rustc-link-arg=--defsym=__crypto_size=0x10000\");\n    }\n}\n\nfn generate_constant_time_code() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"constant_time.rs\");\n\n    let code = r#\"\n// Auto-generated constant-time operations\n\n/// Constant-time conditional select\n#[inline(always)]\npub fn ct_select_u8(condition: u8, a: u8, b: u8) -> u8 {\n    let mask = (condition as i8 >> 7) as u8;\n    (a & mask) | (b & !mask)\n}\n\n/// Constant-time conditional select for arrays\npub fn ct_select_bytes(condition: u8, a: &[u8], b: &[u8], out: &mut [u8]) {\n    assert_eq!(a.len(), b.len());\n    assert_eq!(a.len(), out.len());\n\n    for i in 0..a.len() {\n        out[i] = ct_select_u8(condition, a[i], b[i]);\n    }\n}\n\n/// Constant-time equality check\npub fn ct_eq_bytes(a: &[u8], b: &[u8]) -> u8 {\n    if a.len() != b.len() {\n        return 0;\n    }\n\n    let mut diff = 0u8;\n    for i in 0..a.len() {\n        diff |= a[i] ^ b[i];\n    }\n\n    ((diff as u16).wrapping_sub(1) >> 8) as u8\n}\n\"#;\n\n    fs::write(&dest_path, code).unwrap();\n}\n\n// Helper functions for table generation\nfn aes_sbox(x: u8) -> u8 {\n    // Simplified AES S-box calculation\n    // In practice, you'd implement the full Rijndael S-box\n    x.wrapping_add(1) // Placeholder\n}\n\nfn aes_inv_sbox(x: u8) -> u8 {\n    // Simplified inverse S-box\n    x.wrapping_sub(1) // Placeholder\n}\n\nfn generate_gf256_tables(code: &mut String) {\n    // Generate multiplication tables for Galois Field GF(2^8)\n    code.push_str(\"// GF(2^8) multiplication tables\\n\");\n    code.push_str(\"pub const GF256_MUL_2: [u8; 256] = [\\n\");\n\n    for i in 0..256 {\n        if i % 16 == 0 { code.push_str(\"    \"); }\n        let result = if i & 0x80 != 0 { (i << 1) ^ 0x1b } else { i << 1 };\n        code.push_str(&format!(\"0x{:02x},\", result & 0xff));\n        if i % 16 == 15 { code.push_str(\"\\n\"); } else { code.push(' '); }\n    }\n    code.push_str(\"];\\n\\n\");\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Custom Build Scripts for Cryptographic Code Generation",
        "line_number": 3123,
        "language": "rust",
        "code": "// build.rs - Specialized crypto code generation\nuse std::env;\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::Path;\n\nfn main() {\n    generate_curve_constants();\n    generate_prime_tables();\n    generate_crypto_benchmarks();\n}\n\nfn generate_curve_constants() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"curve_constants.rs\");\n    let mut f = File::create(&dest_path).unwrap();\n\n    writeln!(f, \"// Auto-generated elliptic curve constants\").unwrap();\n    writeln!(f, \"\").unwrap();\n\n    // P-256 curve parameters\n    writeln!(f, \"/// NIST P-256 curve prime\").unwrap();\n    writeln!(f, \"pub const P256_P: [u64; 4] = [\").unwrap();\n    writeln!(f, \"    0xffffffffffffffff,\").unwrap();\n    writeln!(f, \"    0x00000000ffffffff,\").unwrap();\n    writeln!(f, \"    0x0000000000000000,\").unwrap();\n    writeln!(f, \"    0xffffffff00000001,\").unwrap();\n    writeln!(f, \"];\").unwrap();\n    writeln!(f, \"\").unwrap();\n\n    // Generate curve point addition tables\n    generate_precomputed_points(&mut f);\n}\n\nfn generate_precomputed_points(f: &mut File) {\n    writeln!(f, \"/// Precomputed points for scalar multiplication\").unwrap();\n    writeln!(f, \"pub const PRECOMPUTED_POINTS: [[u64; 8]; 16] = [\").unwrap();\n\n    for i in 0..16 {\n        writeln!(f, \"    [\").unwrap();\n        for j in 0..8 {\n            // In practice, these would be actual precomputed curve points\n            writeln!(f, \"        0x{:016x},\", i * 8 + j).unwrap();\n        }\n        writeln!(f, \"    ],\").unwrap();\n    }\n    writeln!(f, \"];\").unwrap();\n}\n\nfn generate_prime_tables() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"prime_tables.rs\");\n    let mut f = File::create(&dest_path).unwrap();\n\n    writeln!(f, \"// Auto-generated prime number tables\").unwrap();\n    writeln!(f, \"\").unwrap();\n\n    // Generate small primes for primality testing\n    let primes = generate_small_primes(1000);\n    writeln!(f, \"pub const SMALL_PRIMES: [u16; {}] = [\", primes.len()).unwrap();\n\n    for (i, prime) in primes.iter().enumerate() {\n        if i % 10 == 0 { write!(f, \"    \").unwrap(); }\n        write!(f, \"{},\", prime).unwrap();\n        if i % 10 == 9 { writeln!(f, \"\").unwrap(); } else { write!(f, \" \").unwrap(); }\n    }\n    writeln!(f, \"];\").unwrap();\n}\n\nfn generate_small_primes(limit: u16) -> Vec<u16> {\n    let mut primes = Vec::new();\n    let mut is_prime = vec![true; limit as usize + 1];\n\n    for i in 2..=limit {\n        if is_prime[i as usize] {\n            primes.push(i);\n            let mut j = i * i;\n            while j <= limit {\n                is_prime[j as usize] = false;\n                j += i;\n            }\n        }\n    }\n    primes\n}\n\nfn generate_crypto_benchmarks() {\n    // Generate benchmark constants for performance testing\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"bench_constants.rs\");\n    let mut f = File::create(&dest_path).unwrap();\n\n    writeln!(f, \"// Benchmark test vectors\").unwrap();\n    writeln!(f, \"pub const BENCH_DATA_1KB: [u8; 1024] = [0x42; 1024];\").unwrap();\n    writeln!(f, \"pub const BENCH_DATA_4KB: [u8; 4096] = [0x42; 4096];\").unwrap();\n    writeln!(f, \"pub const BENCH_KEY: [u8; 32] = [0x2b; 32];\").unwrap();\n    writeln!(f, \"pub const BENCH_NONCE: [u8; 12] = [0x00; 12];\").unwrap();\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "src/crypto/mod.rs - Conditional compilation in action",
        "line_number": 3228,
        "language": "rust",
        "code": "// Cargo.toml - Feature flags for different targets\n[features]\ndefault = [\"software-crypto\"]\nsoftware-crypto = []\nhardware-crypto = [\"dep:stm32-crypto\"]\nsecure-element = [\"dep:atecc608a\"]\ndebug-crypto = []\n\n# Target-specific dependencies\n[target.'cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))'.dependencies]\ncortex-m = \"0.7\"\n\n[target.'cfg(target_arch = \"riscv32\")'.dependencies]\nriscv = \"0.10\"\n\n# src/crypto/mod.rs - Conditional compilation in action\n#[cfg(feature = \"hardware-crypto\")]\npub mod hardware;\n\n#[cfg(feature = \"software-crypto\")]\npub mod software;\n\n#[cfg(feature = \"secure-element\")]\npub mod secure_element;\n\n// Conditional type aliases\n#[cfg(feature = \"hardware-crypto\")]\npub type DefaultCipher = hardware::HardwareAes256;\n\n#[cfg(all(feature = \"software-crypto\", not(feature = \"hardware-crypto\")))]\npub type DefaultCipher = software::SoftwareAes256;\n\n// Conditional implementations\nimpl CryptoEngine {\n    pub fn new() -> Self {\n        Self {\n            #[cfg(feature = \"hardware-crypto\")]\n            backend: Backend::Hardware(hardware::CryptoAccelerator::new()),\n\n            #[cfg(all(feature = \"software-crypto\", not(feature = \"hardware-crypto\")))]\n            backend: Backend::Software(software::SoftwareCrypto::new()),\n\n            #[cfg(feature = \"secure-element\")]\n            secure_element: Some(secure_element::SecureElement::new()),\n\n            #[cfg(not(feature = \"secure-element\"))]\n            secure_element: None,\n        }\n    }\n\n    #[cfg(feature = \"debug-crypto\")]\n    pub fn debug_state(&self) -> DebugInfo {\n        DebugInfo {\n            backend_type: self.backend.type_name(),\n            key_loaded: self.backend.has_key(),\n            operation_count: self.backend.operation_count(),\n        }\n    }\n}\n\n// Target-specific optimizations\n#[cfg(target_arch = \"arm\")]\nmod arm_optimizations {\n    use core::arch::arm::*;\n\n    #[cfg(target_feature = \"crypto\")]\n    pub fn aes_encrypt_block_hw(key: &[u32; 4], block: &mut [u32; 4]) {\n        // Use ARM crypto extensions\n        unsafe {\n            // ARM AES instructions would go here\n        }\n    }\n}\n\n#[cfg(target_arch = \"x86_64\")]\nmod x86_optimizations {\n    use core::arch::x86_64::*;\n\n    #[cfg(target_feature = \"aes\")]\n    pub fn aes_encrypt_block_ni(key: &[u32; 4], block: &mut [u32; 4]) {\n        unsafe {\n            // Intel AES-NI instructions\n            let key_schedule = _mm_loadu_si128(key.as_ptr() as *const __m128i);\n            let mut data = _mm_loadu_si128(block.as_ptr() as *const __m128i);\n            data = _mm_aesenc_si128(data, key_schedule);\n            _mm_storeu_si128(block.as_mut_ptr() as *mut __m128i, data);\n        }\n    }\n}\n\n// MCU-specific configurations\n#[cfg(any(feature = \"stm32f4\", feature = \"stm32h7\"))]\nmod stm32_crypto {\n    pub const HAS_HARDWARE_RNG: bool = true;\n    pub const HAS_CRYPTO_ACCELERATOR: bool = true;\n    pub const MAX_DMA_TRANSFER: usize = 65535;\n}\n\n#[cfg(feature = \"nrf52840\")]\nmod nordic_crypto {\n    pub const HAS_HARDWARE_RNG: bool = true;\n    pub const HAS_CRYPTO_ACCELERATOR: bool = true;\n    pub const HAS_RADIO_CRYPTO: bool = true;\n}\n\n#[cfg(feature = \"rp2040\")]\nmod rp2040_crypto {\n    pub const HAS_HARDWARE_RNG: bool = false;\n    pub const HAS_CRYPTO_ACCELERATOR: bool = false;\n    pub const HAS_PIO_CRYPTO: bool = true;  // Can implement crypto in PIO\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Integration with Hardware-Specific Build Requirements",
        "line_number": 3344,
        "language": "rust",
        "code": "// build.rs - Hardware-specific build configuration\nfn main() {\n    let target = env::var(\"TARGET\").unwrap();\n\n    // Configure based on specific MCU families\n    configure_mcu_specific(&target);\n\n    // Set up crypto-specific linker sections\n    setup_crypto_memory_layout(&target);\n\n    // Generate hardware-specific constants\n    generate_hw_constants(&target);\n}\n\nfn configure_mcu_specific(target: &str) {\n    match target {\n        t if t.contains(\"stm32f4\") => {\n            println!(\"cargo:rustc-cfg=mcu_family=\\\"stm32f4\\\"\");\n            println!(\"cargo:rustc-cfg=has_hw_rng\");\n            println!(\"cargo:rustc-cfg=has_crypto_accel\");\n            println!(\"cargo:rustc-link-arg=-Tstm32f4_crypto.x\");\n        },\n        t if t.contains(\"nrf52840\") => {\n            println!(\"cargo:rustc-cfg=mcu_family=\\\"nrf52\\\"\");\n            println!(\"cargo:rustc-cfg=has_hw_rng\");\n            println!(\"cargo:rustc-cfg=has_radio_crypto\");\n            println!(\"cargo:rustc-link-arg=-Tnrf52_crypto.x\");\n        },\n        t if t.contains(\"rp2040\") => {\n            println!(\"cargo:rustc-cfg=mcu_family=\\\"rp2040\\\"\");\n            println!(\"cargo:rustc-cfg=has_pio\");\n            println!(\"cargo:rustc-link-arg=-Trp2040_crypto.x\");\n        },\n        _ => {\n            println!(\"cargo:rustc-cfg=mcu_family=\\\"generic\\\"\");\n        }\n    }\n}\n\nfn setup_crypto_memory_layout(target: &str) {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let memory_file = Path::new(&out_dir).join(\"crypto_memory.x\");\n\n    let memory_layout = match target {\n        t if t.contains(\"stm32f4\") => {\n            r#\"\n/* STM32F4 Crypto Memory Layout */\nMEMORY\n{\n  FLASH : ORIGIN = 0x08000000, LENGTH = 512K\n  RAM : ORIGIN = 0x20000000, LENGTH = 128K\n  CRYPTO_KEYS : ORIGIN = 0x20020000, LENGTH = 4K\n  CRYPTO_WORKSPACE : ORIGIN = 0x20021000, LENGTH = 4K\n}\n\n/* Crypto-specific sections */\n.crypto_keys (NOLOAD) : ALIGN(4)\n{\n  *(.crypto_keys*)\n} > CRYPTO_KEYS\n\n.crypto_workspace (NOLOAD) : ALIGN(4)\n{\n  *(.crypto_workspace*)\n} > CRYPTO_WORKSPACE\n\"#\n        },\n        t if t.contains(\"nrf52840\") => {\n            r#\"\n/* nRF52840 Crypto Memory Layout */\nMEMORY\n{\n  FLASH : ORIGIN = 0x00000000, LENGTH = 1024K\n  RAM : ORIGIN = 0x20000000, LENGTH = 256K\n  CRYPTO_KEYS : ORIGIN = 0x20040000, LENGTH = 8K\n}\n\n.crypto_keys (NOLOAD) : ALIGN(4)\n{\n  *(.crypto_keys*)\n} > CRYPTO_KEYS\n\"#\n        },\n        _ => {\n            r#\"\n/* Generic Memory Layout */\nMEMORY\n{\n  FLASH : ORIGIN = 0x08000000, LENGTH = 256K\n  RAM : ORIGIN = 0x20000000, LENGTH = 64K\n}\n\"#\n        }\n    };\n\n    fs::write(&memory_file, memory_layout).unwrap();\n    println!(\"cargo:rustc-link-arg=-T{}\", memory_file.display());\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "How Project Structure Differs in No-std Environments",
        "line_number": 3451,
        "language": "rust",
        "code": "// src/lib.rs - No-std library structure\n#![no_std]\n#![forbid(unsafe_code)]  // Optional: forbid unsafe code except in specific modules\n\n// Core imports available in no-std\nuse core::{\n    mem, ptr, slice,\n    fmt::{self, Debug, Display},\n    convert::{TryFrom, TryInto},\n    ops::{Deref, DerefMut},\n};\n\n// Conditional std support\n#[cfg(feature = \"std\")]\nextern crate std;\n\n#[cfg(feature = \"std\")]\nuse std::vec::Vec;\n\n// No-std alternatives\n#[cfg(not(feature = \"std\"))]\nuse heapless::Vec;\n\n// Error handling without std\n#[cfg(not(feature = \"std\"))]\nuse heapless::String;\n\n#[cfg(feature = \"std\")]\nuse std::string::String;\n\n// Module organization for no-std\npub mod crypto {\n    // Core crypto that works everywhere\n    pub mod primitives;\n\n    // Heap-dependent crypto (only with alloc)\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    pub mod advanced;\n\n    // Stack-only crypto for constrained environments\n    pub mod stack_only;\n}\n\npub mod collections {\n    // Re-export appropriate collection types\n    #[cfg(feature = \"std\")]\n    pub use std::collections::*;\n\n    #[cfg(all(not(feature = \"std\"), feature = \"alloc\"))]\n    pub use alloc::collections::*;\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    pub use heapless::{FnvIndexMap as HashMap, Vec, String};\n}\n\n// Error types that work in no-std\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CryptoError {\n    InvalidKeySize,\n    InvalidNonceSize,\n    AuthenticationFailed,\n    BufferTooSmall,\n    HardwareError,\n}\n\n// Implement Display without std\nimpl Display for CryptoError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            CryptoError::InvalidKeySize => write!(f, \"Invalid key size\"),\n            CryptoError::InvalidNonceSize => write!(f, \"Invalid nonce size\"),\n            CryptoError::AuthenticationFailed => write!(f, \"Authentication failed\"),\n            CryptoError::BufferTooSmall => write!(f, \"Buffer too small\"),\n            CryptoError::HardwareError => write!(f, \"Hardware error\"),\n        }\n    }\n}\n\n// No-std compatible Result type\npub type Result<T> = core::result::Result<T, CryptoError>;",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Organizing Code When std Library is Unavailable",
        "line_number": 3536,
        "language": "rust",
        "code": "// src/crypto/stack_only.rs - Crypto that works without heap allocation\nuse crate::{CryptoError, Result};\nuse core::mem::MaybeUninit;\n\n/// AES-256 implementation using only stack allocation\npub struct Aes256 {\n    key_schedule: [u32; 60],  // Expanded key on stack\n}\n\nimpl Aes256 {\n    /// Create new AES-256 instance with stack-allocated key schedule\n    pub fn new(key: &[u8; 32]) -> Self {\n        let mut aes = Self {\n            key_schedule: [0; 60],\n        };\n        aes.expand_key(key);\n        aes\n    }\n\n    /// Encrypt a single block in-place\n    pub fn encrypt_block(&self, block: &mut [u8; 16]) {\n        // AES encryption using only stack variables\n        let mut state = [0u32; 4];\n\n        // Convert bytes to state\n        for i in 0..4 {\n            state[i] = u32::from_le_bytes([\n                block[i*4], block[i*4+1], block[i*4+2], block[i*4+3]\n            ]);\n        }\n\n        // Perform AES rounds\n        self.encrypt_state(&mut state);\n\n        // Convert state back to bytes\n        for i in 0..4 {\n            let bytes = state[i].to_le_bytes();\n            block[i*4..i*4+4].copy_from_slice(&bytes);\n        }\n    }\n\n    /// Process multiple blocks using a fixed-size workspace\n    pub fn encrypt_blocks<const N: usize>(&self, blocks: &mut [[u8; 16]; N]) {\n        for block in blocks.iter_mut() {\n            self.encrypt_block(block);\n        }\n    }\n\n    fn expand_key(&mut self, key: &[u8; 32]) {\n        // Key expansion using only stack allocation\n        // Implementation details...\n    }\n\n    fn encrypt_state(&self, state: &mut [u32; 4]) {\n        // AES state transformation\n        // Implementation details...\n    }\n}\n\n/// ChaCha20 stream cipher with stack-only operation\npub struct ChaCha20 {\n    state: [u32; 16],\n    position: u64,\n}\n\nimpl ChaCha20 {\n    pub fn new(key: &[u8; 32], nonce: &[u8; 12]) -> Self {\n        let mut cipher = Self {\n            state: [0; 16],\n            position: 0,\n        };\n        cipher.init(key, nonce);\n        cipher\n    }\n\n    /// Generate keystream into a fixed-size buffer\n    pub fn keystream<const N: usize>(&mut self) -> [u8; N] {\n        let mut output = [0u8; N];\n        self.apply_keystream(&mut output);\n        output\n    }\n\n    /// XOR data with keystream in-place\n    pub fn apply_keystream(&mut self, data: &mut [u8]) {\n        const BLOCK_SIZE: usize = 64;\n        let mut block = [0u8; BLOCK_SIZE];\n\n        for chunk in data.chunks_mut(BLOCK_SIZE) {\n            self.generate_block(&mut block);\n\n            for (data_byte, key_byte) in chunk.iter_mut().zip(block.iter()) {\n                *data_byte ^= key_byte;\n            }\n        }\n    }\n\n    fn init(&mut self, key: &[u8; 32], nonce: &[u8; 12]) {\n        // ChaCha20 initialization\n        // Implementation details...\n    }\n\n    fn generate_block(&mut self, output: &mut [u8; 64]) {\n        // Generate one ChaCha20 block\n        // Implementation details...\n    }\n}\n\n/// Constant-size hash context for SHA-256\npub struct Sha256 {\n    state: [u32; 8],\n    buffer: [u8; 64],\n    len: u64,\n}\n\nimpl Sha256 {\n    pub fn new() -> Self {\n        Self {\n            state: [\n                0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n                0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n            ],\n            buffer: [0; 64],\n            len: 0,\n        }\n    }\n\n    /// Update hash with data, using only stack allocation\n    pub fn update(&mut self, data: &[u8]) {\n        // SHA-256 update implementation\n        // Uses only stack variables and the internal buffer\n    }\n\n    /// Finalize hash and return digest\n    pub fn finalize(mut self) -> [u8; 32] {\n        // SHA-256 finalization\n        // Returns fixed-size array, no heap allocation\n        [0; 32] // Placeholder\n    }\n\n    /// One-shot hash function for small data\n    pub fn hash<const N: usize>(data: &[u8; N]) -> [u8; 32] {\n        let mut hasher = Self::new();\n        hasher.update(data);\n        hasher.finalize()\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Size-optimized profile",
        "line_number": 3689,
        "language": "toml",
        "code": "# Cargo.toml - Comprehensive dependency management for embedded crypto\n[package]\nname = \"embedded-crypto-lib\"\nversion = \"0.1.0\"\nedition = \"2021\"\nauthors = [\"Your Name <your.email@example.com>\"]\ndescription = \"Cryptographic library for embedded systems\"\nlicense = \"MIT OR Apache-2.0\"\nrepository = \"https://github.com/yourname/embedded-crypto-lib\"\ncategories = [\"embedded\", \"cryptography\", \"no-std\"]\nkeywords = [\"crypto\", \"embedded\", \"no-std\", \"security\"]\n\n[features]\n# Default features for most embedded use cases\ndefault = [\"aes\", \"sha2\", \"hmac\"]\n\n# Core cryptographic algorithms\naes = []\nchacha20 = []\nsha2 = []\nsha3 = []\nblake3 = []\nhmac = []\npoly1305 = []\n\n# Higher-level protocols\ntls = [\"aes\", \"sha2\", \"hmac\", \"x25519\", \"p256\"]\nnoise = [\"chacha20\", \"poly1305\", \"x25519\"]\n\n# Asymmetric cryptography\nrsa = [\"dep:rsa\", \"dep:num-bigint-dig\"]\np256 = [\"dep:p256\"]\nx25519 = [\"dep:x25519-dalek\"]\ned25519 = [\"dep:ed25519-dalek\"]\n\n# Hardware acceleration\nhardware-crypto = [\"dep:stm32-crypto\"]\nhardware-rng = []\n\n# Memory allocation support\nalloc = [\"dep:linked_list_allocator\"]\nstd = [\"alloc\", \"dep:std\"]\n\n# Development and testing features\ndebug-crypto = []\ntest-vectors = []\nbenchmarks = [\"dep:criterion\"]\n\n# Size optimization features\nsmall-code = []  # Optimize for code size over speed\nsmall-ram = []   # Optimize for RAM usage\n\n[dependencies]\n# Core dependencies (always available)\ncortex-m = { version = \"0.7\", optional = false }\nnb = \"1.0\"\nembedded-hal = \"0.2\"\n\n# Crypto dependencies with no-std support\naes = { version = \"0.8\", default-features = false, optional = true }\nchacha20 = { version = \"0.9\", default-features = false, optional = true }\npoly1305 = { version = \"0.8\", default-features = false, optional = true }\nsha2 = { version = \"0.10\", default-features = false, optional = true }\nsha3 = { version = \"0.10\", default-features = false, optional = true }\nblake3 = { version = \"1.3\", default-features = false, optional = true }\nhmac = { version = \"0.12\", default-features = false, optional = true }\n\n# Asymmetric crypto (larger dependencies)\nrsa = { version = \"0.9\", default-features = false, optional = true }\np256 = { version = \"0.13\", default-features = false, optional = true }\nx25519-dalek = { version = \"2.0\", default-features = false, optional = true }\ned25519-dalek = { version = \"2.0\", default-features = false, optional = true }\n\n# Utilities\nsubtle = { version = \"2.5\", default-features = false }\nzeroize = { version = \"1.6\", default-features = false }\nheapless = \"0.7\"\nnb = \"1.0\"\n\n# Optional allocator support\nlinked_list_allocator = { version = \"0.10\", optional = true }\n\n# Hardware-specific dependencies\nstm32-crypto = { version = \"0.1\", optional = true }\n\n# Development dependencies\n[dev-dependencies]\ncriterion = { version = \"0.5\", optional = true }\nhex-literal = \"0.4\"\nrand_core = { version = \"0.6\", features = [\"std\"] }\n\n# Target-specific dependencies\n[target.'cfg(target_arch = \"arm\")'.dependencies]\ncortex-m = \"0.7\"\n\n[target.'cfg(target_arch = \"riscv32\")'.dependencies]\nriscv = \"0.10\"\n\n# Profile optimizations for embedded\n[profile.release]\nopt-level = \"z\"        # Optimize for size\nlto = true            # Link-time optimization\ncodegen-units = 1     # Better optimization\npanic = \"abort\"       # Smaller binary size\nstrip = true          # Remove debug symbols\n\n[profile.dev]\nopt-level = 1         # Some optimization for faster development\ndebug = true          # Keep debug info\npanic = \"abort\"       # Consistent with release\n\n# Size-optimized profile\n[profile.size]\ninherits = \"release\"\nopt-level = \"z\"\nlto = \"fat\"\ncodegen-units = 1\npanic = \"abort\"\nstrip = \"symbols\"",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "TOML syntax error: Cannot overwrite a value (at line 78, column 11)"
        ],
        "warnings": []
      },
      {
        "section": "Size-optimized profile",
        "line_number": 3811,
        "language": "rust",
        "code": "// src/lib.rs - Feature-gated module organization\n#![no_std]\n#![cfg_attr(docsrs, feature(doc_cfg))]\n\n// Conditional allocation support\n#[cfg(feature = \"alloc\")]\nextern crate alloc;\n\n#[cfg(feature = \"std\")]\nextern crate std;\n\n// Core modules (always available)\npub mod error;\npub mod types;\n\n// Algorithm modules (feature-gated)\n#[cfg(feature = \"aes\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"aes\")))]\npub mod aes;\n\n#[cfg(feature = \"chacha20\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"chacha20\")))]\npub mod chacha20;\n\n#[cfg(feature = \"sha2\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"sha2\")))]\npub mod sha2;\n\n#[cfg(feature = \"hmac\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"hmac\")))]\npub mod hmac;\n\n// Protocol modules (feature-gated)\n#[cfg(feature = \"tls\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"tls\")))]\npub mod tls;\n\n#[cfg(feature = \"noise\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"noise\")))]\npub mod noise;\n\n// Hardware modules (feature-gated)\n#[cfg(feature = \"hardware-crypto\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"hardware-crypto\")))]\npub mod hardware;\n\n// Asymmetric crypto (feature-gated)\n#[cfg(feature = \"p256\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"p256\")))]\npub mod p256;\n\n#[cfg(feature = \"x25519\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"x25519\")))]\npub mod x25519;\n\n// Re-exports for convenience\npub use error::{CryptoError, Result};\n\n#[cfg(feature = \"aes\")]\npub use aes::{Aes128, Aes256};\n\n#[cfg(feature = \"chacha20\")]\npub use chacha20::ChaCha20;\n\n#[cfg(feature = \"sha2\")]\npub use sha2::{Sha256, Sha512};\n\n// Conditional compilation for different memory models\n#[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\nuse alloc::{vec::Vec, string::String};\n\n#[cfg(feature = \"std\")]\nuse std::{vec::Vec, string::String};\n\n#[cfg(not(any(feature = \"alloc\", feature = \"std\")))]\nuse heapless::{Vec, String};\n\n// Feature-dependent type aliases\n#[cfg(any(feature = \"alloc\", feature = \"std\"))]\npub type CryptoVec<T> = Vec<T>;\n\n#[cfg(not(any(feature = \"alloc\", feature = \"std\")))]\npub type CryptoVec<T> = heapless::Vec<T, 256>;  // Fixed capacity\n\n// Conditional API based on available features\npub struct CryptoEngine {\n    #[cfg(feature = \"aes\")]\n    aes: Option<aes::Aes256>,\n\n    #[cfg(feature = \"chacha20\")]\n    chacha20: Option<chacha20::ChaCha20>,\n\n    #[cfg(feature = \"hardware-crypto\")]\n    hw_accel: Option<hardware::CryptoAccelerator>,\n}\n\nimpl CryptoEngine {\n    pub fn new() -> Self {\n        Self {\n            #[cfg(feature = \"aes\")]\n            aes: None,\n\n            #[cfg(feature = \"chacha20\")]\n            chacha20: None,\n\n            #[cfg(feature = \"hardware-crypto\")]\n            hw_accel: hardware::CryptoAccelerator::try_new().ok(),\n        }\n    }\n\n    #[cfg(feature = \"aes\")]\n    pub fn set_aes_key(&mut self, key: &[u8; 32]) -> Result<()> {\n        self.aes = Some(aes::Aes256::new(key));\n        Ok(())\n    }\n\n    #[cfg(feature = \"chacha20\")]\n    pub fn set_chacha20_key(&mut self, key: &[u8; 32], nonce: &[u8; 12]) -> Result<()> {\n        self.chacha20 = Some(chacha20::ChaCha20::new(key, nonce));\n        Ok(())\n    }\n\n    // Conditional methods based on available algorithms\n    pub fn encrypt(&mut self, data: &mut [u8]) -> Result<()> {\n        #[cfg(feature = \"hardware-crypto\")]\n        if let Some(ref mut hw) = self.hw_accel {\n            return hw.encrypt(data);\n        }\n\n        #[cfg(feature = \"aes\")]\n        if let Some(ref aes) = self.aes {\n            return self.encrypt_with_aes(data, aes);\n        }\n\n        #[cfg(feature = \"chacha20\")]\n        if let Some(ref mut chacha) = self.chacha20 {\n            chacha.apply_keystream(data);\n            return Ok(());\n        }\n\n        Err(CryptoError::NoAlgorithmAvailable)\n    }\n\n    #[cfg(feature = \"aes\")]\n    fn encrypt_with_aes(&self, data: &mut [u8], aes: &aes::Aes256) -> Result<()> {\n        // AES encryption implementation\n        Ok(())\n    }\n}\n\n// Compile-time feature validation\n#[cfg(all(feature = \"small-code\", feature = \"benchmarks\"))]\ncompile_error!(\"Cannot enable both 'small-code' and 'benchmarks' features\");\n\n#[cfg(all(feature = \"small-ram\", feature = \"alloc\"))]\ncompile_error!(\"'small-ram' and 'alloc' features are incompatible\");\n\n// Feature-dependent constants\n#[cfg(feature = \"small-ram\")]\npub const MAX_BUFFER_SIZE: usize = 256;\n\n#[cfg(not(feature = \"small-ram\"))]\npub const MAX_BUFFER_SIZE: usize = 4096;\n\n#[cfg(feature = \"small-code\")]\npub const OPTIMIZATION_LEVEL: &str = \"size\";\n\n#[cfg(not(feature = \"small-code\"))]\npub const OPTIMIZATION_LEVEL: &str = \"speed\";",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Variables and Mutability",
        "line_number": 4007,
        "language": "rust",
        "code": "// Rust: Variables are immutable by default\nlet x = 5;\n// x = 10;  // ERROR: cannot assign twice to immutable variable\n\nlet mut y = 5;  // Explicitly mutable\ny = 10;  // OK\n\n// Crypto example: key buffers\nlet mut key = [0u8; 32];  // Mutable array\nkey[0] = 0x42;  // OK - can modify contents\n\nlet immutable_key = [0x42u8; 32];  // Immutable\n// immutable_key[0] = 0x43;  // ERROR: cannot modify",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Memory Management: Stack vs Heap",
        "line_number": 4049,
        "language": "rust",
        "code": "// Rust: Automatic memory management with ownership\nfn create_key_buffer() -> [u8; 32] {\n    [0u8; 32]  // Stack allocated, returned by value\n}\n\nfn use_key() {\n    let key = create_key_buffer();  // Ownership transferred\n    // Use key...\n    // Automatically cleaned up - no manual free() needed!\n}\n\n// For dynamic sizes (rare in embedded crypto):\n#[cfg(feature = \"alloc\")]\nfn create_dynamic_buffer(size: usize) -> Vec<u8> {\n    vec![0u8; size]  // Heap allocated\n    // Automatically freed when Vec goes out of scope\n}",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Function Pointers vs Closures",
        "line_number": 4093,
        "language": "rust",
        "code": "// Rust: Closures with captured environment\nfn process_crypto_data<F>(input: &[u8], mut callback: F) \nwhere \n    F: FnMut(&[u8])\n{\n    let output = [0u8; 32];\n    // Process data...\n    callback(&output);\n}\n\n// Usage - much more flexible than C\nfn main() {\n    let data = [0x01, 0x02, 0x03];\n    let mut counter = 0;\n    \n    process_crypto_data(&data, |processed_data| {\n        counter += 1;  // Can capture and modify local variables!\n        // Handle processed data\n    });\n}",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Pointers and References",
        "line_number": 4137,
        "language": "rust",
        "code": "// Rust: References cannot be null, no arithmetic\nlet mut data = [0u8; 256];  // Stack array\ndata[10] = 0x42;            // Bounds checked automatically\n// let next = &data + 1;    // ERROR: no pointer arithmetic on references\n\n// Rust: Function taking slice (cannot be null)\nfn process_buffer(buffer: &mut [u8]) {\n    // No null check needed - references are always valid\n    for byte in buffer.iter_mut() {\n        *byte ^= 0x55;  // Safe iteration, bounds checked\n    }\n}\n\n// Alternative with explicit bounds checking\nfn process_buffer_indexed(buffer: &mut [u8]) {\n    for i in 0..buffer.len() {\n        buffer[i] ^= 0x55;  // Bounds checked at runtime\n    }\n}",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "No Null Pointers - Use Option<T>",
        "line_number": 4180,
        "language": "rust",
        "code": "// Rust: Use Option<T> to represent \"might not exist\"\nfn find_key_by_id(key_id: u32) -> Option<&'static [u8; 32]> {\n    // Search for key...\n    if key_found {\n        Some(&KEY_BUFFER)\n    } else {\n        None  // Explicitly indicates \"not found\"\n    }\n}\n\n// Usage with pattern matching (compiler enforces handling both cases)\nmatch find_key_by_id(0x1234) {\n    Some(key) => encrypt_with_key(key, data),\n    None => {\n        // Handle error - compiler forces you to handle this case!\n    }\n}\n\n// Alternative: use if let for side effects\nif let Some(key) = find_key_by_id(0x1234) {\n    encrypt_with_key(key, data);\n}\n\n// For transformations that return values - use map\nlet encrypted_data = find_key_by_id(0x1234)\n    .map(|key| encrypt_with_key(key, data))  // Only runs if key exists\n    .ok_or(CryptoError::KeyNotFound)?;       // Convert None to error\n\n// Idiomatic pattern for side effects - use if let\nif let Some(p) = ptr {\n    *p = 42;\n}\n\n// For transformations that return values - use map\nlet doubled = ptr.map(|p| *p * 2);  // Returns Option<i32>\n\n// How Option::map works (different from iterator map!)\n// Option<T> has a map method that transforms the contained value IF it exists\n//\n// Option::map signature: fn map<U, F>(self, f: F) -> Option<U>\n//   where F: FnOnce(T) -> U\n//\n// If the Option is Some(value):  map applies the function and returns Some(result)\n// If the Option is None:         map does nothing and returns None\n\nlet some_number: Option<i32> = Some(5);\nlet none_number: Option<i32> = None;\n\n// map transforms the value inside Some, leaves None unchanged\nlet doubled_some = some_number.map(|x| x * 2);  // Some(10)\nlet doubled_none = none_number.map(|x| x * 2);  // None\n\n// This is different from iterator map!\n// Iterator map: transforms each element in a collection\n// Option map: transforms the single value IF it exists\n\n// Comparison with iterator map:\nlet numbers = vec![1, 2, 3];\nlet doubled_vec: Vec<i32> = numbers.iter().map(|x| x * 2).collect();  // [2, 4, 6]\n\n// Option map is like having a collection with 0 or 1 elements:\n// Some(value) is like a collection with 1 element\n// None is like an empty collection\n\n// Practical crypto example:\nlet maybe_key: Option<[u8; 32]> = get_encryption_key();\n\n// Transform key to key ID without unwrapping\nlet key_id: Option<u32> = maybe_key.map(|key| {\n    // This closure only runs if maybe_key is Some(key)\n    calculate_key_id(&key)  // Returns u32\n});  // Returns Option<u32>\n\n// Chain multiple transformations safely\nlet key_info: Option<String> = maybe_key\n    .map(|key| calculate_key_id(&key))      // Option<[u8; 32]> -> Option<u32>\n    .map(|id| format!(\"Key-{:08x}\", id));   // Option<u32> -> Option<String>\n\n// For cryptography: handling optional keys\nfn example_crypto_option_usage() -> Result<Vec<u8>, CryptoError> {\n    let key: Option<SecureKey<32>> = get_key();\n\n    // Side effect: setting a key\n    if let Some(ref k) = key {\n        // cipher.set_key(k.as_bytes());\n    }\n\n    // Transformation: creating encrypted data\n    let data = b\"secret message\";\n    let encrypted = key\n        .map(|k| encrypt_with_key(data, &k))\n        .ok_or(CryptoError::NoKey)?;\n    \n    Ok(encrypted)\n}\n\n// Helper functions for the example\nfn get_key() -> Option<SecureKey<32>> {\n    Some(SecureKey::new([0x42; 32]))\n}\n\nfn encrypt_with_key(data: &[u8], _key: &SecureKey<32>) -> Vec<u8> {\n    data.to_vec() // Placeholder\n}\n\n#[derive(Debug)]\nenum CryptoError {\n    NoKey,\n}\n\nstruct SecureKey<const N: usize> {\n    data: [u8; N],\n}\n\nimpl<const N: usize> SecureKey<N> {\n    fn new(data: [u8; N]) -> Self {\n        Self { data }\n    }\n    \n    fn as_bytes(&self) -> &[u8; N] {\n        &self.data\n    }\n}",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Arrays and Slices",
        "line_number": 4308,
        "language": "rust",
        "code": "// Fixed-size array (stack allocated)\nlet arr: [u8; 16] = [0; 16];  // 16 bytes, all zeros\n\n// Slice (view into array)\nlet slice: &[u8] = &arr[0..8];  // First 8 bytes\n\n// No decay to pointers like C!\nfn process_data(data: &[u8]) {\n    for byte in data {\n        // Safe iteration, no bounds checking needed\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Type Inference",
        "line_number": 4325,
        "language": "rust",
        "code": "// C: Must specify types\nuint32_t value = 0x1234;\nuint16_t* ptr = &value;  // Warning/Error\n\n// Rust: Smart type inference\nlet value = 0x1234u32;  // Explicitly u32\nlet value: u32 = 0x1234;  // Type annotation\nlet value = 0x1234;  // Inferred from usage",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Core Concepts",
        "line_number": 4342,
        "language": "rust",
        "code": "// STATEMENTS (don't return values, end with semicolon)\nlet x = 5;           // let binding is a statement\nx = 10;              // assignment is a statement\nuse std::io;         // use statement\n\n// EXPRESSIONS (return values, no semicolon when used as return)\n5                    // literal expression, returns 5\nx + 1                // arithmetic expression\nif x > 0 { 1 } else { -1 }  // if is an expression!\n\n// THE KEY RULE: Semicolon turns expression into statement\nx + 1;               // This discards the value, returns ()\nx + 1                // This returns the value (when used as last expression)",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "The Unit Type ()",
        "line_number": 4362,
        "language": "rust",
        "code": "// Functions that return nothing actually return ()\nfn print_number(n: i32) {  // -> () is implied\n    println!(\"{}\", n);\n    // Implicitly returns ()\n}\n\n// Assignment always returns ()\nlet mut x = 5;\nlet result = (x = 10);  // result is (), not 10! (different from C)",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Expression Types and Return Behavior",
        "line_number": 4376,
        "language": "rust",
        "code": "// 1. BLOCKS are expressions - return last expression's value\nlet result = {\n    let x = 5;        // Statement inside block\n    let y = 10;       // Statement inside block\n    x + y             // Expression - becomes the block's return value\n};  // result = 15\n\n// 2. CONTROL FLOW expressions\nlet value = if condition { 42 } else { 0 };\n\nlet crypto_mode = match security_level {\n    1 => \"basic\",\n    2 => \"standard\",\n    3 => {\n        log_high_security();  // Statement\n        \"advanced\"            // Expression - returned from block\n    },\n    _ => \"unknown\",\n};\n\n// 3. LOOP expressions - only `loop` can return values\nlet result = loop {\n    if done {\n        break 42;     // loop returns 42\n    }\n};\n\n// while and for always return ()\nlet _unit = while condition { /* ... */ };  // Always ()\nlet _unit = for item in collection { /* ... */ };  // Always ()\n\n// 4. FUNCTION returns\nfn calculate() -> i32 {\n    let x = 5;        // Statement\n    let y = 10;       // Statement\n\n    // Two ways to return:\n    return x + y;     // Explicit return (can be anywhere)\n    // x + y          // Implicit return (must be last, no semicolon)\n}\n\n// 5. NESTED expressions\nlet complex_result = {\n    let intermediate = {\n        let a = 10;\n        let b = 20;\n        a + b             // Returns 30\n    };\n\n    if intermediate > 25 { \"high\" } else { \"low\" }\n};  // \"high\"",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Practical Crypto Examples",
        "line_number": 4432,
        "language": "rust",
        "code": "// Crypto key derivation using expressions\nfn derive_key(master_key: &[u8], salt: &[u8]) -> [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(master_key);    // Statement\n    hasher.update(salt);          // Statement\n\n    hasher.finalize().into()      // Expression - returned (no semicolon!)\n}\n\n// Algorithm selection with match expression\nlet cipher = match algorithm {\n    Algorithm::AES128 => {\n        let mut engine = CryptoEngine::new();\n        engine.configure_aes(KeySize::Bits128);\n        engine  // Return configured engine\n    },\n    Algorithm::AES256 => {\n        let mut engine = CryptoEngine::new();\n        engine.configure_aes(KeySize::Bits256);\n        engine\n    },\n    Algorithm::ChaCha20 => CryptoEngine::new_chacha20(),\n};\n\n// Conditional compilation as expression\nlet buffer_size = if cfg!(feature = \"large-buffer\") {\n    1024\n} else {\n    256\n};\n\n// Error handling with early returns\nfn check_sensor() -> Result<u16, Error> {\n    let value = read_adc();\n\n    if value > MAX_VALUE {\n        return Err(Error::OutOfRange);  // Early return\n    }\n\n    Ok(value)  // Implicit return (no semicolon)\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Key Differences from C",
        "line_number": 4478,
        "language": "rust",
        "code": "// C: if/while/for are statements, need separate variable declaration\nint value;\nif (condition) {\n    value = 10;\n} else {\n    value = 20;\n}\n\n// Rust: if is expression, direct assignment\nlet value = if condition { 10 } else { 20 };\n\n// C: Assignment returns the assigned value\nint x, y;\ny = (x = 10);  // y is 10\n\n// Rust: Assignment returns ()\nlet mut x: i32;\nlet y = (x = 10);  // y is (), not 10!",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Practical Crypto Examples with Expressions",
        "line_number": 4501,
        "language": "rust",
        "code": "// Initialize crypto engine based on algorithm selection\nlet cipher = {\n    let mut engine = CryptoEngine::new();\n    match algorithm {\n        Algorithm::AES128 => engine.configure_aes(KeySize::Bits128),\n        Algorithm::AES256 => engine.configure_aes(KeySize::Bits256),\n        Algorithm::ChaCha20 => engine.configure_chacha20(),\n    }\n    engine.set_key(&key);\n    engine  // Return configured engine\n};\n\n// Key derivation as expression\nlet session_key = {\n    let mut kdf = Kdf::new();\n    kdf.extract(&salt, &input_key_material);\n    kdf.expand(&info, 32)  // Returns derived key\n};\n\n// Crypto operation selection\nimpl CryptoCore {\n    fn process(&mut self, op: Operation, data: &[u8]) -> Result<Vec<u8>, Error> {\n        match op {\n            Operation::Encrypt => self.encrypt(data),\n            Operation::Decrypt => self.decrypt(data),\n            Operation::Sign => self.sign(data),\n            Operation::Verify(sig) => {\n                if self.verify(data, sig) {\n                    Ok(vec![1])  // Success\n                } else {\n                    Ok(vec![0])  // Failure\n                }\n            }\n        }\n    }\n}\n\n// Constant-time conditional selection\nfn ct_select(condition: bool, a: u32, b: u32) -> u32 {\n    let mask = (-(condition as i32)) as u32;\n    (a & mask) | (b & !mask)\n}\n\n// Side-channel resistant error handling\nfn decrypt_and_verify(ciphertext: &[u8], tag: &[u8]) -> Result<Vec<u8>, Error> {\n    let plaintext = decrypt(ciphertext);\n    let computed_tag = compute_mac(&plaintext);\n    \n    // Always complete both operations before checking\n    let valid = constant_time_compare(&computed_tag, tag);\n    \n    if valid {\n        Ok(plaintext)\n    } else {\n        Err(Error::AuthenticationFailed)\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Rust Memory Model",
        "line_number": 4628,
        "language": "rust",
        "code": "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                       RUST MEMORY MODEL                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  Stack (grows down \u2193)              Heap (if enabled)        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502 Owned Values    \u2502               \u2502 Box<T>          \u2502      \u2502\n\u2502  \u2502 References &    \u2502               \u2502 Vec<T>          \u2502      \u2502\n\u2502  \u2502 Mutable Refs &mut\u2502              \u2502 String          \u2502      \u2502\n\u2502  \u2502                 \u2502               \u2502                 \u2502      \u2502\n\u2502  \u2502 key: [u8; 32] \u25c4\u2500\u253c\u2500 OWNS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                 \u2502      \u2502\n\u2502  \u2502 borrowed: &key \u25c4\u2500\u253c\u2500 BORROWS \u2500\u2500\u2500\u2500\u2524 Ownership       \u2502      \u2502\n\u2502  \u2502                 \u2502               \u2502 tracked at      \u2502      \u2502\n\u2502  \u2502 cipher: Box<T> \u2500\u253c\u2500 OWNS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502 compile time    \u2502      \u2502\n\u2502  \u2502                 \u2502               \u2502                 \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                             \u2502\n\u2502  OWNERSHIP RULES:                                           \u2502\n\u2502  \u2713 Each value has exactly one owner                         \u2502\n\u2502  \u2713 When owner goes out of scope, value is dropped           \u2502\n\u2502  \u2713 Can have EITHER:                                         \u2502\n\u2502    - One mutable reference (&mut T)                         \u2502\n\u2502    - Multiple immutable references (&T)                     \u2502\n\u2502                                                             \u2502\n\u2502  COMPILE-TIME GUARANTEES:                                   \u2502\n\u2502  \u2705 No null pointers (use Option<T>)                        \u2502\n\u2502  \u2705 No dangling pointers                                    \u2502\n\u2502  \u2705 No buffer overflows                                     \u2502\n\u2502  \u2705 No use after free                                       \u2502\n\u2502  \u2705 No double free                                          \u2502\n\u2502  \u2705 No data races                                           \u2502\n\u2502  \u2705 Automatic memory cleanup                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Rust Memory Model",
        "line_number": 4665,
        "language": "rust",
        "code": "// 1. Buffer Overflow Prevention\nlet mut key = [0u8; 16];\n// key.copy_from_slice(&user_input);  // Compile error if wrong size!\nif user_input.len() == 16 {\n    key.copy_from_slice(&user_input);  // Safe copy\n}\n\n// 2. Use After Move Prevention\nlet buffer = vec![0u8; 256];\ndrop(buffer);  // Buffer is moved\n// buffer[0] = 0;  // Compile error: use of moved value!\n\n// 3. No Double Free\nlet buffer = Box::new([0u8; 256]);\ndrop(buffer);  // Ownership transferred\n// drop(buffer);  // Compile error: use of moved value!\n\n// 4. Lifetime Checking\nfn get_temp_buffer() -> &'static [u8] {\n    let temp = [0u8; 256];\n    // &temp  // Compile error: temp doesn't live long enough!\n    &STATIC_BUFFER  // OK: 'static lifetime\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Stack and Ownership Flow",
        "line_number": 4713,
        "language": "rust",
        "code": "RUST OWNERSHIP FLOW:\n                                          \nmain() {                                  Stack Frame\n    let key = [0u8; 32];  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                          \u2502 key: [u8;32]\u2502 \n    process_key(key);     \u2500\u2500\u2500 MOVE \u2500\u2500\u2500\u2500\u2500\u25ba \u2502 [MOVED OUT] \u2502\n                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    // key no longer accessible here\n}                                         \n                                          \nprocess_key(k: [u8; 32]) { \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                          \u2502 k: [u8; 32] \u2502\n    encrypt_with_key(&k); \u2500 BORROW \u2500\u2500\u2500\u2500\u2500\u25ba \u2502 still valid \u2502\n                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n} // k dropped here\n\nBORROWING RULES:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 let mut data = vec![1, 2, 3];                      \u2502\n\u2502                                                    \u2502\n\u2502 // Multiple immutable borrows OK                   \u2502\n\u2502 let r1 = &data;       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u2502\n\u2502 let r2 = &data;       \u2502 data \u2502 \u25c4\u2500\u2500 &r1             \u2502\n\u2502 println!(\"{:?}\", r1); \u2502      \u2502 \u25c4\u2500\u2500 &r2             \u2502\n\u2502                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2502\n\u2502                                                    \u2502\n\u2502 // Mutable borrow exclusive                        \u2502\n\u2502 let m1 = &mut data; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u2502\n\u2502 //let m2 = &mut data; \u2502 data \u2502 \u25c4\u2500\u2500 &mut m1 (excl) \u2502\n\u2502 // \u2191 ERROR!         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Stack and Heap Allocation",
        "line_number": 4749,
        "language": "rust",
        "code": "// C: Manual memory management\nuint8_t* buffer = (uint8_t*)malloc(256);\nif (buffer == NULL) { /* handle error */ }\n// ... use buffer ...\nfree(buffer);  // Must remember to free\n// buffer is now dangling pointer\n\n// Rust: Ownership handles deallocation\n// Stack allocation (preferred in embedded)\nlet buffer = [0u8; 256];  // Fixed size, stack allocated\n\n// Heap allocation (if available in embedded)\nlet buffer = Box::new([0u8; 256]);  // Automatically freed when dropped\n// Can't use buffer after it goes out of scope",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Lifetime Visualization",
        "line_number": 4789,
        "language": "rust",
        "code": "// Crypto context that borrows a key\nstruct CryptoContext<'a> {\n    key: &'a [u8; 32],\n    algorithm: &'static str,\n}\n\nfn create_crypto_context<'a>(key: &'a [u8; 32]) -> CryptoContext<'a> {\n    CryptoContext {\n        key,  // Borrows key with lifetime 'a\n        algorithm: \"AES-256\",\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Lifetime Visualization",
        "line_number": 4804,
        "language": "rust",
        "code": "// SIMPLE STEP-BY-STEP LIFETIME EXPLANATION:\n\nfn main() {\n    // STEP 1: Create the key (it's like creating a house \ud83c\udfe0)\n    let master_key = [0u8; 32];\n\n    // STEP 2: Create context that borrows the key (like giving someone the house address)\n    let ctx = create_crypto_context(&master_key);\n    // Now ctx.key points to master_key\n\n    // STEP 3: Use the context (person visits the house using the address)\n    let encrypted = ctx.encrypt(b\"secret data\");\n\n    // STEP 4: What happens at the end?\n    // Rust automatically drops variables in REVERSE order:\n    // 1. ctx gets dropped first (person forgets the address)\n    // 2. master_key gets dropped second (house gets demolished)\n\n    // This order is SAFE because:\n    // - When ctx is dropped, it stops pointing to master_key\n    // - Only then is master_key dropped\n    // - No dangling pointers!\n}\n\n// WHAT RUST PREVENTS:\nfn what_rust_prevents() {\n    let master_key = [0u8; 32];\n    let ctx = create_crypto_context(&master_key);\n\n    // This would be a COMPILE ERROR:\n    // drop(master_key);  // \u2190 Can't demolish house while someone has the address!\n    // ctx.encrypt(data); // \u2190 This would use invalid memory\n}\n\n// SIMPLE RULE:\n// If A borrows from B, then B must live at least as long as A\n//\n// In our case:\n// - ctx (A) borrows from master_key (B)\n// - So master_key must live at least as long as ctx\n// - Rust enforces this automatically!\n\n// THINK OF IT LIKE:\n// master_key = a book \ud83d\udcd6\n// ctx = a bookmark \ud83d\udd16 pointing to a page in the book\n//\n// You can't throw away the book while the bookmark is still pointing to it!\n// The book must exist as long as the bookmark exists.",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Lifetime Visualization",
        "line_number": 4855,
        "language": "rust",
        "code": "// PRACTICAL CRYPTO EXAMPLE:\nfn secure_operation() -> Result<Vec<u8>, CryptoError> {\n    let session_key = derive_session_key()?;  // session_key created\n\n    let crypto_ctx = create_crypto_context(&session_key);  // Borrow starts\n\n    let plaintext = b\"sensitive data\";\n    let ciphertext = crypto_ctx.encrypt(plaintext)?;\n\n    // session_key is still borrowed by crypto_ctx here\n    // Cannot move or drop session_key until crypto_ctx is done\n\n    Ok(ciphertext)\n    // crypto_ctx dropped here, then session_key\n    // session_key is automatically zeroized on drop\n}\n\n// LIFETIME ERRORS PREVENTED:\nfn lifetime_error_example() {\n    let ctx;  // Declare ctx outside inner scope\n\n    {\n        let temp_key = [0u8; 32];  // temp_key has short lifetime\n        ctx = create_crypto_context(&temp_key);  // ERROR!\n        // \u2191 temp_key doesn't live long enough\n    }  // temp_key would be dropped here\n\n    // ctx.encrypt(data);  // Would use dangling reference!\n}\n\n// The compiler prevents this with:\n// error[E0597]: `temp_key` does not live long enough\n//   --> src/main.rs:XX:XX\n//    |\n// XX |         ctx = create_crypto_context(&temp_key);\n//    |                                     ^^^^^^^^^ borrowed value does not live long enough\n// XX |     }\n//    |     - `temp_key` dropped here while still borrowed",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Memory Layout and Alignment",
        "line_number": 4926,
        "language": "rust",
        "code": "// C: Compiler may reorder/pad structs\nstruct Packet {\n    uint8_t  header;   // 1 byte\n    uint32_t length;   // 4 bytes (may have 3 bytes padding before)\n    uint8_t  data[16]; // 16 bytes\n};  // Total: potentially 24 bytes due to padding\n\n// Rust: Explicit control over layout\n#[repr(C)]  // C-compatible layout\nstruct Packet {\n    header: u8,\n    length: u32,\n    data: [u8; 16],\n}\n\n#[repr(packed)]  // No padding (careful with alignment!)\nstruct PackedPacket {\n    header: u8,\n    length: u32,    // Unaligned access!\n    data: [u8; 16],\n}\n\n#[repr(align(4))]  // Force alignment\nstruct AlignedBuffer {\n    data: [u8; 64],\n}",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Undefined Behavior Prevention",
        "line_number": 4957,
        "language": "rust",
        "code": "// C: Many sources of undefined behavior\nint arr[10];\narr[15] = 42;        // UB: Buffer overflow\nint* ptr = NULL;\n*ptr = 42;           // UB: Null pointer deref\nint x;\nuse_value(x);        // UB: Uninitialized read\n\n// Rust: Prevents UB at compile time\nlet arr = [0; 10];\n// arr[15] = 42;     // Compile error: index out of bounds\nlet ptr: Option<&mut i32> = None;\n// *ptr = 42;        // Compile error: can't deref Option\n\nlet x: i32;\n// use_value(x);     // Compile error: use of uninitialized variable",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Volatile Access for Crypto Hardware",
        "line_number": 4978,
        "language": "rust",
        "code": "// C: volatile for crypto registers\nvolatile uint32_t* const AES_KEY = (uint32_t*)0x50060000;\nvolatile uint32_t* const AES_DATA = (uint32_t*)0x50060010;\n*AES_KEY = key_word;  // Key might be optimized/cached\n\n// Rust: Explicit volatile for secure operations\nuse core::ptr::{read_volatile, write_volatile};\n\nconst AES_KEY: *mut u32 = 0x5006_0000 as *mut u32;\nconst AES_DATA: *mut u32 = 0x5006_0010 as *mut u32;\n\n// Ensure key material isn't cached\nunsafe {\n    for (i, &key_word) in key.chunks_exact(4).enumerate() {\n        let key_u32 = u32::from_ne_bytes(key_word.try_into().unwrap());\n        write_volatile(AES_KEY.add(i), key_u32);\n        \n        // Force write completion\n        core::sync::atomic::compiler_fence(Ordering::SeqCst);\n    }\n}\n\n// Better: Use PAC with built-in volatile access\ncrypto.aes.key0.write(|w| unsafe { w.bits(key_words[0]) });\ncrypto.aes.key1.write(|w| unsafe { w.bits(key_words[1]) });\n\n// Secure register clearing\nfn clear_crypto_registers(crypto: &mut CRYPTO) {\n    // Volatile writes ensure registers are actually cleared\n    crypto.key0.write(|w| unsafe { w.bits(0) });\n    crypto.key1.write(|w| unsafe { w.bits(0) });\n    crypto.data.write(|w| unsafe { w.bits(0) });\n    \n    // Ensure writes complete before continuing\n    cortex_m::asm::dsb();\n}",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Memory Ordering and Atomics",
        "line_number": 5019,
        "language": "rust",
        "code": "// C: Compiler/hardware may reorder operations\nint ready = 0;\nint data = 0;\n// Thread 1:\ndata = 42;\nready = 1;  // May be reordered before data write!\n\n// Rust: Explicit memory ordering\nuse core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n\nstatic READY: AtomicBool = AtomicBool::new(false);\nstatic DATA: AtomicU32 = AtomicU32::new(0);\n\n// Producer\nDATA.store(42, Ordering::Relaxed);\nREADY.store(true, Ordering::Release);  // Ensures DATA write completes first\n\n// Consumer\nwhile !READY.load(Ordering::Acquire) {}  // Ensures DATA read happens after\nlet value = DATA.load(Ordering::Relaxed);\n\n// For crypto: ensuring operations complete in order\nuse core::sync::atomic::{compiler_fence, fence};\n\n// Write key to crypto hardware\nwrite_volatile(CRYPTO_KEY_REG, key);\ncompiler_fence(Ordering::SeqCst);  // Prevent compiler reordering\n\n// Write data to process\nwrite_volatile(CRYPTO_DATA_REG, data);\nfence(Ordering::SeqCst);  // Full memory barrier\n\n// Start crypto operation\nwrite_volatile(CRYPTO_CTRL_REG, START_BIT);",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Zero-Copy Operations",
        "line_number": 5058,
        "language": "rust",
        "code": "// C: Risky pointer casting for crypto operations\ntypedef struct {\n    uint8_t nonce[12];\n    uint8_t tag[16];\n    uint8_t ciphertext[256];\n} AeadPacket;\n\nuint8_t buffer[284];\nAeadPacket* pkt = (AeadPacket*)buffer;  // Hope alignment is correct!\n\n// Rust: Safe zero-copy with proper checks\n#[repr(C, packed)]  // Ensure no padding for crypto protocols\nstruct AeadPacket {\n    nonce: [u8; 12],\n    tag: [u8; 16],\n    ciphertext: [u8; 256],\n}\n\nlet buffer = [0u8; 284];\n// Safe transmute with compile-time size checking\nlet packet: &AeadPacket = bytemuck::from_bytes(&buffer);\n\n// Or for cryptographic parsing with endianness\nuse core::convert::TryInto;\nstruct CryptoHeader {\n    version: u8,\n    algorithm: u8,\n    key_id: u16,\n}\n\nimpl CryptoHeader {\n    fn parse(data: &[u8]) -> Option<Self> {\n        if data.len() < 4 {\n            return None;\n        }\n        Some(Self {\n            version: data[0],\n            algorithm: data[1],\n            key_id: u16::from_be_bytes(data[2..4].try_into().ok()?),\n        })\n    }\n}",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Static Memory in Embedded",
        "line_number": 5105,
        "language": "rust",
        "code": "// C: Static initialization order issues\nstatic int counter = 0;\nstatic int* ptr = &counter;  // OK in C\n\n// Rust: Compile-time const evaluation\nstatic mut COUNTER: u32 = 0;  // Requires unsafe to access\nstatic BUFFER: [u8; 1024] = [0; 1024];  // Const initialization\n\n// For complex initialization\nuse cortex_m::singleton;\nlet buffer: &'static mut [u8; 1024] = singleton!(: [u8; 1024] = [0; 1024]).unwrap();",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "DMA-Safe Memory for Crypto Operations",
        "line_number": 5121,
        "language": "rust",
        "code": "// Ensure crypto buffers are DMA-safe and cache-aligned\n#[repr(C, align(32))]  // Cache line alignment\nstruct CryptoBuffer {\n    plaintext: [u8; 1024],\n    ciphertext: [u8; 1024],\n}\n\n// Prevent compiler optimizations on sensitive data\nimpl CryptoBuffer {\n    fn clear_secrets(&mut self) {\n        use core::sync::atomic::{compiler_fence, Ordering};\n        \n        // Secure zeroization\n        for byte in self.plaintext.iter_mut() {\n            unsafe { core::ptr::write_volatile(byte, 0) };\n        }\n        \n        // Prevent dead store elimination\n        compiler_fence(Ordering::SeqCst);\n    }\n}\n\n// Pin buffer for DMA crypto operations\nlet mut crypto_buf = CryptoBuffer {\n    plaintext: [0; 1024],\n    ciphertext: [0; 1024],\n};\n\n// Use with crypto DMA engine\ncrypto_engine.encrypt_dma(\n    crypto_buf.plaintext.as_ptr(),\n    crypto_buf.ciphertext.as_mut_ptr(),\n    1024,\n);",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Common Crypto Pitfalls When Coming from C",
        "line_number": 5160,
        "language": "rust",
        "code": "// 1. Key material handling\n// C: Manual zeroing, often optimized away\nvoid clear_key(uint8_t* key, size_t len) {\n    memset(key, 0, len);  // May be optimized away!\n}\n\n// Rust: Guaranteed zeroization\nuse zeroize::Zeroize;\nlet mut key = [0u8; 32];\nkey.zeroize();  // Won't be optimized away\n\n// 2. Constant-time operations\n// C: Compiler may optimize timing-sensitive code\nif (memcmp(computed_mac, expected_mac, 16) == 0) {\n    // Timing leak!\n}\n\n// Rust: Explicit constant-time operations\nuse subtle::ConstantTimeEq;\nif computed_mac.ct_eq(&expected_mac).unwrap_u8() == 1 {\n    // Constant time comparison\n}\n\n// 3. Overflow in crypto math\n// C: Silent overflow in modular arithmetic\nuint32_t a = 0xFFFFFFFF;\nuint32_t b = a + 1;  // Wraps to 0, undefined in C\n\n// Rust: Explicit overflow handling\nlet a: u32 = 0xFFFFFFFF;\nlet b = a.wrapping_add(1);      // Explicit wrap\nlet b = a.checked_add(1);        // Returns None\nlet b = a.saturating_add(1);     // Saturates at max\n\n// 4. Endianness in crypto protocols\n// C: Platform-dependent behavior\nuint32_t value = *(uint32_t*)buffer;  // Endianness?\n\n// Rust: Explicit endianness\nlet value = u32::from_be_bytes(buffer[0..4].try_into()?);\nlet value = u32::from_le_bytes(buffer[0..4].try_into()?);",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Memory Safety in Cryptographic Context",
        "line_number": 5206,
        "language": "rust",
        "code": "// Preventing key reuse after move\nstruct CryptoContext {\n    key: SecureKey<32>,\n}\n\nimpl CryptoContext {\n    fn encrypt(&self, data: &[u8]) -> Vec<u8> {\n        // Can use key multiple times through &self\n        cipher_with_key(self.key.as_bytes(), data)\n    }\n}\n\n// Key is automatically zeroized when context is dropped\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n\n// SECURE implementation - key IS zeroized\n#[derive(ZeroizeOnDrop)]\nstruct SecureKey<const N: usize> {\n    key_material: [u8; N],\n}\n\nimpl<const N: usize> Drop for SecureKey<N> {\n    fn drop(&mut self) {\n        // Securely zeroize the key material\n        self.key_material.zeroize();\n        // Compiler fence to prevent optimization\n        core::sync::atomic::compiler_fence(core::sync::atomic::Ordering::SeqCst);\n    }\n}\n\nlet ctx = CryptoContext { key: SecureKey::new(master_key) };\nlet ciphertext = ctx.encrypt(b\"secret data\");\n// ctx.key automatically cleared when ctx goes out of scope\n\n// Preventing double-free of sensitive material\nstruct KeyMaterial {\n    ptr: *mut u8,\n    len: usize,\n}\n\nimpl Drop for KeyMaterial {\n    fn drop(&mut self) {\n        unsafe {\n            // Zeroize before deallocation\n            core::ptr::write_bytes(self.ptr, 0, self.len);\n            dealloc(self.ptr, self.len);\n        }\n    }\n}\n// Automatically freed once, can't double-free\n\n// Side-channel resistant code patterns\nfn select_constant_time(condition: bool, a: u32, b: u32) -> u32 {\n    // Branchless selection\n    let mask = (condition as u32).wrapping_sub(1);\n    (a & !mask) | (b & mask)\n}\n\n// Compile-time bounds checking for crypto operations\nfn xor_blocks<const N: usize>(a: &[u8; N], b: &[u8; N]) -> [u8; N] {\n    let mut result = [0u8; N];\n    for i in 0..N {\n        result[i] = a[i] ^ b[i];  // No bounds checks needed\n    }\n    result\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "The Three Rules of Ownership",
        "line_number": 5285,
        "language": "rust",
        "code": "// Basic ownership example\nfn main() {\n    let key = vec![0u8; 32];  // main owns 'key'\n    process_key(key);         // ownership moves to process_key\n    // println!(\"{:?}\", key); // ERROR: key was moved\n}\n\nfn process_key(k: Vec<u8>) {  // process_key now owns 'k'\n    // Use the key\n} // 'k' is dropped here\n\n// Moving ownership\nlet s1 = String::from(\"secret\");\nlet s2 = s1;  // s1 is moved to s2\n// println!(\"{}\", s1);  // ERROR: s1 no longer valid\n\n// In C, this would be a shallow copy potentially leading to double-free\n// In Rust, s1 is invalidated, preventing the double-free",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Borrowing References",
        "line_number": 5308,
        "language": "rust",
        "code": "// Immutable borrow (&T)\nlet data = vec![1, 2, 3, 4];\nlet sum = calculate_sum(&data);  // Borrow data\nprintln!(\"{:?}\", data);  // Can still use data\n\nfn calculate_sum(values: &Vec<i32>) -> i32 {\n    values.iter().sum()\n}\n\n// Mutable borrow (&mut T)\nlet mut buffer = [0u8; 128];\nfill_buffer(&mut buffer);\n\nfn fill_buffer(buf: &mut [u8]) {\n    for (i, byte) in buf.iter_mut().enumerate() {\n        *byte = i as u8;\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Lifetimes",
        "line_number": 5333,
        "language": "rust",
        "code": "// Simple lifetime example\nfn get_first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n    \n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n    \n    &s[..]\n}\n\n// Lifetime annotation needed when returning references\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n\n// Common in embedded: static lifetime for constant data\nconst LOOKUP_TABLE: &'static [u8] = &[\n    0x00, 0x1B, 0x36, 0x2D, 0x6C, 0x77, 0x5A, 0x41,\n];\n\n// Struct containing reference needs lifetime\nstruct CryptoContext<'a> {\n    key: &'a [u8],\n    algorithm: Algorithm,\n}\n\n#[derive(Copy, Clone)]\nenum Algorithm {\n    AES128,\n    AES256,\n    ChaCha20,\n}\n\nimpl<'a> CryptoContext<'a> {\n    fn new(key: &'a [u8]) -> Self {\n        Self {\n            key,\n            algorithm: Algorithm::AES256,\n        }\n    }\n    \n    fn encrypt(&self, data: &[u8]) -> Vec<u8> {\n        // Use self.key which has lifetime 'a\n        // This is a placeholder - real implementation would use the key\n        data.to_vec()  // Placeholder\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Interior Mutability",
        "line_number": 5390,
        "language": "rust",
        "code": "use core::cell::{Cell, RefCell};\n\n// Cell: for Copy types, no runtime borrow checking\nstruct Counter {\n    value: Cell<u32>,\n}\n\nimpl Counter {\n    fn new() -> Self {\n        Self { value: Cell::new(0) }\n    }\n    \n    fn increment(&self) {  // Note: &self, not &mut self\n        let current = self.value.get();\n        self.value.set(current + 1);\n    }\n}\n\n// RefCell: for any type, runtime borrow checking\n#[derive(Debug)]\nenum EngineState {\n    Idle,\n    Processing,\n    Error,\n}\n\nstruct CryptoEngine {\n    state: RefCell<EngineState>,\n}\n\nimpl CryptoEngine {\n    fn new() -> Self {\n        Self {\n            state: RefCell::new(EngineState::Idle),\n        }\n    }\n    \n    fn process(&self, data: &[u8]) {  // &self, not &mut self\n        let mut state = self.state.borrow_mut();  // Runtime borrow check\n        \n        match *state {\n            EngineState::Idle => {\n                *state = EngineState::Processing;\n                // Process data...\n            }\n            _ => panic!(\"Invalid state\"),\n        }\n    }\n}\n\n// Placeholder for registers struct\nstruct Registers {\n    control: u32,\n    status: u32,\n    data: u32,\n}\n\n// Common pattern in embedded: hardware register access\nstruct Peripheral {\n    registers: RefCell<Registers>,\n}\n\nimpl Peripheral {\n    fn configure(&self) {\n        // Can mutate even though &self is immutable\n        self.registers.borrow_mut().control = 0x01;\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "The Result Type",
        "line_number": 5467,
        "language": "rust",
        "code": "// C style: error codes\nint read_sensor(uint16_t* value) {\n    if (!sensor_ready()) {\n        return -1;  // Error\n    }\n    *value = read_register();\n    return 0;  // Success\n}\n\n// Rust style: Result<T, E>\nfn read_sensor() -> Result<u16, SensorError> {\n    if !sensor_ready() {\n        return Err(SensorError::NotReady);\n    }\n    Ok(read_register())\n}\n\n// Using the result\nmatch read_sensor() {\n    Ok(value) => process_value(value),\n    Err(SensorError::NotReady) => retry_later(),\n    Err(e) => log_error(e),\n}\n\n// Or use ? operator for propagation\nfn process_measurement() -> Result<(), SensorError> {\n    let value = read_sensor()?;  // Returns early if Err\n    let processed = value * 2;\n    store_value(processed)?;\n    Ok(())\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Custom Error Types",
        "line_number": 5503,
        "language": "rust",
        "code": "#[derive(Debug)]\nenum CryptoError {\n    InvalidKeySize,\n    InvalidNonceSize,\n    AuthenticationFailed,\n    HardwareError,\n    QueueFull,\n    Timeout,\n}\n\n// Implement conversion from hardware errors\nimpl From<RngError> for CryptoError {\n    fn from(_: RngError) -> Self {\n        CryptoError::HardwareError\n    }\n}\n\n// Use in Result types\ntype CryptoResult<T> = Result<T, CryptoError>;\n\n// Example usage\nfn encrypt_message(key: &[u8], nonce: &[u8], plaintext: &[u8]) -> CryptoResult<Vec<u8>> {\n    if key.len() != 32 {\n        return Err(CryptoError::InvalidKeySize);\n    }\n    if nonce.len() != 12 {\n        return Err(CryptoError::InvalidNonceSize);\n    }\n    \n    // Perform encryption...\n    Ok(vec![])  // Placeholder\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Panic Handling in Embedded",
        "line_number": 5540,
        "language": "rust",
        "code": "// Choose panic behavior in Cargo.toml dependencies\n// panic-halt = \"0.2\"      // Halt on panic\n// panic-reset = \"0.1\"     // Reset on panic\n// panic-semihosting = \"0.5\"  // Print via debugger\n\nuse panic_halt as _;  // The _ import just links the handler\n\n// Custom panic handler\n#[panic_handler]\nfn panic(info: &PanicInfo) -> ! {\n    // Log error, reset system, etc.\n    cortex_m::peripheral::SCB::sys_reset();\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "No-std Programming",
        "line_number": 5560,
        "language": "rust",
        "code": "#![no_std]  // No standard library\n#![no_main] // No standard main\n\n// Use core instead of std for basic functionality\nuse core::mem;\nuse core::slice;\nuse core::fmt::Write;  // For formatting without std\n\n// Available in no-std:\n// - Basic types and traits\n// - Option, Result\n// - Iterator traits\n// - Atomic operations\n// - Core algorithms\n// - Format traits (but not print!/println!)\n\n// NOT available without std:\n// - Heap allocation (Vec, String, HashMap) - unless you add it\n// - File I/O\n// - Network\n// - Threads\n// - println!/print! macros",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Heap Allocation in No-std",
        "line_number": 5589,
        "language": "rust",
        "code": "// In Cargo.toml, add:\n// [dependencies]\n// linked_list_allocator = \"0.10\"\n\n#![feature(alloc_error_handler)]  // Required for custom allocator\n\nextern crate alloc;\nuse alloc::vec::Vec;\nuse linked_list_allocator::LockedHeap;\n\n#[global_allocator]\nstatic ALLOCATOR: LockedHeap = LockedHeap::empty();\n\n// Initialize the allocator with some RAM\nconst HEAP_SIZE: usize = 16384;\nstatic mut HEAP: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n\nfn init_heap() {\n    unsafe {\n        ALLOCATOR.lock().init(HEAP.as_ptr() as usize, HEAP_SIZE);\n    }\n}\n\n// Required: define allocation error handler\n#[alloc_error_handler]\nfn oom(_: core::alloc::Layout) -> ! {\n    panic!(\"Out of memory\");\n}",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Interfacing with Xilinx Crypto Accelerators",
        "line_number": 5632,
        "language": "rust",
        "code": "// build.rs - Build script for Xilinx BSP integration\nuse std::env;\nuse std::path::PathBuf;\n\nfn main() {\n    // Link against Xilinx BSP libraries\n    println!(\"cargo:rustc-link-lib=static=xilsecure\");\n    println!(\"cargo:rustc-link-lib=static=xilstandalone\");\n    println!(\"cargo:rustc-link-lib=static=xilffs\");\n    \n    // Add Xilinx BSP include paths\n    let xilinx_bsp_path = env::var(\"XILINX_BSP_PATH\")\n        .unwrap_or_else(|_| \"/opt/xilinx/bsp\".to_string());\n    \n    println!(\"cargo:rustc-link-search=native={}/lib\", xilinx_bsp_path);\n    \n    // Generate bindings for Xilinx crypto libraries\n    let bindings = bindgen::Builder::default()\n        .header(\"wrapper.h\")\n        .clang_arg(format!(\"-I{}/include\", xilinx_bsp_path))\n        .parse_callbacks(Box::new(bindgen::CargoCallbacks))\n        .generate()\n        .expect(\"Unable to generate bindings\");\n\n    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"xilinx_bindings.rs\"))\n        .expect(\"Couldn't write bindings!\");\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Interfacing with Xilinx Crypto Accelerators",
        "line_number": 5673,
        "language": "rust",
        "code": "// src/xilinx/crypto.rs - Safe Rust wrapper for Xilinx crypto\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n\ninclude!(concat!(env!(\"OUT_DIR\"), \"/xilinx_bindings.rs\"));\n\nuse core::mem::MaybeUninit;\nuse core::ptr;\n\n/// Safe wrapper for Xilinx AES accelerator\npub struct XilinxAes {\n    instance: XSecure_Aes,\n    initialized: bool,\n}\n\nimpl XilinxAes {\n    /// Initialize the AES accelerator\n    pub fn new() -> Result<Self, XilinxError> {\n        let mut instance = MaybeUninit::<XSecure_Aes>::uninit();\n        \n        let status = unsafe {\n            XSecure_AesInitialize(instance.as_mut_ptr(), XSECURE_CSUDMA_DEVICEID)\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            return Err(XilinxError::InitializationFailed(status));\n        }\n        \n        Ok(Self {\n            instance: unsafe { instance.assume_init() },\n            initialized: true,\n        })\n    }\n    \n    /// Set encryption key\n    pub fn set_key(&mut self, key: &[u8; 32], key_type: KeyType) -> Result<(), XilinxError> {\n        if !self.initialized {\n            return Err(XilinxError::NotInitialized);\n        }\n        \n        let key_src = match key_type {\n            KeyType::UserKey => XSECURE_AES_USER_KEY_0,\n            KeyType::DeviceKey => XSECURE_AES_DEVICE_KEY,\n            KeyType::KupKey => XSECURE_AES_KUP_KEY,\n        };\n        \n        let status = unsafe {\n            XSecure_AesWriteKey(\n                &mut self.instance,\n                key_src,\n                XSECURE_AES_KEY_SIZE_256,\n                key.as_ptr() as *const u64\n            )\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            Err(XilinxError::KeySetFailed(status))\n        } else {\n            Ok(())\n        }\n    }\n    \n    /// Encrypt data using AES-GCM\n    pub fn encrypt_gcm(\n        &mut self,\n        plaintext: &[u8],\n        iv: &[u8; 12],\n        aad: &[u8],\n        ciphertext: &mut [u8],\n        tag: &mut [u8; 16]\n    ) -> Result<(), XilinxError> {\n        if plaintext.len() != ciphertext.len() {\n            return Err(XilinxError::InvalidLength);\n        }\n        \n        let status = unsafe {\n            XSecure_AesEncryptData(\n                &mut self.instance,\n                plaintext.as_ptr() as u64,\n                ciphertext.as_mut_ptr() as u64,\n                plaintext.len() as u32,\n                iv.as_ptr() as u64,\n                aad.as_ptr() as u64,\n                aad.len() as u32,\n                tag.as_mut_ptr() as u64\n            )\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            Err(XilinxError::EncryptionFailed(status))\n        } else {\n            Ok(())\n        }\n    }\n    \n    /// Decrypt data using AES-GCM\n    pub fn decrypt_gcm(\n        &mut self,\n        ciphertext: &[u8],\n        iv: &[u8; 12],\n        aad: &[u8],\n        tag: &[u8; 16],\n        plaintext: &mut [u8]\n    ) -> Result<(), XilinxError> {\n        if plaintext.len() != ciphertext.len() {\n            return Err(XilinxError::InvalidLength);\n        }\n        \n        let status = unsafe {\n            XSecure_AesDecryptData(\n                &mut self.instance,\n                ciphertext.as_ptr() as u64,\n                plaintext.as_mut_ptr() as u64,\n                ciphertext.len() as u32,\n                iv.as_ptr() as u64,\n                aad.as_ptr() as u64,\n                aad.len() as u32,\n                tag.as_ptr() as u64\n            )\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            Err(XilinxError::DecryptionFailed(status))\n        } else {\n            Ok(())\n        }\n    }\n}\n\nimpl Drop for XilinxAes {\n    fn drop(&mut self) {\n        if self.initialized {\n            // Zeroize the AES instance to clear key material\n            unsafe {\n                ptr::write_volatile(&mut self.instance as *mut _, MaybeUninit::zeroed().assume_init());\n            }\n        }\n    }\n}\n\n/// Safe wrapper for Xilinx SHA accelerator\npub struct XilinxSha {\n    instance: XSecure_Sha3,\n}\n\nimpl XilinxSha {\n    pub fn new() -> Result<Self, XilinxError> {\n        let mut instance = MaybeUninit::<XSecure_Sha3>::uninit();\n        \n        let status = unsafe {\n            XSecure_Sha3Initialize(instance.as_mut_ptr(), XSECURE_CSUDMA_DEVICEID)\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            return Err(XilinxError::InitializationFailed(status));\n        }\n        \n        Ok(Self {\n            instance: unsafe { instance.assume_init() },\n        })\n    }\n    \n    /// Compute SHA3-256 hash\n    pub fn sha3_256(&mut self, data: &[u8]) -> Result<[u8; 32], XilinxError> {\n        let mut hash = [0u8; 32];\n        \n        let status = unsafe {\n            XSecure_Sha3Digest(\n                &mut self.instance,\n                data.as_ptr(),\n                data.len() as u32,\n                hash.as_mut_ptr()\n            )\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            Err(XilinxError::HashFailed(status))\n        } else {\n            Ok(hash)\n        }\n    }\n    \n    /// Start incremental hashing\n    pub fn start(&mut self) -> Result<(), XilinxError> {\n        let status = unsafe { XSecure_Sha3Start(&mut self.instance) };\n        \n        if status != XST_SUCCESS as i32 {\n            Err(XilinxError::HashFailed(status))\n        } else {\n            Ok(())\n        }\n    }\n    \n    /// Update hash with more data\n    pub fn update(&mut self, data: &[u8]) -> Result<(), XilinxError> {\n        let status = unsafe {\n            XSecure_Sha3Update(&mut self.instance, data.as_ptr(), data.len() as u32)\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            Err(XilinxError::HashFailed(status))\n        } else {\n            Ok(())\n        }\n    }\n    \n    /// Finalize hash and get result\n    pub fn finalize(&mut self) -> Result<[u8; 32], XilinxError> {\n        let mut hash = [0u8; 32];\n        \n        let status = unsafe {\n            XSecure_Sha3Finish(&mut self.instance, hash.as_mut_ptr())\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            Err(XilinxError::HashFailed(status))\n        } else {\n            Ok(hash)\n        }\n    }\n}\n\n/// Xilinx True Random Number Generator\npub struct XilinxTrng {\n    instance: XTrngpsx,\n}\n\nimpl XilinxTrng {\n    pub fn new() -> Result<Self, XilinxError> {\n        let mut instance = MaybeUninit::<XTrngpsx>::uninit();\n        let config = unsafe { XTrngpsx_LookupConfig(XPAR_XTRNGPSX_0_DEVICE_ID) };\n        \n        if config.is_null() {\n            return Err(XilinxError::ConfigNotFound);\n        }\n        \n        let status = unsafe {\n            XTrngpsx_CfgInitialize(instance.as_mut_ptr(), config, (*config).BaseAddress)\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            return Err(XilinxError::InitializationFailed(status));\n        }\n        \n        Ok(Self {\n            instance: unsafe { instance.assume_init() },\n        })\n    }\n    \n    /// Generate random bytes\n    pub fn generate(&mut self, output: &mut [u8]) -> Result<(), XilinxError> {\n        // TRNG generates 32-bit words, so we need to handle alignment\n        let mut temp_buffer = [0u32; 64]; // 256 bytes max\n        let words_needed = (output.len() + 3) / 4;\n        \n        if words_needed > temp_buffer.len() {\n            return Err(XilinxError::BufferTooLarge);\n        }\n        \n        let status = unsafe {\n            XTrngpsx_Generate(\n                &mut self.instance,\n                temp_buffer.as_mut_ptr(),\n                words_needed as u32,\n                1 // Wait for completion\n            )\n        };\n        \n        if status != XST_SUCCESS as i32 {\n            return Err(XilinxError::RngFailed(status));\n        }\n        \n        // Copy bytes from u32 array to output\n        let temp_bytes = unsafe {\n            core::slice::from_raw_parts(\n                temp_buffer.as_ptr() as *const u8,\n                output.len()\n            )\n        };\n        output.copy_from_slice(temp_bytes);\n        \n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum KeyType {\n    UserKey,\n    DeviceKey,\n    KupKey,\n}\n\n#[derive(Debug)]\npub enum XilinxError {\n    InitializationFailed(i32),\n    NotInitialized,\n    KeySetFailed(i32),\n    EncryptionFailed(i32),\n    DecryptionFailed(i32),\n    HashFailed(i32),\n    RngFailed(i32),\n    InvalidLength,\n    BufferTooLarge,\n    ConfigNotFound,\n}\n\n// Constants (these would come from the Xilinx headers)\nconst XST_SUCCESS: u32 = 0;\nconst XSECURE_CSUDMA_DEVICEID: u32 = 0;\nconst XSECURE_AES_USER_KEY_0: u32 = 0;\nconst XSECURE_AES_DEVICE_KEY: u32 = 1;\nconst XSECURE_AES_KUP_KEY: u32 = 2;\nconst XSECURE_AES_KEY_SIZE_256: u32 = 0;\nconst XPAR_XTRNGPSX_0_DEVICE_ID: u32 = 0;",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Using Xilinx BSP Libraries via FFI",
        "line_number": 5995,
        "language": "rust",
        "code": "// src/xilinx/bsp.rs - Higher-level BSP integration\nuse crate::xilinx::crypto::{XilinxAes, XilinxSha, XilinxTrng, KeyType, XilinxError};\nuse heapless::Vec;\n\n/// High-level crypto engine using Xilinx accelerators\npub struct XilinxCryptoEngine {\n    aes: XilinxAes,\n    sha: XilinxSha,\n    trng: XilinxTrng,\n}\n\nimpl XilinxCryptoEngine {\n    /// Initialize all crypto accelerators\n    pub fn new() -> Result<Self, XilinxError> {\n        Ok(Self {\n            aes: XilinxAes::new()?,\n            sha: XilinxSha::new()?,\n            trng: XilinxTrng::new()?,\n        })\n    }\n    \n    /// Generate a secure session key\n    pub fn generate_session_key(&mut self) -> Result<[u8; 32], XilinxError> {\n        let mut key = [0u8; 32];\n        self.trng.generate(&mut key)?;\n        Ok(key)\n    }\n    \n    /// Encrypt data with authenticated encryption\n    pub fn encrypt_message(\n        &mut self,\n        plaintext: &[u8],\n        key: &[u8; 32]\n    ) -> Result<EncryptedMessage, XilinxError> {\n        // Set the encryption key\n        self.aes.set_key(key, KeyType::UserKey)?;\n        \n        // Generate random IV\n        let mut iv = [0u8; 12];\n        self.trng.generate(&mut iv)?;\n        \n        // Prepare buffers\n        let mut ciphertext = vec![0u8; plaintext.len()];\n        let mut tag = [0u8; 16];\n        \n        // Encrypt with no additional authenticated data\n        self.aes.encrypt_gcm(plaintext, &iv, &[], &mut ciphertext, &mut tag)?;\n        \n        Ok(EncryptedMessage {\n            ciphertext,\n            iv,\n            tag,\n        })\n    }\n    \n    /// Decrypt and verify authenticated message\n    pub fn decrypt_message(\n        &mut self,\n        encrypted: &EncryptedMessage,\n        key: &[u8; 32]\n    ) -> Result<Vec<u8, 1024>, XilinxError> {\n        // Set the decryption key\n        self.aes.set_key(key, KeyType::UserKey)?;\n        \n        // Prepare plaintext buffer\n        let mut plaintext = vec![0u8; encrypted.ciphertext.len()];\n        \n        // Decrypt and verify\n        self.aes.decrypt_gcm(\n            &encrypted.ciphertext,\n            &encrypted.iv,\n            &[], // No AAD\n            &encrypted.tag,\n            &mut plaintext\n        )?;\n        \n        // Convert to heapless Vec for no-std compatibility\n        let mut result = Vec::new();\n        for &byte in &plaintext {\n            result.push(byte).map_err(|_| XilinxError::BufferTooLarge)?;\n        }\n        \n        Ok(result)\n    }\n    \n    /// Compute secure hash of data\n    pub fn hash_data(&mut self, data: &[u8]) -> Result<[u8; 32], XilinxError> {\n        self.sha.sha3_256(data)\n    }\n    \n    /// Compute HMAC using SHA3-256\n    pub fn hmac(&mut self, key: &[u8], message: &[u8]) -> Result<[u8; 32], XilinxError> {\n        // Simplified HMAC implementation using SHA3\n        // In production, use proper HMAC construction\n        \n        const BLOCK_SIZE: usize = 136; // SHA3-256 block size\n        let mut ipad = [0x36u8; BLOCK_SIZE];\n        let mut opad = [0x5cu8; BLOCK_SIZE];\n        \n        // XOR key with pads\n        for (i, &k) in key.iter().enumerate().take(BLOCK_SIZE) {\n            ipad[i] ^= k;\n            opad[i] ^= k;\n        }\n        \n        // Inner hash: H(K \u2295 ipad || message)\n        self.sha.start()?;\n        self.sha.update(&ipad)?;\n        self.sha.update(message)?;\n        let inner_hash = self.sha.finalize()?;\n        \n        // Outer hash: H(K \u2295 opad || inner_hash)\n        self.sha.start()?;\n        self.sha.update(&opad)?;\n        self.sha.update(&inner_hash)?;\n        self.sha.finalize()\n    }\n}\n\n#[derive(Debug)]\npub struct EncryptedMessage {\n    pub ciphertext: Vec<u8>,\n    pub iv: [u8; 12],\n    pub tag: [u8; 16],\n}\n\n/// Example usage in main application\npub fn crypto_example() -> Result<(), XilinxError> {\n    let mut crypto = XilinxCryptoEngine::new()?;\n    \n    // Generate a session key\n    let session_key = crypto.generate_session_key()?;\n    \n    // Encrypt some data\n    let plaintext = b\"Hello, secure world!\";\n    let encrypted = crypto.encrypt_message(plaintext, &session_key)?;\n    \n    // Decrypt the data\n    let decrypted = crypto.decrypt_message(&encrypted, &session_key)?;\n    \n    // Verify the roundtrip worked\n    assert_eq!(plaintext.as_slice(), decrypted.as_slice());\n    \n    // Compute a hash\n    let hash = crypto.hash_data(plaintext)?;\n    \n    // Compute HMAC\n    let hmac_key = b\"secret_hmac_key\";\n    let hmac = crypto.hmac(hmac_key, plaintext)?;\n    \n    Ok(())\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Advanced DMA Operations in Rust",
        "line_number": 6154,
        "language": "rust",
        "code": "// src/xilinx/multicore.rs - Multi-core coordination\nuse core::sync::atomic::{AtomicU32, AtomicBool, Ordering};\nuse core::ptr;\n\n/// Shared memory structure for inter-core communication\n#[repr(C, align(64))] // Cache line aligned\npub struct SharedMemory {\n    // Core synchronization\n    pub core0_ready: AtomicBool,\n    pub core1_ready: AtomicBool,\n    \n    // Work distribution\n    pub work_queue_head: AtomicU32,\n    pub work_queue_tail: AtomicU32,\n    pub work_items: [WorkItem; 16],\n    \n    // Results\n    pub results: [CryptoResult; 16],\n    pub result_flags: AtomicU32, // Bitmask of completed work\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct WorkItem {\n    pub operation: Operation,\n    pub input_addr: u32,\n    pub input_len: u32,\n    pub output_addr: u32,\n    pub key_addr: u32,\n    pub work_id: u32,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct CryptoResult {\n    pub work_id: u32,\n    pub status: u32,\n    pub output_len: u32,\n}\n\n#[repr(u32)]\n#[derive(Clone, Copy)]\npub enum Operation {\n    Encrypt = 1,\n    Decrypt = 2,\n    Hash = 3,\n    Sign = 4,\n}\n\n// Shared memory location in OCM\nconst SHARED_MEMORY_ADDR: usize = 0xFFFC0000;\n\nimpl SharedMemory {\n    /// Get reference to shared memory (unsafe - must ensure proper initialization)\n    pub unsafe fn get() -> &'static mut Self {\n        &mut *(SHARED_MEMORY_ADDR as *mut Self)\n    }\n    \n    /// Initialize shared memory (call from core 0 only)\n    pub fn init(&mut self) {\n        self.core0_ready.store(false, Ordering::SeqCst);\n        self.core1_ready.store(false, Ordering::SeqCst);\n        self.work_queue_head.store(0, Ordering::SeqCst);\n        self.work_queue_tail.store(0, Ordering::SeqCst);\n        self.result_flags.store(0, Ordering::SeqCst);\n        \n        // Initialize work items and results\n        for i in 0..16 {\n            self.work_items[i] = WorkItem {\n                operation: Operation::Encrypt,\n                input_addr: 0,\n                input_len: 0,\n                output_addr: 0,\n                key_addr: 0,\n                work_id: i as u32,\n            };\n            \n            self.results[i] = CryptoResult {\n                work_id: i as u32,\n                status: 0,\n                output_len: 0,\n            };\n        }\n    }\n    \n    /// Submit work item (producer)\n    pub fn submit_work(&mut self, work: WorkItem) -> Result<(), MultiCoreError> {\n        let current_tail = self.work_queue_tail.load(Ordering::Acquire);\n        let next_tail = (current_tail + 1) % 16;\n        let head = self.work_queue_head.load(Ordering::Acquire);\n        \n        // Check if queue is full\n        if next_tail == head {\n            return Err(MultiCoreError::QueueFull);\n        }\n        \n        // Store work item\n        self.work_items[current_tail as usize] = work;\n        \n        // Update tail pointer\n        self.work_queue_tail.store(next_tail, Ordering::Release);\n        \n        Ok(())\n    }\n    \n    /// Get next work item (consumer)\n    pub fn get_work(&mut self) -> Option<WorkItem> {\n        let head = self.work_queue_head.load(Ordering::Acquire);\n        let tail = self.work_queue_tail.load(Ordering::Acquire);\n        \n        if head == tail {\n            return None; // Queue empty\n        }\n        \n        let work = self.work_items[head as usize];\n        let next_head = (head + 1) % 16;\n        self.work_queue_head.store(next_head, Ordering::Release);\n        \n        Some(work)\n    }\n    \n    /// Submit result\n    pub fn submit_result(&mut self, result: CryptoResult) {\n        let work_id = result.work_id as usize;\n        if work_id < 16 {\n            self.results[work_id] = result;\n            \n            // Set completion flag\n            let current_flags = self.result_flags.load(Ordering::Acquire);\n            self.result_flags.store(current_flags | (1 << work_id), Ordering::Release);\n        }\n    }\n    \n    /// Check if work is complete\n    pub fn is_work_complete(&self, work_id: u32) -> bool {\n        let flags = self.result_flags.load(Ordering::Acquire);\n        (flags & (1 << work_id)) != 0\n    }\n    \n    /// Get result for completed work\n    pub fn get_result(&self, work_id: u32) -> Option<CryptoResult> {\n        if self.is_work_complete(work_id) && work_id < 16 {\n            Some(self.results[work_id as usize])\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum MultiCoreError {\n    QueueFull,\n    InvalidWorkId,\n    CoreNotReady,\n}\n\n/// Core 0 - Master core that distributes work\npub struct MasterCore {\n    shared_mem: &'static mut SharedMemory,\n    crypto_engine: crate::xilinx::crypto::XilinxCryptoEngine,\n}\n\nimpl MasterCore {\n    pub fn new() -> Result<Self, XilinxError> {\n        let shared_mem = unsafe { SharedMemory::get() };\n        shared_mem.init();\n        \n        let crypto_engine = crate::xilinx::crypto::XilinxCryptoEngine::new()?;\n        \n        Ok(Self {\n            shared_mem,\n            crypto_engine,\n        })\n    }\n    \n    pub fn start(&mut self) -> Result<(), MultiCoreError> {\n        // Signal that core 0 is ready\n        self.shared_mem.core0_ready.store(true, Ordering::SeqCst);\n        \n        // Wait for core 1 to be ready\n        while !self.shared_mem.core1_ready.load(Ordering::SeqCst) {\n            cortex_r::asm::wfi();\n        }\n        \n        Ok(())\n    }\n    \n    pub fn encrypt_parallel(&mut self, data_chunks: &[&[u8]], key: &[u8; 32]) -> Result<Vec<Vec<u8>>, MultiCoreError> {\n        let mut work_ids = Vec::new();\n        \n        // Submit work items\n        for (i, chunk) in data_chunks.iter().enumerate() {\n            let work = WorkItem {\n                operation: Operation::Encrypt,\n                input_addr: chunk.as_ptr() as u32,\n                input_len: chunk.len() as u32,\n                output_addr: 0, // Would need to allocate output buffer\n                key_addr: key.as_ptr() as u32,\n                work_id: i as u32,\n            };\n            \n            self.shared_mem.submit_work(work)?;\n            work_ids.push(i as u32);\n        }\n        \n        // Wait for completion and collect results\n        let mut results = Vec::new();\n        for work_id in work_ids {\n            while !self.shared_mem.is_work_complete(work_id) {\n                cortex_r::asm::wfi();\n            }\n            \n            if let Some(result) = self.shared_mem.get_result(work_id) {\n                // Process result...\n                results.push(Vec::new()); // Placeholder\n            }\n        }\n        \n        Ok(results)\n    }\n}\n\n/// Core 1 - Worker core that processes crypto operations\npub struct WorkerCore {\n    shared_mem: &'static mut SharedMemory,\n    crypto_engine: crate::xilinx::crypto::XilinxCryptoEngine,\n}\n\nimpl WorkerCore {\n    pub fn new() -> Result<Self, XilinxError> {\n        let shared_mem = unsafe { SharedMemory::get() };\n        let crypto_engine = crate::xilinx::crypto::XilinxCryptoEngine::new()?;\n        \n        Ok(Self {\n            shared_mem,\n            crypto_engine,\n        })\n    }\n    \n    pub fn start_worker(&mut self) -> Result<(), MultiCoreError> {\n        // Signal that core 1 is ready\n        self.shared_mem.core1_ready.store(true, Ordering::SeqCst);\n        \n        // Wait for core 0 to be ready\n        while !self.shared_mem.core0_ready.load(Ordering::SeqCst) {\n            cortex_r::asm::wfi();\n        }\n        \n        // Main worker loop\n        loop {\n            if let Some(work) = self.shared_mem.get_work() {\n                let result = self.process_work(work);\n                self.shared_mem.submit_result(result);\n            } else {\n                // No work available, wait for interrupt or yield\n                cortex_r::asm::wfi();\n            }\n        }\n    }\n    \n    fn process_work(&mut self, work: WorkItem) -> CryptoResult {\n        match work.operation {\n            Operation::Encrypt => {\n                // Perform encryption using hardware accelerator\n                // This is a simplified example\n                CryptoResult {\n                    work_id: work.work_id,\n                    status: 0, // Success\n                    output_len: work.input_len,\n                }\n            }\n            Operation::Decrypt => {\n                // Perform decryption\n                CryptoResult {\n                    work_id: work.work_id,\n                    status: 0,\n                    output_len: work.input_len,\n                }\n            }\n            Operation::Hash => {\n                // Perform hashing\n                CryptoResult {\n                    work_id: work.work_id,\n                    status: 0,\n                    output_len: 32, // SHA-256 output size\n                }\n            }\n            Operation::Sign => {\n                // Perform digital signature\n                CryptoResult {\n                    work_id: work.work_id,\n                    status: 0,\n                    output_len: 64, // ECDSA signature size\n                }\n            }\n        }\n    }\n}\n\n### Advanced DMA Operations in Rust\n\nDMA (Direct Memory Access) is crucial for high-performance crypto operations. Here's how to handle DMA safely in Rust:\n",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Peripheral Access Crate (PAC)",
        "line_number": 7122,
        "language": "rust",
        "code": "// Assuming stm32f4xx-pac in dependencies\nuse stm32f4xx_pac as pac;\n\n// Take ownership of peripherals (only once!)\nlet peripherals = pac::Peripherals::take().unwrap();\nlet gpioa = &peripherals.GPIOA;\n\n// Set pin 5 as output\ngpioa.moder.modify(|_, w| w.moder5().output());\n\n// Set pin 5 high\ngpioa.odr.modify(|_, w| w.odr5().set_bit());\n\n// Read pin state\nlet is_high = gpioa.idr.read().idr5().bit_is_set();",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Hardware Abstraction Layer (HAL) for Crypto",
        "line_number": 7144,
        "language": "rust",
        "code": "use stm32f4xx_hal::{pac, prelude::*};\n\n// Example: Using hardware RNG\nlet dp = pac::Peripherals::take().unwrap();\nlet rcc = dp.RCC.constrain();\nlet clocks = rcc.cfgr.sysclk(84.MHz()).freeze();\n\n// Initialize hardware RNG (if your MCU has one)\n// Check your HAL documentation for availability\nlet mut rng = dp.RNG.constrain(&clocks);\n\n// Generate cryptographically secure random bytes\nlet mut key = [0u8; 32];\nrng.fill_bytes(&mut key).expect(\"RNG error\");\n\n// Example: Hardware AES acceleration (MCU-specific)\n// Not all MCUs have crypto accelerators - check your datasheet\nuse stm32_crypto::{aes::Aes, Mode};  // If available for your MCU\n\nlet mut aes = Aes::new(dp.CRYP, &clocks);\naes.set_key(&key);\naes.set_mode(Mode::ECB);\n\nlet mut ciphertext = [0u8; 16];\naes.encrypt_block(&plaintext, &mut ciphertext);",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Embedded-HAL Traits",
        "line_number": 7176,
        "language": "rust",
        "code": "use embedded_hal::digital::v2::OutputPin;\nuse embedded_hal::blocking::delay::DelayMs;\n\nstruct Led<P: OutputPin> {\n    pin: P,\n}\n\nimpl<P: OutputPin> Led<P> {\n    fn new(pin: P) -> Self {\n        Led { pin }\n    }\n    \n    fn blink(&mut self, delay: &mut impl DelayMs<u32>) {\n        self.pin.set_high().ok();\n        delay.delay_ms(100);\n        self.pin.set_low().ok();\n        delay.delay_ms(100);\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Interrupt Handlers for Crypto Operations",
        "line_number": 7200,
        "language": "rust",
        "code": "use stm32f4xx_hal::pac::{interrupt, Interrupt, NVIC};\nuse core::cell::RefCell;\nuse cortex_m::interrupt::Mutex;\nuse heapless::spsc::{Queue, Producer, Consumer};\n\n// Type alias for cleaner code\ntype CryptoProducer = Producer<'static, CryptoRequest, 16>;\ntype CryptoConsumer = Consumer<'static, CryptoRequest, 16>;\n\n// Global queue for crypto requests\nstatic mut QUEUE: Queue<CryptoRequest, 16> = Queue::new();\nstatic mut PRODUCER: Option<CryptoProducer> = None;\nstatic mut CONSUMER: Option<CryptoConsumer> = None;\n\n// DMA completion flag\nstatic DMA_COMPLETE: Mutex<RefCell<bool>> = Mutex::new(RefCell::new(false));\n\n#[derive(Clone, Copy)]\nstruct CryptoRequest {\n    operation: Operation,\n    src_addr: usize,\n    dst_addr: usize,\n    len: usize,\n}\n\n#[derive(Clone, Copy)]\nenum Operation {\n    Encrypt,\n    Decrypt,\n    Hash,\n}\n\n// Initialize the queues (call this in main before enabling interrupts)\nfn init_crypto_queue() {\n    unsafe {\n        let (producer, consumer) = QUEUE.split();\n        PRODUCER = Some(producer);\n        CONSUMER = Some(consumer);\n    }\n}\n\n// Hardware crypto DMA completion interrupt\n#[interrupt]\nfn DMA2_STREAM0() {\n    // Clear interrupt flag\n    unsafe {\n        let dma = &*pac::DMA2::ptr();\n        dma.lifcr.write(|w| w.ctcif0().set_bit());\n    }\n    \n    // Signal completion\n    cortex_m::interrupt::free(|cs| {\n        DMA_COMPLETE.borrow(cs).replace(true);\n    });\n}\n\n// Submit crypto request\nfn encrypt_async(plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), CryptoError> {\n    let request = CryptoRequest {\n        operation: Operation::Encrypt,\n        src_addr: plaintext.as_ptr() as usize,\n        dst_addr: ciphertext.as_mut_ptr() as usize,\n        len: plaintext.len(),\n    };\n    \n    unsafe {\n        if let Some(producer) = &mut PRODUCER {\n            producer.enqueue(request).map_err(|_| CryptoError::QueueFull)?;\n        }\n    }\n    Ok(())\n}\n\n#[derive(Debug)]\nenum CryptoError {\n    QueueFull,\n}",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "Secure Coding Patterns",
        "line_number": 7284,
        "language": "rust",
        "code": "// 1. Secure temporary storage\nuse zeroize::Zeroizing;\n\nfn derive_key(master: &[u8], info: &[u8]) -> [u8; 32] {\n    // Automatically cleared on drop\n    let mut temp = Zeroizing::new([0u8; 64]);\n    \n    // Use temp for intermediate calculations\n    sha256_hmac(master, info, &mut *temp);\n    \n    // Extract final key\n    let mut key = [0u8; 32];\n    key.copy_from_slice(&temp[..32]);\n    key\n    // temp is automatically zeroized here\n}\n\n// 2. Preventing compiler optimizations\nuse core::sync::atomic::{compiler_fence, Ordering};\n\nfn secure_compare(a: &[u8], b: &[u8]) -> bool {\n    if a.len() != b.len() {\n        return false;\n    }\n    \n    let mut diff = 0u8;\n    for (x, y) in a.iter().zip(b.iter()) {\n        diff |= x ^ y;\n        // Prevent early exit optimization\n        compiler_fence(Ordering::SeqCst);\n    }\n    \n    diff == 0\n}\n\n// 3. Stack cleaning for sensitive functions\n#[inline(never)]  // Prevent inlining\nfn process_secret(secret: &[u8]) -> [u8; 32] {\n    let mut workspace = [0u8; 1024];\n    \n    // Do crypto operations...\n    let result = perform_crypto(&secret, &mut workspace);\n    \n    // Clean stack before returning\n    workspace.zeroize();\n    compiler_fence(Ordering::SeqCst);\n    \n    result\n}\n\n// 4. Fault injection resistance\nfn verify_signature(message: &[u8], signature: &[u8]) -> Result<(), Error> {\n    // Double-check critical operations\n    let hash1 = sha256(message);\n    let hash2 = sha256(message);\n    \n    if !constant_time_compare(&hash1, &hash2) {\n        // Fault detected\n        panic!(\"Fault injection detected\");\n    }\n    \n    // Proceed with verification\n    verify_sig(&hash1, signature)\n}\n\n// 5. Timing-safe error handling\nenum TimingSafeResult<T> {\n    Ok(T),\n    Err,\n}\n\nfn decrypt_with_padding(ciphertext: &[u8]) -> TimingSafeResult<Vec<u8>> {\n    let mut plaintext = vec![0u8; ciphertext.len()];\n    let mut error_flag = 0u8;\n    \n    // Always perform full decryption\n    decrypt_block(ciphertext, &mut plaintext);\n    \n    // Check padding without early return\n    let pad_len = plaintext[plaintext.len() - 1] as usize;\n    for i in 0..pad_len {\n        let idx = plaintext.len() - 1 - i;\n        error_flag |= plaintext[idx] ^ (pad_len as u8);\n    }\n    \n    // Return after constant time\n    if error_flag == 0 {\n        plaintext.truncate(plaintext.len() - pad_len);\n        TimingSafeResult::Ok(plaintext)\n    } else {\n        TimingSafeResult::Err\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "DMA (Direct Memory Access)",
        "line_number": 7382,
        "language": "rust",
        "code": "// Example of DMA usage pattern\n// Actual implementation depends on your HAL crate\n\nuse stm32f4xx_hal::dma::{StreamsTuple, Stream0, Transfer, MemoryToPeripheral};\n\n// Configure DMA for memory to peripheral transfer\nlet dma_streams = StreamsTuple::new(dp.DMA2);\nlet mut transfer = Transfer::init(\n    dma_streams.0,                    // Stream 0\n    buffer,                           // Source buffer\n    uart_tx,                          // Destination peripheral\n    None,                            // No double buffer\n    dma_config,                      // Configuration\n);\n\n// Start the transfer\ntransfer.start(|uart| {\n    // Enable UART transmitter\n    uart.enable_tx();\n});\n\n// Wait for completion or use interrupt\nwhile !transfer.is_complete() {\n    // Could yield to other tasks here\n}\n\n// Get resources back after transfer\nlet (_stream, buffer, uart_tx) = transfer.free();",
        "syntax_valid": true,
        "compiles": true,
        "errors": [
          "Skipped: Not Rust code (diagram, comment, or C code)"
        ],
        "warnings": []
      },
      {
        "section": "State Machines for Cryptographic Protocols",
        "line_number": 7417,
        "language": "rust",
        "code": "// TLS-like protocol state machine\n#[derive(Debug)]\nenum TlsState {\n    Initial,\n    ClientHello { random: [u8; 32] },\n    ServerHello { session_id: [u8; 32], cipher_suite: u16 },\n    KeyExchange { public_key: [u8; 32] },\n    Established { keys: SessionKeys },\n    Error(TlsError),\n}\n\n#[derive(Debug)]\nstruct SessionKeys {\n    client_write_key: [u8; 32],\n    server_write_key: [u8; 32],\n    client_write_iv: [u8; 12],\n    server_write_iv: [u8; 12],\n}\n\n#[derive(Debug)]\nenum TlsError {\n    UnexpectedMessage,\n    InvalidCertificate,\n    CryptoError,\n}\n\n// Protocol messages\nenum TlsMessage {\n    ClientHello(ClientHelloMsg),\n    ServerHello(ServerHelloMsg),\n    Certificate(Vec<u8>),\n    Finished([u8; 32]),\n}\n\nstruct ClientHelloMsg {\n    cipher_suites: Vec<u16>,\n}\n\nstruct ServerHelloMsg {\n    session_id: [u8; 32],\n    cipher_suite: u16,\n}\n\nimpl TlsState {\n    fn process(&mut self, message: TlsMessage) -> Result<(), TlsError> {\n        *self = match (self.clone(), message) {\n            (TlsState::Initial, TlsMessage::ClientHello(hello)) => {\n                let random = [0u8; 32];  // Generate random\n                // Send client hello with cipher suites\n                TlsState::ClientHello { random }\n            }\n            (TlsState::ClientHello { .. }, TlsMessage::ServerHello(hello)) => {\n                // Verify server's chosen cipher suite is acceptable\n                TlsState::ServerHello { \n                    session_id: hello.session_id,\n                    cipher_suite: hello.cipher_suite,\n                }\n            }\n            (TlsState::ServerHello { .. }, TlsMessage::Certificate(cert)) => {\n                // Verify certificate and extract public key\n                let public_key = [0u8; 32];  // Extract from cert\n                TlsState::KeyExchange { public_key }\n            }\n            (TlsState::KeyExchange { public_key }, TlsMessage::Finished(verify_data)) => {\n                // Derive session keys from key exchange\n                let keys = SessionKeys {\n                    client_write_key: [0u8; 32],\n                    server_write_key: [0u8; 32],\n                    client_write_iv: [0u8; 12],\n                    server_write_iv: [0u8; 12],\n                };\n                TlsState::Established { keys }\n            }\n            (_, _) => return Err(TlsError::UnexpectedMessage),\n        };\n        Ok(())\n    }\n}\n\n// Add Clone for TlsState (needed for the pattern match)\nimpl Clone for TlsState {\n    fn clone(&self) -> Self {\n        match self {\n            TlsState::Initial => TlsState::Initial,\n            TlsState::ClientHello { random } => TlsState::ClientHello { random: *random },\n            TlsState::ServerHello { session_id, cipher_suite } => {\n                TlsState::ServerHello { \n                    session_id: *session_id, \n                    cipher_suite: *cipher_suite \n                }\n            }\n            TlsState::KeyExchange { public_key } => {\n                TlsState::KeyExchange { public_key: *public_key }\n            }\n            TlsState::Established { keys } => {\n                TlsState::Established { \n                    keys: SessionKeys {\n                        client_write_key: keys.client_write_key,\n                        server_write_key: keys.server_write_key,\n                        client_write_iv: keys.client_write_iv,\n                        server_write_iv: keys.server_write_iv,\n                    }\n                }\n            }\n            TlsState::Error(e) => TlsState::Error(match e {\n                TlsError::UnexpectedMessage => TlsError::UnexpectedMessage,\n                TlsError::InvalidCertificate => TlsError::InvalidCertificate,\n                TlsError::CryptoError => TlsError::CryptoError,\n            }),\n        }\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Builder Pattern for Crypto Configuration",
        "line_number": 7534,
        "language": "rust",
        "code": "use core::marker::PhantomData;\n\n// Type states for builder\nstruct NoKey;\nstruct HasKey;\n\n// Configuration enums\n#[derive(Copy, Clone)]\nenum Algorithm {\n    Aes,\n    ChaCha20,\n}\n\n#[derive(Copy, Clone)]\nenum Mode {\n    ECB,\n    CBC,\n    GCM,\n    Poly1305,\n}\n\n#[derive(Copy, Clone)]\nenum KeySize {\n    Bits128,\n    Bits256,\n}\n\n// Cipher implementations\nenum Cipher {\n    AesGcm(AesGcm<Authenticated>),\n    ChaCha20Poly1305(ChaCha20Poly1305),\n}\n\n// Placeholder cipher types\nstruct AesGcm<STATE> {\n    _state: PhantomData<STATE>,\n}\n\nimpl AesGcm<Authenticated> {\n    fn new(_key: [u8; 32]) -> Self {\n        Self { _state: PhantomData }\n    }\n}\n\nstruct ChaCha20Poly1305;\n\nimpl ChaCha20Poly1305 {\n    fn new(_key: [u8; 32]) -> Self {\n        Self\n    }\n}\n\n// The builder itself\nstruct CipherConfig<K> {\n    algorithm: Algorithm,\n    mode: Mode,\n    key_size: KeySize,\n    key: Option<[u8; 32]>,\n    _key_state: PhantomData<K>,\n}\n\nimpl Default for CipherConfig<NoKey> {\n    fn default() -> Self {\n        Self {\n            algorithm: Algorithm::Aes,\n            mode: Mode::GCM,\n            key_size: KeySize::Bits256,\n            key: None,\n            _key_state: PhantomData,\n        }\n    }\n}\n\nimpl<K> CipherConfig<K> {\n    fn algorithm(mut self, alg: Algorithm) -> Self {\n        self.algorithm = alg;\n        self\n    }\n    \n    fn mode(mut self, mode: Mode) -> Self {\n        self.mode = mode;\n        self\n    }\n}\n\nimpl CipherConfig<NoKey> {\n    fn with_key(mut self, key: [u8; 32]) -> CipherConfig<HasKey> {\n        CipherConfig {\n            algorithm: self.algorithm,\n            mode: self.mode,\n            key_size: self.key_size,\n            key: Some(key),\n            _key_state: PhantomData,\n        }\n    }\n}\n\n// Can only build cipher after key is set\nimpl CipherConfig<HasKey> {\n    fn build(self) -> Result<Cipher, CryptoError> {\n        let key = self.key.unwrap();\n        match (self.algorithm, self.mode) {\n            (Algorithm::Aes, Mode::GCM) => Ok(Cipher::AesGcm(AesGcm::new(key))),\n            (Algorithm::ChaCha20, Mode::Poly1305) => Ok(Cipher::ChaCha20Poly1305(ChaCha20Poly1305::new(key))),\n            _ => Err(CryptoError::UnsupportedConfiguration),\n        }\n    }\n}\n\n// Error type for unsupported configurations\n#[derive(Debug)]\nenum CryptoError {\n    UnsupportedConfiguration,\n}\n\n// Usage - compile-time enforcement\nlet config = CipherConfig::default()\n    .algorithm(Algorithm::Aes)\n    .mode(Mode::GCM);\n    \n// let cipher = config.build();  // Compile error! No key set\n\nlet key = [0u8; 32];  // Your key here\nlet cipher = config\n    .with_key(key)\n    .build()\n    .expect(\"Valid configuration\");  // OK!",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Side-Channel Resistant Patterns",
        "line_number": 7666,
        "language": "rust",
        "code": "// Add to Cargo.toml:\n// subtle = \"2.5\"\n// rand_core = \"0.6\"\n\nuse subtle::{Choice, ConditionallySelectable, ConstantTimeEq};\nuse rand_core::RngCore;\n\n// Constant-time selection without branches\nfn ct_select(condition: Choice, a: u32, b: u32) -> u32 {\n    u32::conditional_select(&a, &b, condition)\n}\n\n// Constant-time comparison\nfn verify_mac(computed: &[u8; 32], expected: &[u8; 32]) -> bool {\n    computed.ct_eq(expected).unwrap_u8() == 1\n}\n\n// Masking sensitive operations\nstruct MaskedValue {\n    value: u32,\n    mask: u32,\n}\n\nimpl MaskedValue {\n    fn new(value: u32, rng: &mut dyn RngCore) -> Self {\n        let mask = rng.next_u32();\n        Self {\n            value: value ^ mask,\n            mask,\n        }\n    }\n    \n    fn unmask(&self) -> u32 {\n        self.value ^ self.mask\n    }\n    \n    // Operate on masked values\n    fn add_masked(&self, other: &Self, rng: &mut dyn RngCore) -> Self {\n        // Arithmetic on masked values\n        let unmasked_sum = self.unmask().wrapping_add(other.unmask());\n        Self::new(unmasked_sum, rng)\n    }\n}\n\n// Example elliptic curve point for power analysis resistance\nstruct Point {\n    x: u32,\n    y: u32,\n}\n\nimpl Point {\n    fn double(&self) -> Self {\n        // Point doubling operation\n        Self { x: self.x, y: self.y }  // Placeholder\n    }\n    \n    fn add(&self, _other: &Self) -> Self {\n        // Point addition operation  \n        Self { x: self.x, y: self.y }  // Placeholder\n    }\n}\n\nimpl ConditionallySelectable for Point {\n    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {\n        Self {\n            x: u32::conditional_select(&a.x, &b.x, choice),\n            y: u32::conditional_select(&a.y, &b.y, choice),\n        }\n    }\n}\n\n// Power analysis resistant scalar multiplication\nfn process_key_bit(bit: bool, accumulator: &mut Point, generator: &Point) {\n    // Always perform both operations\n    let doubled = accumulator.double();\n    let added = accumulator.add(generator);\n    \n    // Select result without branching\n    *accumulator = Point::conditional_select(\n        &doubled,\n        &added,\n        Choice::from(bit as u8),\n    );\n}\n\n// Cache-timing resistant table lookup\nfn sbox_lookup(index: u8) -> u8 {\n    // Example S-box values\n    const SBOX: [u8; 256] = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        // ... rest of S-box values ...\n        0x00; 248  // Placeholder for remaining values\n    ];\n    \n    // Access all entries to avoid cache timing\n    let mut result = 0u8;\n    for (i, &value) in SBOX.iter().enumerate() {\n        let is_target = (i as u8).ct_eq(&index);\n        // ConditionallySelectable trait from subtle crate\n        // Assigns value to result only if is_target is true (constant time)\n        ConditionallySelectable::conditional_assign(&mut result, &value, is_target);\n    }\n    result\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "RTIC for Real-Time Systems",
        "line_number": 7775,
        "language": "rust",
        "code": "#[rtic::app(device = stm32f4xx_hal::pac, peripherals = true)]\nmod app {\n    use super::*;\n    \n    #[shared]\n    struct Shared {\n        counter: u32,\n    }\n    \n    #[local]\n    struct Local {\n        led: Led,\n    }\n    \n    #[init]\n    fn init(ctx: init::Context) -> (Shared, Local, init::Monotonics) {\n        // Initialize hardware\n        let led = configure_led(ctx.device);\n        \n        (\n            Shared { counter: 0 },\n            Local { led },\n            init::Monotonics(),\n        )\n    }\n    \n    #[task(binds = TIM2, shared = [counter], local = [led])]\n    fn timer_interrupt(ctx: timer_interrupt::Context) {\n        ctx.local.led.toggle();\n        ctx.shared.counter.lock(|c| *c += 1);\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Type State Pattern for Secure APIs",
        "line_number": 7814,
        "language": "rust",
        "code": "use core::marker::PhantomData;\n\n// Type states for cipher operation\nstruct Uninitialized;\nstruct Initialized;\nstruct Authenticated;\n\n// Mock AES context for example\nstruct AesContext {\n    key: Option<[u8; 32]>,\n    nonce: Option<[u8; 12]>,\n    aad_processed: bool,\n}\n\nimpl AesContext {\n    fn new() -> Self {\n        Self {\n            key: None,\n            nonce: None,\n            aad_processed: false,\n        }\n    }\n    \n    fn set_key(&mut self, key: &[u8]) {\n        if key.len() == 32 {\n            self.key = Some(key.try_into().unwrap());\n        }\n    }\n    \n    fn set_nonce(&mut self, nonce: &[u8]) {\n        if nonce.len() == 12 {\n            self.nonce = Some(nonce.try_into().unwrap());\n        }\n    }\n    \n    fn process_aad(&mut self, _aad: &[u8]) {\n        self.aad_processed = true;\n    }\n    \n    fn encrypt(&self, plaintext: &[u8], ciphertext: &mut [u8]) {\n        // Mock encryption - copy plaintext\n        ciphertext.copy_from_slice(plaintext);\n    }\n    \n    fn decrypt(&self, ciphertext: &[u8]) -> Vec<u8> {\n        // Mock decryption\n        ciphertext.to_vec()\n    }\n    \n    fn compute_tag(&self) -> [u8; 16] {\n        // Mock tag computation\n        [0u8; 16]\n    }\n}\n\n#[derive(Debug)]\nenum AuthError {\n    InvalidTag,\n}\n\nstruct AesGcm<STATE> {\n    ctx: AesContext,\n    _state: PhantomData<STATE>,\n}\n\n// Can only create in uninitialized state\nimpl AesGcm<Uninitialized> {\n    fn new() -> Self {\n        Self {\n            ctx: AesContext::new(),\n            _state: PhantomData,\n        }\n    }\n    \n    // Must initialize with key before use\n    fn init(mut self, key: &[u8; 32]) -> AesGcm<Initialized> {\n        self.ctx.set_key(key);\n        AesGcm {\n            ctx: self.ctx,\n            _state: PhantomData,\n        }\n    }\n}\n\n// Can only set nonce and AAD when initialized\nimpl AesGcm<Initialized> {\n    fn set_nonce(mut self, nonce: &[u8; 12]) -> Self {\n        self.ctx.set_nonce(nonce);\n        self\n    }\n    \n    fn authenticate(mut self, aad: &[u8]) -> AesGcm<Authenticated> {\n        self.ctx.process_aad(aad);\n        AesGcm {\n            ctx: self.ctx,\n            _state: PhantomData,\n        }\n    }\n}\n\n// Can only encrypt/decrypt after authentication\nimpl AesGcm<Authenticated> {\n    fn encrypt(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> [u8; 16] {\n        self.ctx.encrypt(plaintext, ciphertext);\n        self.ctx.compute_tag()\n    }\n    \n    fn decrypt(&mut self, ciphertext: &[u8], tag: &[u8; 16]) -> Result<Vec<u8>, AuthError> {\n        let plaintext = self.ctx.decrypt(ciphertext);\n        let computed_tag = self.ctx.compute_tag();\n        \n        if constant_time_compare(&computed_tag, tag) {\n            Ok(plaintext)\n        } else {\n            Err(AuthError::InvalidTag)\n        }\n    }\n}\n\n// Usage - compile-time enforcement of correct API usage\nfn example_usage() {\n    let cipher = AesGcm::<Uninitialized>::new();\n    // cipher.encrypt(...);  // Compile error! Not initialized\n\n    let key = [0u8; 32];\n    let cipher = cipher.init(&key);\n    // cipher.encrypt(...);  // Compile error! Not authenticated\n\n    let nonce = [0u8; 12];\n    let aad = b\"additional authenticated data\";\n    let mut cipher = cipher\n        .set_nonce(&nonce)\n        .authenticate(aad);\n        \n    let plaintext = b\"secret message\";\n    let mut ciphertext = [0u8; 14];\n    let tag = cipher.encrypt(plaintext, &mut ciphertext);  // OK!\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "RTT (Real-Time Transfer) for Printf Debugging",
        "line_number": 7972,
        "language": "rust",
        "code": "use rtt_target::{rprintln, rtt_init_print};\n\n#[entry]\nfn main() -> ! {\n    rtt_init_print!();\n    \n    rprintln!(\"Starting application...\");\n    \n    let mut counter = 0;\n    loop {\n        rprintln!(\"Counter: {}\", counter);\n        counter += 1;\n        delay.delay_ms(1000u32);\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Panic Information",
        "line_number": 7992,
        "language": "rust",
        "code": "use panic_probe as _;  // Prints panic info via probe-rs\nuse cortex_m_rt::exception;\n\n#[exception]\nunsafe fn HardFault(ef: &cortex_m_rt::ExceptionFrame) -> ! {\n    panic!(\"HardFault at {:#?}\", ef);\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Cargo.toml",
        "line_number": 8004,
        "language": "toml",
        "code": "# Cargo.toml\n[profile.release]\nopt-level = \"z\"     # Optimize for size\nlto = true          # Link-time optimization\ncodegen-units = 1   # Better optimization\nstrip = true        # Strip symbols\npanic = \"abort\"     # No unwinding code",
        "syntax_valid": true,
        "compiles": true,
        "errors": [],
        "warnings": []
      },
      {
        "section": "Unit Testing with Test Vectors",
        "line_number": 8028,
        "language": "rust",
        "code": "// In your Cargo.toml for tests:\n// [dev-dependencies]\n// hex-literal = \"0.4\"\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hex_literal::hex;\n    \n    #[test]\n    fn test_aes_128_ecb() {\n        // NIST test vectors\n        let key = hex!(\"2b7e151628aed2a6abf7158809cf4f3c\");\n        let plaintext = hex!(\"6bc1bee22e409f96e93d7e117393172a\");\n        let expected = hex!(\"3ad77bb40d7a3660a89ecaf32466ef97\");\n        \n        let cipher = Aes128::new(key);\n        let mut output = [0u8; 16];\n        cipher.encrypt_block(&plaintext, &mut output);\n        \n        assert_eq!(output, expected);\n    }\n    \n    #[test]\n    fn test_constant_time_compare() {\n        let a = [0x42u8; 32];\n        let b = [0x42u8; 32];\n        let c = [0x41u8; 32];\n        \n        assert!(constant_time_compare(&a, &b));\n        assert!(!constant_time_compare(&a, &c));\n        \n        // Ensure it works for all positions\n        for i in 0..32 {\n            let mut d = a;\n            d[i] ^= 1;\n            assert!(!constant_time_compare(&a, &d));\n        }\n    }\n}\n\n// Integration tests in tests/ directory\n#[test]\nfn test_full_protocol() {\n    // Mock RNG for deterministic tests\n    struct TestRng {\n        state: u64,\n    }\n    \n    impl TestRng {\n        fn from_seed(seed: [u8; 32]) -> Self {\n            Self { state: u64::from_le_bytes(seed[0..8].try_into().unwrap()) }\n        }\n        \n        fn next_u64(&mut self) -> u64 {\n            // Simple LCG for testing only\n            self.state = self.state.wrapping_mul(6364136223846793005)\n                                   .wrapping_add(1442695040888963407);\n            self.state\n        }\n    }\n    \n    let mut rng = TestRng::from_seed([0x42; 32]);\n    \n    // Your protocol tests here\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Property-Based Testing",
        "line_number": 8099,
        "language": "rust",
        "code": "use proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn test_encrypt_decrypt_roundtrip(\n        key in any::<[u8; 32]>(),\n        nonce in any::<[u8; 12]>(),\n        plaintext in prop::collection::vec(any::<u8>(), 0..1024)\n    ) {\n        let cipher = ChaCha20::new(key, nonce);\n        let ciphertext = cipher.encrypt(&plaintext);\n        \n        let cipher = ChaCha20::new(key, nonce);\n        let decrypted = cipher.decrypt(&ciphertext);\n        \n        prop_assert_eq!(plaintext, decrypted);\n    }\n    \n    #[test]\n    fn test_mac_deterministic(\n        key in any::<[u8; 32]>(),\n        message in prop::collection::vec(any::<u8>(), 0..1024)\n    ) {\n        let mac1 = compute_hmac(&key, &message);\n        let mac2 = compute_hmac(&key, &message);\n        \n        prop_assert_eq!(mac1, mac2);\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Hardware-in-the-Loop Testing",
        "line_number": 8133,
        "language": "rust",
        "code": "#[cfg(target_arch = \"arm\")]\n#[test]\nfn test_hardware_rng_entropy() {\n    let mut rng = hardware_rng();\n    let mut counts = [0u32; 256];\n    \n    // Collect samples\n    for _ in 0..1_000_000 {\n        let byte = rng.next_u8();\n        counts[byte as usize] += 1;\n    }\n    \n    // Chi-square test for uniformity\n    let expected = 1_000_000.0 / 256.0;\n    let mut chi_square = 0.0;\n    \n    for count in &counts {\n        let diff = *count as f64 - expected;\n        chi_square += (diff * diff) / expected;\n    }\n    \n    // 99% confidence interval for 255 degrees of freedom\n    assert!(chi_square < 310.0, \"RNG output not uniform\");\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Fuzzing Crypto Implementations",
        "line_number": 8162,
        "language": "rust",
        "code": "#![no_main]\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target!(|data: &[u8]| {\n    if data.len() < 32 {\n        return;\n    }\n    \n    // Split input\n    let (key, rest) = data.split_at(32);\n    let key: [u8; 32] = key.try_into().unwrap();\n    \n    // Try to decrypt with various lengths\n    for chunk in rest.chunks(16) {\n        let _ = decrypt_block(&key, chunk);\n    }\n    \n    // Should not panic or cause UB\n});",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Real-World Example: Secure Communication Module",
        "line_number": 8188,
        "language": "rust",
        "code": "#![no_std]\n#![no_main]\n\nuse panic_halt as _;\nuse cortex_m_rt::entry;\nuse stm32f4xx_hal::{pac, prelude::*};\nuse core::convert::TryInto;\nuse core::sync::atomic::{compiler_fence, Ordering};\nuse core::ptr::{read_volatile, write_volatile};\n\n// Re-export PAC for use in other modules\nuse stm32f4xx_hal::pac as stm32;\n\n/// Constant-time comparison to prevent timing attacks\n#[inline(never)]\nfn constant_time_compare(a: &[u8], b: &[u8]) -> bool {\n    if a.len() != b.len() {\n        return false;\n    }\n    \n    let mut result = 0u8;\n    for (x, y) in a.iter().zip(b.iter()) {\n        result |= x ^ y;\n    }\n    result == 0\n}\n\n/// Secure key storage with zeroization on drop\npub struct SecureKey<const N: usize> {\n    data: [u8; N],\n}\n\nimpl<const N: usize> SecureKey<N> {\n    pub fn new(key: [u8; N]) -> Self {\n        Self { data: key }\n    }\n    \n    pub fn as_bytes(&self) -> &[u8] {\n        &self.data\n    }\n}\n\nimpl<const N: usize> Drop for SecureKey<N> {\n    fn drop(&mut self) {\n        // Zeroize key material\n        use core::sync::atomic::{compiler_fence, Ordering};\n        \n        for byte in self.data.iter_mut() {\n            unsafe { core::ptr::write_volatile(byte, 0) };\n        }\n        \n        // Prevent compiler optimizations\n        compiler_fence(Ordering::SeqCst);\n    }\n}\n\n/// AES-128 block cipher using hardware acceleration\npub struct Aes128 {\n    key: SecureKey<16>,\n    // In real implementation, this would interface with crypto hardware\n}\n\nimpl Aes128 {\n    pub fn new(key: [u8; 16]) -> Self {\n        Self {\n            key: SecureKey::new(key),\n        }\n    }\n    \n    /// Encrypt single block using hardware AES\n    pub fn encrypt_block(&self, input: &[u8; 16], output: &mut [u8; 16]) {\n        // Example using STM32 crypto accelerator\n        unsafe {\n            let cryp = &*pac::CRYP::ptr();\n            \n            // Configure for AES-128 ECB encryption\n            cryp.cr.modify(|_, w| {\n                w.algomode().bits(0b000)  // AES ECB\n                 .datatype().bits(0b00)    // 32-bit data\n                 .keysize().bits(0b00)     // 128-bit key\n            });\n            \n            // Load key (constant-time)\n            let key_words: &[u32; 4] = core::mem::transmute(self.key.as_bytes());\n            cryp.k0lr.write(|w| w.bits(key_words[0]));\n            cryp.k0rr.write(|w| w.bits(key_words[1]));\n            cryp.k1lr.write(|w| w.bits(key_words[2]));\n            cryp.k1rr.write(|w| w.bits(key_words[3]));\n            \n            // Enable crypto processor\n            cryp.cr.modify(|_, w| w.crypen().set_bit());\n            \n            // Process data\n            let input_words: &[u32; 4] = core::mem::transmute(input);\n            for &word in input_words {\n                while cryp.sr.read().ifnf().bit_is_clear() {}\n                cryp.din.write(|w| w.bits(word));\n            }\n            \n            // Read output\n            let output_words: &mut [u32; 4] = core::mem::transmute(output);\n            for word in output_words {\n                while cryp.sr.read().ofne().bit_is_clear() {}\n                *word = cryp.dout.read().bits();\n            }\n            \n            // Disable crypto processor\n            cryp.cr.modify(|_, w| w.crypen().clear_bit());\n        }\n    }\n}\n\n/// ChaCha20 stream cipher in software\npub struct ChaCha20 {\n    key: SecureKey<32>,\n    nonce: [u8; 12],\n    counter: u32,\n}\n\nimpl ChaCha20 {\n    const CONSTANTS: [u32; 4] = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574];\n    \n    pub fn new(key: [u8; 32], nonce: [u8; 12]) -> Self {\n        Self {\n            key: SecureKey::new(key),\n            nonce,\n            counter: 0,\n        }\n    }\n    \n    /// Generate keystream block\n    fn block(&mut self) -> [u8; 64] {\n        let mut state = [0u32; 16];\n        \n        // Initialize state\n        state[0..4].copy_from_slice(&Self::CONSTANTS);\n        \n        // Add key\n        let key_words: &[u32; 8] = unsafe { \n            core::mem::transmute(self.key.as_bytes()) \n        };\n        state[4..12].copy_from_slice(key_words);\n        \n        // Add counter and nonce\n        state[12] = self.counter;\n        let nonce_words: &[u32; 3] = unsafe { \n            core::mem::transmute(&self.nonce) \n        };\n        state[13..16].copy_from_slice(nonce_words);\n        \n        // ChaCha20 rounds (simplified)\n        let mut working_state = state;\n        for _ in 0..10 {\n            // Quarter round operations\n            Self::quarter_round(&mut working_state, 0, 4, 8, 12);\n            Self::quarter_round(&mut working_state, 1, 5, 9, 13);\n            Self::quarter_round(&mut working_state, 2, 6, 10, 14);\n            Self::quarter_round(&mut working_state, 3, 7, 11, 15);\n            \n            Self::quarter_round(&mut working_state, 0, 5, 10, 15);\n            Self::quarter_round(&mut working_state, 1, 6, 11, 12);\n            Self::quarter_round(&mut working_state, 2, 7, 8, 13);\n            Self::quarter_round(&mut working_state, 3, 4, 9, 14);\n        }\n        \n        // Add initial state\n        for i in 0..16 {\n            working_state[i] = working_state[i].wrapping_add(state[i]);\n        }\n        \n        self.counter += 1;\n        \n        // Convert to bytes\n        unsafe { core::mem::transmute(working_state) }\n    }\n    \n    #[inline(always)]\n    fn quarter_round(state: &mut [u32; 16], a: usize, b: usize, c: usize, d: usize) {\n        state[a] = state[a].wrapping_add(state[b]);\n        state[d] ^= state[a];\n        state[d] = state[d].rotate_left(16);\n        \n        state[c] = state[c].wrapping_add(state[d]);\n        state[b] ^= state[c];\n        state[b] = state[b].rotate_left(12);\n        \n        state[a] = state[a].wrapping_add(state[b]);\n        state[d] ^= state[a];\n        state[d] = state[d].rotate_left(8);\n        \n        state[c] = state[c].wrapping_add(state[d]);\n        state[b] ^= state[c];\n        state[b] = state[b].rotate_left(7);\n    }\n}\n\n/// True Random Number Generator using hardware\npub struct Trng {\n    rng: pac::RNG,\n}\n\nimpl Trng {\n    pub fn new(rng: pac::RNG) -> Self {\n        // Enable RNG clock and peripheral\n        unsafe {\n            let rcc = &*pac::RCC::ptr();\n            rcc.ahb2enr.modify(|_, w| w.rngen().set_bit());\n            \n            rng.cr.modify(|_, w| w.rngen().set_bit());\n        }\n        \n        Self { rng }\n    }\n    \n    /// Get random bytes with constant-time retry\n    pub fn fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), RngError> {\n        for chunk in dest.chunks_mut(4) {\n            let random = self.next_u32()?;\n            let bytes = random.to_ne_bytes();\n            chunk.copy_from_slice(&bytes[..chunk.len()]);\n        }\n        Ok(())\n    }\n    \n    fn next_u32(&mut self) -> Result<u32, RngError> {\n        // Constant-time retry loop\n        for _ in 0..100 {\n            let sr = self.rng.sr.read();\n            \n            if sr.cecs().bit_is_set() || sr.secs().bit_is_set() {\n                // Clear error flags\n                self.rng.sr.modify(|_, w| {\n                    w.cecs().clear_bit()\n                     .secs().clear_bit()\n                });\n                continue;\n            }\n            \n            if sr.drdy().bit_is_set() {\n                return Ok(self.rng.dr.read().bits());\n            }\n        }\n        \n        Err(RngError::Timeout)\n    }\n}\n\n#[derive(Debug)]\nenum RngError {\n    Timeout,\n}\n\n/// Message Authentication Code\npub struct Hmac {\n    key: SecureKey<32>,\n}\n\nimpl Hmac {\n    pub fn new(key: [u8; 32]) -> Self {\n        Self {\n            key: SecureKey::new(key),\n        }\n    }\n    \n    /// Compute HMAC-SHA256 (simplified)\n    pub fn compute(&self, message: &[u8]) -> [u8; 32] {\n        // In practice, use hardware SHA accelerator\n        let mut hasher = Sha256::new();\n        \n        // Inner padding\n        let mut ipad = [0x36u8; 64];\n        for (i, &k) in self.key.as_bytes().iter().enumerate() {\n            ipad[i] ^= k;\n        }\n        \n        hasher.update(&ipad);\n        hasher.update(message);\n        let inner_hash = hasher.finalize();\n        \n        // Outer padding\n        let mut opad = [0x5cu8; 64];\n        for (i, &k) in self.key.as_bytes().iter().enumerate() {\n            opad[i] ^= k;\n        }\n        \n        let mut hasher = Sha256::new();\n        hasher.update(&opad);\n        hasher.update(&inner_hash);\n        hasher.finalize()\n    }\n}\n\n/// Simplified SHA-256 (would use hardware in practice)\nstruct Sha256 {\n    // Implementation details...\n}\n\nimpl Sha256 {\n    fn new() -> Self { \n        // Initialize\n        Self {}\n    }\n    \n    fn update(&mut self, _data: &[u8]) {\n        // Update hash state\n    }\n    \n    fn finalize(self) -> [u8; 32] {\n        // Return final hash\n        [0; 32]\n    }\n}\n\n#[entry]\nfn main() -> ! {\n    // Take peripherals\n    let dp = pac::Peripherals::take().unwrap();\n    let cp = cortex_m::Peripherals::take().unwrap();\n    \n    // Configure clocks\n    let rcc = dp.RCC.constrain();\n    let clocks = rcc.cfgr.sysclk(84.MHz()).freeze();\n    \n    // Initialize TRNG (if available on your MCU)\n    let mut rng = Trng::new(dp.RNG);\n    \n    // Generate session key\n    let mut session_key = [0u8; 32];\n    match rng.fill_bytes(&mut session_key) {\n        Ok(()) => {\n            // Key generated successfully\n        }\n        Err(_) => {\n            // Handle RNG error - halt for security\n            panic!(\"RNG initialization failed\");\n        }\n    }\n    \n    // Initialize cipher\n    let mut cipher = ChaCha20::new(session_key, [0u8; 12]);\n    \n    // Example: Secure boot verification\n    let stored_hash = [0x42u8; 32];  // Would come from secure storage\n    let computed_hash = [0x42u8; 32];  // Would be computed from firmware\n    \n    if constant_time_compare(&stored_hash, &computed_hash) {\n        // Boot verified - continue\n        // In practice, would jump to verified firmware\n    } else {\n        // Security violation - halt system\n        panic!(\"Secure boot verification failed\");\n    }\n    \n    // Main loop\n    loop {\n        // Wait for interrupts\n        cortex_m::asm::wfi();\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Create simple programs to understand ownership",
        "line_number": 8615,
        "language": "rust",
        "code": "// Rust equivalent - practice this pattern\nfn xor_buffers(dst: &mut [u8], src1: &[u8], src2: &[u8]) {\n    assert_eq!(dst.len(), src1.len());\n    assert_eq!(dst.len(), src2.len());\n    \n    for ((d, s1), s2) in dst.iter_mut().zip(src1.iter()).zip(src2.iter()) {\n        *d = s1 ^ s2;\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Week 2: Ownership and Memory Management",
        "line_number": 8635,
        "language": "rust",
        "code": "// Practice: Secure key management\nstruct SecureKey {\n    data: [u8; 32],\n}\n\nimpl Drop for SecureKey {\n    fn drop(&mut self) {\n        // Zeroize on drop - automatic cleanup!\n        for byte in self.data.iter_mut() {\n            unsafe { core::ptr::write_volatile(byte, 0) };\n        }\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Week 3: No-std Programming",
        "line_number": 8656,
        "language": "rust",
        "code": "// Create your first no-std project\n#![no_std]\n#![no_main]\n\nuse panic_halt as _;\nuse cortex_r::asm;\n\n#[no_mangle]\npub extern \"C\" fn main() -> ! {\n    // Your code here\n    loop {\n        asm::wfi();\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Week 4: Hardware Abstraction",
        "line_number": 8685,
        "language": "rust",
        "code": "// Example: Safe register access\nuse core::ptr;\n\nconst GPIO_BASE: *mut u32 = 0x4000_0000 as *mut u32;\n\nfn set_gpio_pin(pin: u8) {\n    unsafe {\n        let current = ptr::read_volatile(GPIO_BASE);\n        ptr::write_volatile(GPIO_BASE, current | (1 << pin));\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Week 5-6: Basic Crypto Algorithms",
        "line_number": 8706,
        "language": "rust",
        "code": "// Implement ChaCha20 quarter round\nfn quarter_round(state: &mut [u32; 16], a: usize, b: usize, c: usize, d: usize) {\n    state[a] = state[a].wrapping_add(state[b]);\n    state[d] ^= state[a];\n    state[d] = state[d].rotate_left(16);\n    \n    state[c] = state[c].wrapping_add(state[d]);\n    state[b] ^= state[c];\n    state[b] = state[b].rotate_left(12);\n    \n    state[a] = state[a].wrapping_add(state[b]);\n    state[d] ^= state[a];\n    state[d] = state[d].rotate_left(8);\n    \n    state[c] = state[c].wrapping_add(state[d]);\n    state[b] ^= state[c];\n    state[b] = state[b].rotate_left(7);\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Week 7-8: Advanced Crypto Patterns",
        "line_number": 8733,
        "language": "rust",
        "code": "// Constant-time operations\nuse subtle::ConstantTimeEq;\n\nfn verify_mac(computed: &[u8], provided: &[u8]) -> bool {\n    computed.ct_eq(provided).into()\n}\n\n// Type-safe protocol states\nstruct TlsHandshake<S> {\n    state: S,\n    // ... other fields\n}\n\nstruct ClientHello;\nstruct ServerHello;\nstruct Finished;\n\nimpl TlsHandshake<ClientHello> {\n    fn process_server_hello(self) -> TlsHandshake<ServerHello> {\n        // State transition enforced by type system\n        TlsHandshake { state: ServerHello }\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Week 9: Xilinx Hardware Integration",
        "line_number": 8764,
        "language": "rust",
        "code": "// Example: Using Xilinx crypto accelerator via FFI\nextern \"C\" {\n    fn XSecure_AesInitialize(instance_ptr: *mut XSecure_Aes) -> i32;\n    fn XSecure_AesEncrypt(instance_ptr: *mut XSecure_Aes, \n                         src: *const u8, dst: *mut u8, len: u32) -> i32;\n}\n\npub struct XilinxAes {\n    instance: XSecure_Aes,\n}\n\nimpl XilinxAes {\n    pub fn new() -> Result<Self, CryptoError> {\n        let mut instance = unsafe { core::mem::zeroed() };\n        let result = unsafe { XSecure_AesInitialize(&mut instance) };\n        \n        if result == 0 {\n            Ok(Self { instance })\n        } else {\n            Err(CryptoError::HardwareInitFailed)\n        }\n    }\n    \n    pub fn encrypt(&mut self, src: &[u8], dst: &mut [u8]) -> Result<(), CryptoError> {\n        assert_eq!(src.len(), dst.len());\n        \n        let result = unsafe {\n            XSecure_AesEncrypt(&mut self.instance, \n                              src.as_ptr(), dst.as_mut_ptr(), src.len() as u32)\n        };\n        \n        if result == 0 {\n            Ok(())\n        } else {\n            Err(CryptoError::EncryptionFailed)\n        }\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Testing Strategy",
        "line_number": 8817,
        "language": "rust",
        "code": "#[cfg(test)]\nmod tests {\n    use super::*;\n    use hex_literal::hex;\n    \n    #[test]\n    fn test_aes_known_vectors() {\n        let key = hex!(\"2b7e151628aed2a6abf7158809cf4f3c\");\n        let plaintext = hex!(\"6bc1bee22e409f96e93d7e117393172a\");\n        let expected = hex!(\"3ad77bb40d7a3660a89ecaf32466ef97\");\n        \n        let cipher = Aes128::new(&key);\n        let mut output = [0u8; 16];\n        cipher.encrypt_block(&plaintext, &mut output);\n        \n        assert_eq!(output, expected);\n    }\n    \n    #[test]\n    fn test_constant_time_compare() {\n        let a = [0x42u8; 32];\n        let b = [0x42u8; 32];\n        let c = [0x41u8; 32];\n        \n        assert!(constant_time_eq(&a, &b));\n        assert!(!constant_time_eq(&a, &c));\n    }\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Debugging and Optimization",
        "line_number": 8849,
        "language": "rust",
        "code": "// RTT for debugging\nuse rtt_target::{rprintln, rtt_init_print};\n\n#[entry]\nfn main() -> ! {\n    rtt_init_print!();\n    rprintln!(\"Starting crypto application...\");\n    \n    // Your code with debug output\n    rprintln!(\"Key loaded: {:?}\", key_id);\n}\n\n// Size optimization\n#[inline(never)]  // Prevent inlining for size\nfn large_function() { /* ... */ }\n\n#[inline(always)] // Force inlining for performance\nfn small_hot_function() { /* ... */ }",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Pitfall 1: Fighting the Borrow Checker",
        "line_number": 8908,
        "language": "rust",
        "code": "// Don't do this (fighting the borrow checker)\nlet mut data = vec![1, 2, 3];\nlet first = &data[0];\ndata.push(4);  // Error: cannot borrow as mutable\nprintln!(\"{}\", first);\n\n// Do this instead (work with the borrow checker)\nlet mut data = vec![1, 2, 3];\nlet first = data[0];  // Copy the value\ndata.push(4);  // OK\nprintln!(\"{}\", first);",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Pitfall 2: Overusing `unsafe`",
        "line_number": 8923,
        "language": "rust",
        "code": "// Don't do this (unnecessary unsafe)\nunsafe fn add_numbers(a: i32, b: i32) -> i32 {\n    a + b  // No unsafe operations here!\n}\n\n// Do this instead\nfn add_numbers(a: i32, b: i32) -> i32 {\n    a + b  // Safe by default\n}\n\n// Only use unsafe when actually needed\nunsafe fn read_hardware_register() -> u32 {\n    core::ptr::read_volatile(0x4000_0000 as *const u32)\n}",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      },
      {
        "section": "Pitfall 3: Ignoring Error Handling",
        "line_number": 8941,
        "language": "rust",
        "code": "// Don't do this (ignoring errors)\nlet result = risky_operation().unwrap();  // Will panic on error\n\n// Do this instead (handle errors properly)\nlet result = match risky_operation() {\n    Ok(value) => value,\n    Err(error) => {\n        // Handle error appropriately\n        return Err(error.into());\n    }\n};\n\n// Or use the ? operator\nlet result = risky_operation()?;",
        "syntax_valid": false,
        "compiles": false,
        "errors": [
          "error: Unrecognized option: 'parse-only'"
        ],
        "warnings": []
      }
    ]
  },
  "cross_reference_validation": {
    "total_anchors": 222,
    "total_links": 14,
    "valid_links": 14,
    "broken_links": 0,
    "orphaned_anchors": 135,
    "success_rate": 1.0,
    "report_path": "validation_output/cross_reference_report.json",
    "link_statistics": {
      "total_links": 14,
      "internal_links": 14,
      "cross_references": 0,
      "navigation_links": 0,
      "direct_links": 0,
      "unique_targets": 14,
      "sections_with_links": 1
    },
    "broken_link_details": []
  },
  "redundancy_analysis": {
    "total_segments": 327,
    "exact_duplicates": 1,
    "near_duplicates": 13,
    "similar_content": 25,
    "conceptual_overlaps": 3,
    "redundancy_rate": 4.281345565749235,
    "report_path": "validation_output/redundancy_report.json",
    "statistics": {
      "total_segments": 327,
      "exact_duplicates": 1,
      "near_duplicates": 13,
      "similar_content": 25,
      "conceptual_overlaps": 3,
      "total_redundancy_issues": 42,
      "list_segments": 35,
      "paragraph_segments": 167,
      "table_segments": 5,
      "code_rust_segments": 93,
      "code_bash_segments": 4,
      "code_toml_segments": 5,
      "code_segments": 8,
      "code_c_segments": 10
    }
  },
  "overall_score": 65.00655307994758,
  "recommendations": [
    "\ud83d\udd27 Fix 70 failing code examples",
    "\u26a0\ufe0f  Address 70 critical syntax errors immediately",
    "\ud83c\udff7\ufe0f  Review 135 unused anchors - consider removal or linking",
    "\ud83d\udd04 Remove 1 exact duplicate sections",
    "\ud83d\udcca Run validation again after fixes to track improvement"
  ]
}