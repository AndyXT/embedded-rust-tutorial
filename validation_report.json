{
  "summary": {
    "total_code_examples": 64,
    "total_cross_references": 68,
    "total_content_blocks": 269,
    "compilation_success_rate": 0.0,
    "broken_links_count": 3,
    "duplicate_content_pairs": 1,
    "errors": [
      "Found 3 broken cross-references",
      "Found 58 code examples that don't compile"
    ],
    "warnings": [
      "Found 1 pairs of duplicate/similar content"
    ]
  },
  "code_examples": [
    {
      "language": "rust",
      "code": "// C style error handling\n// int divide(int a, int b, int* result) {\n//     if (b == 0) return -1;\n//     *result = a / b;\n//     return 0;\n// }\n\n// Rust equivalent\nfn divide(a: i32, b: i32) -> Result<i32, &'static str> {\n    if b == 0 {\n        Err(\"Division by zero\")\n    } else {\n        Ok(a / b)\n    }\n}\n\n// Usage with ? operator for error propagation\nfn calculate() -> Result<i32, &'static str> {\n    let result = divide(10, 2)?;  // Automatically propagates error\n    Ok(result * 2)\n}",
      "line_number": 194,
      "section": "Result Type Usage",
      "context": "#### Result Type Usage\n\n```rust\n// C style error handling\n// int divide(int a, int b, int* result) {"
    },
    {
      "language": "rust",
      "code": "use zeroize::{Zeroize, ZeroizeOnDrop};\n\n#[derive(ZeroizeOnDrop)]\nstruct SecureKey<const N: usize> {\n    key: [u8; N],\n}\n\nimpl<const N: usize> SecureKey<N> {\n    fn new(key_material: [u8; N]) -> Self {\n        Self { key: key_material }\n    }\n    \n    fn as_bytes(&self) -> &[u8; N] {\n        &self.key\n    }\n}\n\n// Automatically zeroized when dropped\nlet key = SecureKey::<32>::new(key_data);\n// Use key...\n// key is automatically zeroized here when it goes out of scope",
      "line_number": 231,
      "section": "Secure Key Management Example",
      "context": "#### Secure Key Management Example\n\n```rust\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n"
    },
    {
      "language": "rust",
      "code": "#![no_std]\n#![no_main]\n\nuse panic_halt as _;\nuse cortex_m_rt::entry;\nuse cortex_m::interrupt;\nuse heapless::Vec;\n\n// Global state with proper synchronization\nstatic mut CRYPTO_BUFFER: [u8; 1024] = [0; 1024];\nstatic mut CRYPTO_STATE: Option<CryptoEngine> = None;\n\n#[entry]\nfn main() -> ! {\n    // Initialize hardware\n    let peripherals = init_hardware();\n    \n    // Initialize crypto engine\n    let crypto_engine = CryptoEngine::new(peripherals.crypto);\n    \n    // Store in global state (unsafe required)\n    unsafe {\n        CRYPTO_STATE = Some(crypto_engine);\n    }\n    \n    // Enable interrupts\n    unsafe { cortex_m::interrupt::enable() };\n    \n    loop {\n        // Main application loop\n        process_crypto_operations();\n        cortex_m::asm::wfi(); // Wait for interrupt\n    }\n}\n\n#[interrupt]\nfn CRYPTO_IRQ() {\n    // Handle crypto hardware interrupt\n    interrupt::free(|_| {\n        unsafe {\n            if let Some(ref mut crypto) = CRYPTO_STATE {\n                crypto.handle_interrupt();\n            }\n        }\n    });\n}\n\n#[panic_handler]\nfn panic(info: &PanicInfo) -> ! {\n    // Secure panic handler - clear sensitive data\n    unsafe {\n        CRYPTO_BUFFER.fill(0);\n        if let Some(ref mut crypto) = CRYPTO_STATE {\n            crypto.emergency_zeroize();\n        }\n    }\n    \n    // Reset system or halt\n    cortex_m::peripheral::SCB::sys_reset();\n}",
      "line_number": 293,
      "section": "No-std Complete Template",
      "context": "#### No-std Complete Template\n\n```rust\n#![no_std]\n#![no_main]"
    },
    {
      "language": "rust",
      "code": "// C code that compiles but has use-after-free bug:\n// uint8_t* create_key() {\n//     uint8_t key[32] = {0};\n//     return key;  // Returns pointer to stack memory!\n// }\n\n// Rust equivalent - won't compile:\nfn create_key() -> &[u8; 32] {\n    let key = [0u8; 32];\n    &key  // ERROR: borrowed value does not live long enough\n}\n\n// Correct Rust approach:\nfn create_key() -> [u8; 32] {\n    [0u8; 32]  // Return owned value, not reference\n}\n\n// Or use heap allocation:\nfn create_key_heap() -> Box<[u8; 32]> {\n    Box::new([0u8; 32])  // Heap-allocated, properly owned\n}",
      "line_number": 381,
      "section": "\u26a0\ufe0f Memory Management Gotchas",
      "context": "**\u26a0\ufe0f Critical Example - Use After Free Prevention:**\n\n```rust\n// C code that compiles but has use-after-free bug:\n// uint8_t* create_key() {"
    },
    {
      "language": "rust",
      "code": "// C code - easy to forget zeroization:\n// void process_message(uint8_t* key) {\n//     uint8_t session_key[32];\n//     derive_key(key, session_key);\n//     encrypt_message(session_key, message);\n//     // BUG: Forgot to clear session_key!\n//     return;\n// }\n\n// Rust equivalent - automatic zeroization:\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n\n#[derive(ZeroizeOnDrop)]\nstruct SessionKey([u8; 32]);\n\nfn process_message(master_key: &[u8; 32]) {\n    let session_key = SessionKey(derive_key(master_key));\n    encrypt_message(&session_key.0, message);\n    // session_key automatically zeroized when dropped\n}",
      "line_number": 419,
      "section": "\u26a0\ufe0f Crypto-Specific Gotchas",
      "context": "**\u26a0\ufe0f Critical Example - Automatic Key Zeroization:**\n\n```rust\n// C code - easy to forget zeroization:\n// void process_message(uint8_t* key) {"
    },
    {
      "language": "rust",
      "code": "// C code - vulnerable to timing attacks:\n// int verify_mac(uint8_t* expected, uint8_t* actual, size_t len) {\n//     for (size_t i = 0; i < len; i++) {\n//         if (expected[i] != actual[i]) {\n//             return 0;  // Early return leaks timing info!\n//         }\n//     }\n//     return 1;\n// }\n\n// Rust equivalent - constant-time comparison:\nuse subtle::ConstantTimeEq;\n\nfn verify_mac(expected: &[u8], actual: &[u8]) -> bool {\n    expected.ct_eq(actual).into()  // Always takes same time\n}",
      "line_number": 444,
      "section": "\u26a0\ufe0f Crypto-Specific Gotchas",
      "context": "**\u26a0\ufe0f Critical Example - Constant-Time Operations:**\n\n```rust\n// C code - vulnerable to timing attacks:\n// int verify_mac(uint8_t* expected, uint8_t* actual, size_t len) {"
    },
    {
      "language": "rust",
      "code": "// C code - race condition possible:\n// volatile uint32_t crypto_status = 0;\n// \n// void main_loop() {\n//     crypto_status = PROCESSING;  // Race with interrupt!\n//     start_crypto_operation();\n// }\n// \n// void CRYPTO_IRQ() {\n//     crypto_status = COMPLETE;    // Race with main loop!\n// }\n\n// Rust equivalent - compile-time safety:\nuse cortex_m::interrupt::Mutex;\nuse core::cell::RefCell;\n\nstatic CRYPTO_STATUS: Mutex<RefCell<CryptoStatus>> = \n    Mutex::new(RefCell::new(CryptoStatus::Idle));\n\n#[derive(Clone, Copy)]\nenum CryptoStatus {\n    Idle,\n    Processing,\n    Complete,\n}\n\nfn main_loop() {\n    cortex_m::interrupt::free(|cs| {\n        *CRYPTO_STATUS.borrow(cs).borrow_mut() = CryptoStatus::Processing;\n    });\n    start_crypto_operation();\n}\n\n#[interrupt]\nfn CRYPTO_IRQ() {\n    cortex_m::interrupt::free(|cs| {\n        *CRYPTO_STATUS.borrow(cs).borrow_mut() = CryptoStatus::Complete;\n    });\n}",
      "line_number": 477,
      "section": "\u26a0\ufe0f Embedded-Specific Gotchas",
      "context": "**\u26a0\ufe0f Critical Example - Interrupt-Safe Global State:**\n\n```rust\n// C code - race condition possible:\n// volatile uint32_t crypto_status = 0;"
    },
    {
      "language": "rust",
      "code": "// C code - direct register access:\n// #define CRYPTO_BASE 0x40000000\n// #define CRYPTO_CTRL (*(volatile uint32_t*)(CRYPTO_BASE + 0x00))\n// #define CRYPTO_DATA (*(volatile uint32_t*)(CRYPTO_BASE + 0x04))\n// \n// void start_encryption() {\n//     CRYPTO_CTRL = 0x01;  // Enable\n//     CRYPTO_DATA = key_data;  // Potential race conditions\n// }\n\n// Rust equivalent - type-safe register access:\nuse cortex_m::peripheral::Peripherals;\n\n// Using PAC (Peripheral Access Crate)\nfn start_encryption(crypto: &mut CRYPTO) {\n    crypto.ctrl.write(|w| w.enable().set_bit());\n    crypto.data.write(|w| unsafe { w.bits(key_data) });\n}\n\n// Or using raw pointers with explicit unsafe:\nfn start_encryption_raw() {\n    const CRYPTO_BASE: *mut u32 = 0x4000_0000 as *mut u32;\n    \n    unsafe {\n        // Explicit unsafe block makes risks visible\n        core::ptr::write_volatile(CRYPTO_BASE, 0x01);\n        core::ptr::write_volatile(CRYPTO_BASE.offset(1), key_data);\n    }\n}",
      "line_number": 521,
      "section": "\u26a0\ufe0f Embedded-Specific Gotchas",
      "context": "**\u26a0\ufe0f Critical Example - Safe Hardware Register Access:**\n\n```rust\n// C code - direct register access:\n// #define CRYPTO_BASE 0x40000000"
    },
    {
      "language": "rust",
      "code": "// C approach:\n// char buffer[256];\n// strcpy(buffer, \"Hello\");\n// strcat(buffer, \" World\");\n\n// Rust approach - different string types:\nlet mut buffer = [0u8; 256];  // Byte array, not string\nlet hello = b\"Hello\";         // Byte string literal\nlet world = b\" World\";        // Byte string literal\n\n// For actual strings:\nuse heapless::String;\nlet mut message: String<256> = String::new();\nmessage.push_str(\"Hello\").unwrap();\nmessage.push_str(\" World\").unwrap();",
      "line_number": 557,
      "section": "\u26a0\ufe0f Common Migration Pitfalls",
      "context": "**1. String Handling Differences:**\n\n```rust\n// C approach:\n// char buffer[256];"
    },
    {
      "language": "rust",
      "code": "// C approach:\n// uint8_t buffer[1024] = {0};  // Zero-initialized\n\n// Rust approach:\nlet buffer = [0u8; 1024];     // Zero-initialized\n// Or:\nlet mut buffer: [u8; 1024] = [0; 1024];\n\n// For uninitialized arrays (unsafe):\nlet mut buffer: [u8; 1024] = unsafe { \n    core::mem::MaybeUninit::uninit().assume_init() \n};\n// Must initialize before use!",
      "line_number": 577,
      "section": "\u26a0\ufe0f Common Migration Pitfalls",
      "context": "**2. Array Initialization Differences:**\n\n```rust\n// C approach:\n// uint8_t buffer[1024] = {0};  // Zero-initialized"
    },
    {
      "language": "rust",
      "code": "// C approach:\n// typedef int (*crypto_func_t)(uint8_t*, size_t);\n// crypto_func_t encrypt_fn = aes_encrypt;\n\n// Rust approach:\ntype CryptoFn = fn(&mut [u8]) -> Result<(), CryptoError>;\nlet encrypt_fn: CryptoFn = aes_encrypt;\n\n// Or using closures:\nlet encrypt_fn = |data: &mut [u8]| -> Result<(), CryptoError> {\n    aes_encrypt(data)\n};",
      "line_number": 595,
      "section": "\u26a0\ufe0f Common Migration Pitfalls",
      "context": "**3. Function Pointer Differences:**\n\n```rust\n// C approach:\n// typedef int (*crypto_func_t)(uint8_t*, size_t);"
    },
    {
      "language": "bash",
      "code": "# Install Rust and essential embedded tools\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource ~/.cargo/env\n\n# Core embedded development tools\ncargo install cargo-binutils probe-rs --features cli cargo-embed\n\n# Install targets for your hardware (choose what you need)\nrustup target add thumbv7em-none-eabihf  # Cortex-M4F/M7F (most common)\nrustup target add armv7r-none-eabihf     # Xilinx Cortex-R5F\nrustup target add thumbv8m.main-none-eabihf # Cortex-M33F (with TrustZone)",
      "line_number": 657,
      "section": "Install targets for your hardware (choose what you need)",
      "context": "<summary><strong>\u25b6\ufe0f Installation Commands</strong> - Copy-paste installation script</summary>\n\n```bash\n# Install Rust and essential embedded tools\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"
    },
    {
      "language": "toml",
      "code": "# .cargo/config.toml - ZynqMP/Versal configuration\n[target.armv7r-none-eabihf]\nrunner = \"echo 'Use Xilinx Vitis/XSCT for debugging'\"\nrustflags = [\n  \"-C\", \"link-arg=-Tlink.x\",\n  \"-C\", \"target-cpu=cortex-r5\",\n  \"-C\", \"target-feature=+vfp3\",\n]\n\n[build]\ntarget = \"armv7r-none-eabihf\"",
      "line_number": 682,
      "section": ".cargo/config.toml - ZynqMP/Versal configuration",
      "context": "#### 2.2.1 Xilinx Ultrascale+ (Cortex-R5) {#xilinx-ultrascale-cortex-r5}\n\n```toml\n# .cargo/config.toml - ZynqMP/Versal configuration\n[target.armv7r-none-eabihf]"
    },
    {
      "language": "rust",
      "code": "// memory.x - Optimized for crypto operations\nMEMORY\n{\n  ATCM : ORIGIN = 0x00000000, LENGTH = 64K   /* Fast instruction access */\n  BTCM : ORIGIN = 0x00020000, LENGTH = 64K   /* Fast data/stack */\n  OCM  : ORIGIN = 0xFFFC0000, LENGTH = 256K  /* Shared crypto workspace */\n  DDR  : ORIGIN = 0x00100000, LENGTH = 2G    /* Large buffers */\n}\n\n_stack_start = ORIGIN(BTCM) + LENGTH(BTCM);\n_crypto_workspace = ORIGIN(OCM);",
      "line_number": 696,
      "section": ".cargo/config.toml - ZynqMP/Versal configuration",
      "context": "```\n\n```rust\n// memory.x - Optimized for crypto operations\nMEMORY"
    },
    {
      "language": "toml",
      "code": "# .cargo/config.toml - STM32F4 example\n[target.thumbv7em-none-eabihf]\nrunner = \"probe-rs run --chip STM32F411RETx\"\nrustflags = [\n  \"-C\", \"link-arg=-Tlink.x\",\n  \"-C\", \"target-cpu=cortex-m4\",\n  \"-C\", \"target-feature=+fp-armv8d16\",\n]\n\n[build]\ntarget = \"thumbv7em-none-eabihf\"",
      "line_number": 712,
      "section": ".cargo/config.toml - STM32F4 example",
      "context": "#### 2.2.2 ARM Cortex-M Series {#arm-cortex-m-series}\n\n```toml\n# .cargo/config.toml - STM32F4 example\n[target.thumbv7em-none-eabihf]"
    },
    {
      "language": "bash",
      "code": "# Additional targets for specialized applications\nrustup target add riscv32imac-unknown-none-elf  # RISC-V with crypto extensions\nrustup target add thumbv6m-none-eabi             # Cortex-M0+ (resource constrained)",
      "line_number": 728,
      "section": "Additional targets for specialized applications",
      "context": "#### 2.2.3 Other Embedded Targets {#other-embedded-targets}\n\n```bash\n# Additional targets for specialized applications\nrustup target add riscv32imac-unknown-none-elf  # RISC-V with crypto extensions"
    },
    {
      "language": "toml",
      "code": "# Cargo.toml - Essential crypto dependencies\n[package]\nname = \"embedded-crypto-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n# Core embedded\ncortex-m = \"0.7\"\ncortex-m-rt = \"0.7\"\npanic-halt = \"0.2\"\n\n# Crypto (no-std)\nchacha20poly1305 = { version = \"0.10\", default-features = false }\naes-gcm = { version = \"0.10\", default-features = false }\nsha2 = { version = \"0.10\", default-features = false }\nsubtle = { version = \"2.5\", default-features = false }\nzeroize = { version = \"1.6\", default-features = false }\n\n# Collections\nheapless = \"0.7\"\n\n[profile.release]\nopt-level = \"z\"\nlto = true\npanic = \"abort\"",
      "line_number": 736,
      "section": "Collections",
      "context": "### 2.3 Project Structure and Dependencies {#project-structure-and-dependencies}\n\n```toml\n# Cargo.toml - Essential crypto dependencies\n[package]"
    },
    {
      "language": "rust",
      "code": "// build.rs - Hardware-specific optimizations\nuse std::env;\n\nfn main() {\n    let target = env::var(\"TARGET\").unwrap();\n    \n    // Enable hardware features based on target\n    match target.as_str() {\n        t if t.contains(\"thumbv8m\") => {\n            println!(\"cargo:rustc-cfg=feature=\\\"hw_crypto\\\"\");\n            println!(\"cargo:rustc-cfg=feature=\\\"trustzone\\\"\");\n        }\n        t if t.contains(\"cortex-r5\") => {\n            println!(\"cargo:rustc-cfg=feature=\\\"xilinx_r5\\\"\");\n        }\n        _ => {}\n    }\n}",
      "line_number": 779,
      "section": "2.4 Build Configuration",
      "context": "### 2.4 Build Configuration {#build-configuration}\n\n```rust\n// build.rs - Hardware-specific optimizations\nuse std::env;"
    },
    {
      "language": "bash",
      "code": "# 1. Verify installation\nrustc --version && cargo --version\n\n# 2. Test target compilation\ncargo new --bin setup-test && cd setup-test\necho 'cortex-m = \"0.7\"' >> Cargo.toml\necho 'cortex-m-rt = \"0.7\"' >> Cargo.toml\necho 'panic-halt = \"0.2\"' >> Cargo.toml\n\n# 3. Build for your target\ncargo build --target thumbv7em-none-eabihf --release\n\n# 4. Verify binary size (should be small)\ncargo size --target thumbv7em-none-eabihf --release\n\n# 5. Test crypto compilation\necho 'sha2 = { version = \"0.10\", default-features = false }' >> Cargo.toml\ncargo build --target thumbv7em-none-eabihf --release",
      "line_number": 804,
      "section": "5. Test crypto compilation",
      "context": "#### Step-by-Step Setup Verification\n\n```bash\n# 1. Verify installation\nrustc --version && cargo --version"
    },
    {
      "language": "rust",
      "code": "// src/main.rs - Setup verification test\n#![no_std]\n#![no_main]\n\nuse panic_halt as _;\nuse cortex_m_rt::entry;\n\n#[entry]\nfn main() -> ! {\n    // Basic functionality test\n    let test_data = [0x42u8; 32];\n    let mut result = 0u8;\n    \n    // Simple crypto-like operation\n    for &byte in &test_data {\n        result ^= byte;\n    }\n    \n    // If this compiles and the result is 0x42, setup is working\n    assert_eq!(result, 0x42);\n    \n    loop {\n        cortex_m::asm::wfi();\n    }\n}",
      "line_number": 827,
      "section": "Minimal Verification Application",
      "context": "#### Minimal Verification Application\n\n```rust\n// src/main.rs - Setup verification test\n#![no_std]"
    },
    {
      "language": "rust",
      "code": "use zeroize::{Zeroize, ZeroizeOnDrop};\n\n#[derive(ZeroizeOnDrop)]\nstruct CryptoContext {\n    session_key: [u8; 32],    // Owned key material\n    nonce_counter: u64,       // Owned state\n    cipher_state: AesState,   // Owned cipher context\n}\n\nimpl CryptoContext {\n    fn new(key: [u8; 32]) -> Self {\n        Self {\n            session_key: key,  // key ownership transferred here\n            nonce_counter: 0,\n            cipher_state: AesState::new(),\n        }\n    }\n    \n    fn encrypt(&mut self, plaintext: &[u8]) -> Result<Vec<u8>, CryptoError> {\n        // Exclusive mutable access prevents concurrent key usage\n        self.nonce_counter += 1;\n        \n        // Use owned key material safely\n        let nonce = self.nonce_counter.to_le_bytes();\n        aes_gcm_encrypt(&self.session_key, &nonce, plaintext)\n    }\n}\n\nfn secure_communication() -> Result<(), CryptoError> {\n    let master_key = generate_session_key()?;\n    let mut crypto_ctx = CryptoContext::new(master_key);\n    // master_key is moved, can't be accidentally reused\n    \n    let message1 = crypto_ctx.encrypt(b\"first message\")?;\n    let message2 = crypto_ctx.encrypt(b\"second message\")?;\n    // Nonce automatically incremented, no reuse possible\n    \n    transmit_messages(&[message1, message2])?;\n    \n    // crypto_ctx dropped here, session_key automatically zeroized\n    Ok(())\n}",
      "line_number": 909,
      "section": "Ownership in Embedded Crypto Context",
      "context": "#### Ownership in Embedded Crypto Context\n\n```rust\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n"
    },
    {
      "language": "rust",
      "code": "// Immutable borrowing - safe concurrent reads\nfn verify_multiple_signatures(\n    public_key: &[u8; 32],     // Immutable borrow\n    messages: &[&[u8]],        // Multiple immutable borrows allowed\n    signatures: &[[u8; 64]]\n) -> Vec<bool> {\n    messages.iter()\n        .zip(signatures.iter())\n        .map(|(msg, sig)| verify_signature(public_key, msg, sig))\n        .collect()\n}\n\n// Mutable borrowing - exclusive access for state updates\nfn update_crypto_state(ctx: &mut CryptoContext, new_params: CryptoParams) {\n    // Exclusive access ensures no race conditions\n    ctx.nonce_counter = new_params.starting_nonce;\n    ctx.cipher_state.update_key_schedule(&new_params.key);\n    // No other code can access ctx during this function\n}\n\n// Lifetime management for key derivation\nstruct KeyDerivationContext<'a> {\n    master_key: &'a [u8; 32],  // Borrowed master key\n    salt: &'a [u8; 16],        // Borrowed salt\n}\n\nimpl<'a> KeyDerivationContext<'a> {\n    fn derive_key(&self, info: &[u8]) -> [u8; 32] {\n        // Compiler ensures master_key and salt remain valid\n        hkdf_expand(self.master_key, self.salt, info)\n    }\n}\n\n// Usage ensures master key outlives derived keys\nfn key_hierarchy_example() -> Result<(), CryptoError> {\n    let master_key = [0u8; 32];  // Stack allocated\n    let salt = [1u8; 16];        // Stack allocated\n    \n    let kdf_ctx = KeyDerivationContext {\n        master_key: &master_key,\n        salt: &salt,\n    };\n    \n    let encryption_key = kdf_ctx.derive_key(b\"encryption\");\n    let mac_key = kdf_ctx.derive_key(b\"authentication\");\n    \n    // master_key and salt guaranteed valid throughout this scope\n    perform_crypto_operations(&encryption_key, &mac_key)?;\n    \n    Ok(())\n}",
      "line_number": 956,
      "section": "Borrowing Rules for Crypto Operations",
      "context": "#### Borrowing Rules for Crypto Operations\n\n```rust\n// Immutable borrowing - safe concurrent reads\nfn verify_multiple_signatures("
    },
    {
      "language": "rust",
      "code": "#![no_std]\n\nuse heapless::Vec;\n\n// Stack-based crypto operations (preferred in embedded)\nfn stack_crypto_operations() -> Result<[u8; 16], CryptoError> {\n    let mut plaintext = [0u8; 16];      // Stack allocated\n    let key = [0u8; 32];                // Stack allocated\n    let mut cipher_state = AesState::new(); // Stack allocated\n    \n    // All operations use stack memory\n    cipher_state.set_key(&key);\n    cipher_state.encrypt_block(&mut plaintext)?;\n    \n    Ok(plaintext)\n    // All memory automatically cleaned up\n}\n\n// Static allocation for global crypto state\nstatic mut GLOBAL_CRYPTO_CTX: Option<CryptoContext> = None;\n\nfn init_global_crypto(key: [u8; 32]) {\n    unsafe {\n        GLOBAL_CRYPTO_CTX = Some(CryptoContext::new(key));\n    }\n}\n\n// Heapless collections for message queues\nfn message_queue_example() -> Result<(), CryptoError> {\n    let mut encrypted_messages: Vec<[u8; 32], 16> = Vec::new();\n    \n    for i in 0..10 {\n        let plaintext = [i; 16];\n        let ciphertext = encrypt_message(&plaintext)?;\n        encrypted_messages.push(ciphertext)\n            .map_err(|_| CryptoError::QueueFull)?;\n    }\n    \n    // Process messages without heap allocation\n    for message in encrypted_messages.iter() {\n        transmit_encrypted_message(message)?;\n    }\n    \n    Ok(())\n}",
      "line_number": 1012,
      "section": "Memory Management Patterns for Embedded",
      "context": "#### Memory Management Patterns for Embedded\n\n```rust\n#![no_std]\n"
    },
    {
      "language": "rust",
      "code": "#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CryptoError {\n    // Key-related errors\n    InvalidKeySize,\n    WeakKey,\n    KeyExpired,\n    KeyNotFound,\n    \n    // Algorithm errors\n    InvalidNonce,\n    InvalidTag,\n    AuthenticationFailed,\n    DecryptionFailed,\n    \n    // Hardware errors\n    HardwareNotAvailable,\n    HardwareTimeout,\n    HardwareError(u32),\n    \n    // Resource errors\n    InsufficientEntropy,\n    BufferTooSmall,\n    QueueFull,\n    OutOfMemory,\n    \n    // Protocol errors\n    InvalidState,\n    ProtocolViolation,\n    HandshakeFailed,\n}\n\nimpl CryptoError {\n    pub fn is_recoverable(&self) -> bool {\n        match self {\n            CryptoError::HardwareTimeout | \n            CryptoError::InsufficientEntropy |\n            CryptoError::QueueFull => true,\n            _ => false,\n        }\n    }\n}\n\ntype CryptoResult<T> = Result<T, CryptoError>;",
      "line_number": 1066,
      "section": "Comprehensive Crypto Error Types",
      "context": "#### Comprehensive Crypto Error Types\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CryptoError {"
    },
    {
      "language": "rust",
      "code": "// Crypto operations with explicit error handling\nfn encrypt_aes_gcm(\n    key: &[u8; 32], \n    nonce: &[u8; 12], \n    plaintext: &[u8],\n    aad: &[u8]\n) -> CryptoResult<Vec<u8>> {\n    // Validate inputs explicitly\n    if key.iter().all(|&b| b == 0) {\n        return Err(CryptoError::WeakKey);\n    }\n    \n    if nonce.iter().all(|&b| b == 0) {\n        return Err(CryptoError::InvalidNonce);\n    }\n    \n    // Perform encryption with error checking\n    let mut cipher = Aes256Gcm::new(key)?;\n    let ciphertext = cipher.encrypt(nonce, plaintext, aad)?;\n    \n    Ok(ciphertext)\n}\n\n// Error propagation with ? operator\nfn secure_message_processing(message: &[u8]) -> CryptoResult<Vec<u8>> {\n    let session_key = derive_session_key()?;     // Propagates key derivation errors\n    let nonce = generate_nonce()?;               // Propagates RNG errors\n    let aad = compute_aad(&message)?;            // Propagates AAD computation errors\n    \n    let encrypted = encrypt_aes_gcm(&session_key, &nonce, message, &aad)?;\n    \n    Ok(encrypted)\n}\n\n// Comprehensive error handling\nfn handle_crypto_pipeline(messages: &[&[u8]]) -> CryptoResult<Vec<Vec<u8>>> {\n    let mut results = Vec::new();\n    \n    for message in messages {\n        match secure_message_processing(message) {\n            Ok(encrypted) => {\n                results.push(encrypted);\n            }\n            Err(CryptoError::InsufficientEntropy) => {\n                // Recoverable error - wait and retry\n                wait_for_entropy()?;\n                let encrypted = secure_message_processing(message)?;\n                results.push(encrypted);\n            }\n            Err(CryptoError::HardwareTimeout) => {\n                // Fallback to software crypto\n                let encrypted = software_encrypt_message(message)?;\n                results.push(encrypted);\n            }\n            Err(e) if e.is_recoverable() => {\n                // Generic recoverable error handling\n                retry_with_backoff(|| secure_message_processing(message))?;\n            }\n            Err(e) => {\n                // Non-recoverable error\n                log_crypto_error(&e);\n                return Err(e);\n            }\n        }\n    }\n    \n    Ok(results)\n}",
      "line_number": 1114,
      "section": "Error Propagation in Crypto Pipelines",
      "context": "#### Error Propagation in Crypto Pipelines\n\n```rust\n// Crypto operations with explicit error handling\nfn encrypt_aes_gcm("
    },
    {
      "language": "rust",
      "code": "// Safe handling of optional crypto contexts\nstruct CryptoManager {\n    active_sessions: heapless::FnvIndexMap<u32, CryptoContext, 16>,\n}\n\nimpl CryptoManager {\n    fn get_session(&mut self, session_id: u32) -> Option<&mut CryptoContext> {\n        self.active_sessions.get_mut(&session_id)\n    }\n    \n    fn process_message(&mut self, session_id: u32, message: &[u8]) -> CryptoResult<Vec<u8>> {\n        match self.get_session(session_id) {\n            Some(ctx) => {\n                // Session exists, safe to use\n                ctx.encrypt(message)\n            }\n            None => {\n                // No session found, handle gracefully\n                Err(CryptoError::InvalidState)\n            }\n        }\n    }\n    \n    fn cleanup_expired_sessions(&mut self) {\n        self.active_sessions.retain(|_, ctx| !ctx.is_expired());\n    }\n}\n\n// Chaining Option operations\nfn find_and_use_key(key_id: u32) -> Option<Vec<u8>> {\n    get_key_from_storage(key_id)?     // Returns None if key not found\n        .validate()?                  // Returns None if key invalid\n        .decrypt_with_master_key()    // Returns None if decryption fails\n}",
      "line_number": 1187,
      "section": "Option Types for Safe Nullable Crypto State",
      "context": "#### Option Types for Safe Nullable Crypto State\n\n```rust\n// Safe handling of optional crypto contexts\nstruct CryptoManager {"
    },
    {
      "language": "rust",
      "code": "// Retry with exponential backoff for transient errors\nfn retry_with_backoff<F, T>(mut operation: F) -> CryptoResult<T>\nwhere\n    F: FnMut() -> CryptoResult<T>,\n{\n    const MAX_RETRIES: u32 = 3;\n    let mut delay_ms = 10;\n    \n    for attempt in 0..MAX_RETRIES {\n        match operation() {\n            Ok(result) => return Ok(result),\n            Err(e) if e.is_recoverable() && attempt < MAX_RETRIES - 1 => {\n                // Wait before retry\n                cortex_m::asm::delay(delay_ms * 1000);\n                delay_ms *= 2; // Exponential backoff\n            }\n            Err(e) => return Err(e),\n        }\n    }\n    \n    Err(CryptoError::HardwareTimeout)\n}\n\n// Graceful degradation for hardware failures\nfn encrypt_with_fallback(data: &[u8], key: &[u8; 32]) -> CryptoResult<Vec<u8>> {\n    // Try hardware acceleration first\n    match hardware_encrypt(data, key) {\n        Ok(result) => Ok(result),\n        Err(CryptoError::HardwareNotAvailable) => {\n            // Fall back to software implementation\n            software_encrypt(data, key)\n        }\n        Err(e) => Err(e), // Propagate other errors\n    }\n}",
      "line_number": 1226,
      "section": "Error Recovery Patterns for Embedded Crypto",
      "context": "#### Error Recovery Patterns for Embedded Crypto\n\n```rust\n// Retry with exponential backoff for transient errors\nfn retry_with_backoff<F, T>(mut operation: F) -> CryptoResult<T>"
    },
    {
      "language": "rust",
      "code": "use core::marker::PhantomData;\n\n// Protocol states as types\nstruct Uninitialized;\nstruct HandshakeInProgress;\nstruct KeyExchangeComplete;\nstruct SessionEstablished;\nstruct SessionTerminated;\n\n// TLS connection with compile-time state tracking\nstruct TlsConnection<State> {\n    socket: Socket,\n    buffer: [u8; 4096],\n    state: PhantomData<State>,\n}\n\nimpl TlsConnection<Uninitialized> {\n    fn new(socket: Socket) -> Self {\n        Self { \n            socket, \n            buffer: [0; 4096],\n            state: PhantomData \n        }\n    }\n    \n    fn start_handshake(self, config: TlsConfig) -> CryptoResult<TlsConnection<HandshakeInProgress>> {\n        // Send ClientHello\n        let client_hello = build_client_hello(&config)?;\n        self.socket.send(&client_hello)?;\n        \n        Ok(TlsConnection {\n            socket: self.socket,\n            buffer: self.buffer,\n            state: PhantomData,\n        })\n    }\n}\n\nimpl TlsConnection<HandshakeInProgress> {\n    fn process_server_hello(mut self, server_hello: &[u8]) -> CryptoResult<TlsConnection<KeyExchangeComplete>> {\n        // Validate server hello\n        let server_params = parse_server_hello(server_hello)?;\n        validate_server_params(&server_params)?;\n        \n        Ok(TlsConnection {\n            socket: self.socket,\n            buffer: self.buffer,\n            state: PhantomData,\n        })\n    }\n}\n\nimpl TlsConnection<KeyExchangeComplete> {\n    fn complete_handshake(self, master_secret: &[u8; 48]) -> TlsConnection<SessionEstablished> {\n        TlsConnection {\n            socket: self.socket,\n            buffer: self.buffer,\n            state: PhantomData,\n        }\n    }\n}\n\nimpl TlsConnection<SessionEstablished> {\n    // Only available after successful handshake\n    fn send_encrypted(&mut self, data: &[u8]) -> CryptoResult<()> {\n        let encrypted = encrypt_application_data(data)?;\n        self.socket.send(&encrypted)?;\n        Ok(())\n    }\n    \n    fn receive_encrypted(&mut self) -> CryptoResult<Vec<u8>> {\n        let encrypted = self.socket.receive(&mut self.buffer)?;\n        decrypt_application_data(&encrypted)\n    }\n    \n    fn terminate(self) -> TlsConnection<SessionTerminated> {\n        // Send close_notify\n        let _ = self.socket.send(&[0x15, 0x03, 0x03, 0x00, 0x02, 0x01, 0x00]);\n        \n        TlsConnection {\n            socket: self.socket,\n            buffer: self.buffer,\n            state: PhantomData,\n        }\n    }\n}\n\n// Compiler enforces correct state transitions\nfn secure_communication_example() -> CryptoResult<()> {\n    let socket = Socket::connect(\"server:443\")?;\n    let config = TlsConfig::default();\n    \n    let conn = TlsConnection::new(socket)\n        .start_handshake(config)?\n        .process_server_hello(&receive_server_hello()?)?\n        .complete_handshake(&derive_master_secret()?);\n    \n    // Can only send encrypted data after handshake is complete\n    conn.send_encrypted(b\"GET / HTTP/1.1\\r\\n\\r\\n\")?;\n    let response = conn.receive_encrypted()?;\n    \n    // Properly terminate session\n    let _terminated = conn.terminate();\n    \n    Ok(())\n}",
      "line_number": 1270,
      "section": "Type-Safe Protocol State Machines",
      "context": "#### Type-Safe Protocol State Machines\n\n```rust\nuse core::marker::PhantomData;\n"
    },
    {
      "language": "rust",
      "code": "// Type-safe key sizes with const generics\n#[derive(ZeroizeOnDrop)]\nstruct CryptoKey<const N: usize> {\n    key_material: [u8; N],\n    algorithm: KeyAlgorithm,\n}\n\nimpl<const N: usize> CryptoKey<N> {\n    fn new(material: [u8; N], algorithm: KeyAlgorithm) -> CryptoResult<Self> {\n        // Validate key size matches algorithm\n        match (N, algorithm) {\n            (16, KeyAlgorithm::Aes128) |\n            (32, KeyAlgorithm::Aes256) |\n            (32, KeyAlgorithm::ChaCha20) => {\n                Ok(Self { key_material: material, algorithm })\n            }\n            _ => Err(CryptoError::InvalidKeySize),\n        }\n    }\n    \n    fn as_bytes(&self) -> &[u8; N] {\n        &self.key_material\n    }\n}\n\n// Type aliases for specific key sizes\ntype Aes128Key = CryptoKey<16>;\ntype Aes256Key = CryptoKey<32>;\ntype ChaCha20Key = CryptoKey<32>;\n\n// Compile-time prevention of key size mismatches\nfn encrypt_with_aes256(key: &Aes256Key, plaintext: &[u8]) -> CryptoResult<Vec<u8>> {\n    // key is guaranteed to be exactly 32 bytes at compile time\n    let cipher = Aes256::new(key.as_bytes());\n    cipher.encrypt(plaintext)\n}\n\nfn encrypt_with_chacha20(key: &ChaCha20Key, nonce: &[u8; 12], plaintext: &[u8]) -> CryptoResult<Vec<u8>> {\n    // key is guaranteed to be exactly 32 bytes at compile time\n    let cipher = ChaCha20::new(key.as_bytes(), nonce);\n    cipher.encrypt(plaintext)\n}\n\n// Const generic arrays for fixed-size crypto operations\nstruct CryptoBuffer<const SIZE: usize> {\n    data: [u8; SIZE],\n    used: usize,\n}\n\nimpl<const SIZE: usize> CryptoBuffer<SIZE> {\n    fn new() -> Self {\n        Self { data: [0; SIZE], used: 0 }\n    }\n    \n    fn encrypt_in_place<const KEY_SIZE: usize>(\n        &mut self, \n        key: &CryptoKey<KEY_SIZE>\n    ) -> CryptoResult<()> {\n        // Compile-time bounds checking\n        if self.used > SIZE {\n            return Err(CryptoError::BufferTooSmall);\n        }\n        \n        // Perform in-place encryption\n        encrypt_buffer(&mut self.data[..self.used], key.as_bytes())?;\n        Ok(())\n    }\n}\n\n// Usage with compile-time guarantees\nfn crypto_operations_example() -> CryptoResult<()> {\n    let aes_key = Aes256Key::new([0; 32], KeyAlgorithm::Aes256)?;\n    let chacha_key = ChaCha20Key::new([1; 32], KeyAlgorithm::ChaCha20)?;\n    \n    let mut buffer: CryptoBuffer<1024> = CryptoBuffer::new();\n    \n    // This works - correct key type and size\n    encrypt_with_aes256(&aes_key, b\"test data\")?;\n    buffer.encrypt_in_place(&aes_key)?;\n    \n    // This would be a compile error - wrong key type\n    // encrypt_with_aes256(&chacha_key, b\"test data\")?;\n    \n    Ok(())\n}",
      "line_number": 1381,
      "section": "Const Generics for Compile-Time Crypto Parameters",
      "context": "#### Const Generics for Compile-Time Crypto Parameters\n\n```rust\n// Type-safe key sizes with const generics\n#[derive(ZeroizeOnDrop)]"
    },
    {
      "language": "rust",
      "code": "// Distinguish between different types of cryptographic data\n#[derive(Clone, Copy)]\nstruct PlaintextData<'a>(&'a [u8]);\n\n#[derive(Clone, Copy)]\nstruct CiphertextData<'a>(&'a [u8]);\n\n#[derive(Clone, Copy)]\nstruct AuthenticatedData<'a>(&'a [u8]);\n\n#[derive(Clone, Copy, ZeroizeOnDrop)]\nstruct KeyMaterial<'a>(&'a [u8]);\n\n// Prevent mixing up different types of crypto data\nimpl<'a> PlaintextData<'a> {\n    fn new(data: &'a [u8]) -> Self {\n        Self(data)\n    }\n    \n    fn as_bytes(&self) -> &[u8] {\n        self.0\n    }\n}\n\nimpl<'a> CiphertextData<'a> {\n    fn new(data: &'a [u8]) -> Self {\n        Self(data)\n    }\n    \n    fn as_bytes(&self) -> &[u8] {\n        self.0\n    }\n}\n\n// Type-safe crypto operations\nfn aead_encrypt(\n    key: KeyMaterial,\n    nonce: &[u8; 12],\n    plaintext: PlaintextData,\n    aad: AuthenticatedData,\n) -> CryptoResult<Vec<u8>> {\n    // Function signature prevents mixing up parameters\n    let cipher = ChaCha20Poly1305::new(key.0);\n    cipher.encrypt(nonce, plaintext.as_bytes(), aad.as_bytes())\n}\n\nfn aead_decrypt(\n    key: KeyMaterial,\n    nonce: &[u8; 12],\n    ciphertext: CiphertextData,\n    aad: AuthenticatedData,\n) -> CryptoResult<Vec<u8>> {\n    let cipher = ChaCha20Poly1305::new(key.0);\n    cipher.decrypt(nonce, ciphertext.as_bytes(), aad.as_bytes())\n}\n\n// Usage prevents parameter confusion\nfn secure_message_example() -> CryptoResult<()> {\n    let key_bytes = [0u8; 32];\n    let key = KeyMaterial(&key_bytes);\n    let nonce = [1u8; 12];\n    \n    let message = b\"secret message\";\n    let additional_data = b\"public header\";\n    \n    // Type system prevents parameter mix-ups\n    let plaintext = PlaintextData::new(message);\n    let aad = AuthenticatedData::new(additional_data);\n    \n    let encrypted = aead_encrypt(key, &nonce, plaintext, aad)?;\n    \n    // For decryption, must use CiphertextData\n    let ciphertext = CiphertextData::new(&encrypted);\n    let decrypted = aead_decrypt(key, &nonce, ciphertext, aad)?;\n    \n    Ok(())\n}",
      "line_number": 1471,
      "section": "Newtype Pattern for Domain-Specific Security",
      "context": "#### Newtype Pattern for Domain-Specific Security\n\n```rust\n// Distinguish between different types of cryptographic data\n#[derive(Clone, Copy)]"
    },
    {
      "language": "rust",
      "code": "#![no_std]\n#![no_main]\n#![forbid(unsafe_code)]  // Optional: forbid unsafe except in specific modules\n\n// Essential imports for no-std embedded crypto\nuse panic_halt as _;\nuse cortex_m_rt::entry;\n\n// Core library - always available in no-std\nuse core::{\n    mem,                    // Memory utilities (size_of, align_of, etc.)\n    ptr,                    // Pointer operations (read_volatile, write_volatile)\n    slice,                  // Slice operations\n    fmt::Write,             // Formatting without heap allocation\n    convert::TryInto,       // Fallible conversions\n    ops::{Deref, DerefMut}, // Smart pointer traits\n};\n\n// Heapless collections - essential for no-std\nuse heapless::{\n    Vec,                    // Stack-allocated vector\n    String,                 // Stack-allocated string  \n    FnvIndexMap,           // Hash map without heap\n    spsc::{Queue, Producer, Consumer}, // Lock-free queues\n    pool::{Pool, Node},     // Memory pools\n};\n\n// Crypto dependencies (all no-std compatible)\nuse chacha20poly1305::{ChaCha20Poly1305, Key, Nonce};\nuse sha2::{Sha256, Digest};\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse subtle::ConstantTimeEq;\n\n#[entry]\nfn main() -> ! {\n    // Initialize hardware and crypto systems\n    let mut crypto_hw = init_crypto_hardware();\n    let mut crypto_ctx = CryptoContext::new();\n    \n    // Initialize static memory pools\n    init_memory_pools();\n    \n    // Enable interrupts for crypto operations\n    unsafe { cortex_m::interrupt::enable() };\n    \n    // Main application loop\n    loop {\n        process_crypto_requests(&mut crypto_hw, &mut crypto_ctx);\n        handle_crypto_interrupts();\n        cortex_m::asm::wfi(); // Wait for interrupt\n    }\n}\n\n// Secure panic handler that clears sensitive data\n#[panic_handler]\nfn panic(info: &PanicInfo) -> ! {\n    // Disable interrupts to prevent further crypto operations\n    cortex_m::interrupt::disable();\n    \n    // Clear all sensitive data before panic\n    unsafe {\n        clear_crypto_memory();\n    }\n    \n    // Log panic info if possible, then reset\n    #[cfg(feature = \"panic-log\")]\n    log_panic_info(info);\n    \n    // Reset system or halt based on configuration\n    #[cfg(feature = \"panic-reset\")]\n    cortex_m::peripheral::SCB::sys_reset();\n    \n    #[cfg(not(feature = \"panic-reset\"))]\n    loop { cortex_m::asm::wfi(); }\n}",
      "line_number": 1565,
      "section": "Complete No-std Project Template",
      "context": "#### Complete No-std Project Template\n\n```rust\n#![no_std]\n#![no_main]"
    },
    {
      "language": "rust",
      "code": "use heapless::{Vec, pool::{Pool, Node, Singleton}};\n\n// Static memory pools for different crypto operations\nstatic mut SMALL_BLOCKS: [Node<[u8; 256]>; 16] = [Node::new(); 16];\nstatic mut LARGE_BLOCKS: [Node<[u8; 4096]>; 4] = [Node::new(); 4];\nstatic mut CRYPTO_CONTEXTS: [Node<CryptoContext>; 8] = [Node::new(); 8];\n\nstatic SMALL_POOL: Pool<[u8; 256]> = Pool::new();\nstatic LARGE_POOL: Pool<[u8; 4096]> = Pool::new();\nstatic CONTEXT_POOL: Pool<CryptoContext> = Pool::new();\n\n// Singleton for global crypto state (only one instance allowed)\nstatic mut GLOBAL_CRYPTO_STATE: [u8; 2048] = [0; 2048];\nstatic CRYPTO_STATE: Singleton<GlobalCryptoState> = Singleton::new();\n\nfn init_memory_pools() {\n    unsafe {\n        SMALL_POOL.grow(&mut SMALL_BLOCKS);\n        LARGE_POOL.grow(&mut LARGE_BLOCKS);\n        CONTEXT_POOL.grow(&mut CRYPTO_CONTEXTS);\n    }\n}\n\n// Memory-efficient crypto operations using pools\nfn encrypt_with_pool(plaintext: &[u8]) -> Result<heapless::Vec<u8, 4096>, CryptoError> {\n    // Choose appropriate pool based on data size\n    if plaintext.len() <= 256 {\n        let mut buffer = SMALL_POOL.alloc().ok_or(CryptoError::OutOfMemory)?;\n        buffer[..plaintext.len()].copy_from_slice(plaintext);\n        \n        // Perform in-place encryption\n        encrypt_in_place(&mut buffer[..plaintext.len()])?;\n        \n        // Copy result to heapless Vec\n        let mut result = heapless::Vec::new();\n        result.extend_from_slice(&buffer[..plaintext.len()])\n            .map_err(|_| CryptoError::BufferTooSmall)?;\n        \n        Ok(result)\n    } else if plaintext.len() <= 4096 {\n        let mut buffer = LARGE_POOL.alloc().ok_or(CryptoError::OutOfMemory)?;\n        buffer[..plaintext.len()].copy_from_slice(plaintext);\n        \n        encrypt_in_place(&mut buffer[..plaintext.len()])?;\n        \n        let mut result = heapless::Vec::new();\n        result.extend_from_slice(&buffer[..plaintext.len()])\n            .map_err(|_| CryptoError::BufferTooSmall)?;\n        \n        Ok(result)\n    } else {\n        Err(CryptoError::DataTooLarge)\n    }\n}\n\n// Stack-based collections for crypto state management\n#[derive(ZeroizeOnDrop)]\nstruct CryptoSession {\n    active_keys: Vec<[u8; 32], 8>,        // Max 8 active keys\n    message_queue: Vec<CryptoMessage, 32>, // Max 32 queued messages\n    nonce_counters: Vec<u64, 8>,           // Nonce counter per key\n    session_id: u32,\n}\n\nimpl CryptoSession {\n    fn new(session_id: u32) -> Self {\n        Self {\n            active_keys: Vec::new(),\n            message_queue: Vec::new(),\n            nonce_counters: Vec::new(),\n            session_id,\n        }\n    }\n    \n    fn add_key(&mut self, key: [u8; 32]) -> Result<usize, CryptoError> {\n        let key_index = self.active_keys.len();\n        \n        self.active_keys.push(key)\n            .map_err(|_| CryptoError::TooManyKeys)?;\n        self.nonce_counters.push(0)\n            .map_err(|_| CryptoError::TooManyKeys)?;\n            \n        Ok(key_index)\n    }\n    \n    fn encrypt_message(&mut self, key_index: usize, plaintext: &[u8]) -> Result<Vec<u8, 4096>, CryptoError> {\n        let key = self.active_keys.get(key_index).ok_or(CryptoError::InvalidKeyIndex)?;\n        let nonce_counter = self.nonce_counters.get_mut(key_index).ok_or(CryptoError::InvalidKeyIndex)?;\n        \n        // Increment nonce counter (prevents reuse)\n        *nonce_counter += 1;\n        let nonce_bytes = nonce_counter.to_le_bytes();\n        \n        // Perform encryption with automatic nonce management\n        chacha20poly1305_encrypt(key, &nonce_bytes, plaintext)\n    }\n}\n\n// Compile-time memory layout with const generics\nstruct CryptoWorkspace<const BUFFER_SIZE: usize, const KEY_COUNT: usize> {\n    buffers: [[u8; BUFFER_SIZE]; 4],\n    keys: [[u8; 32]; KEY_COUNT],\n    nonces: [[u8; 12]; KEY_COUNT],\n    in_use: [bool; 4], // Track buffer usage\n}\n\nimpl<const BUFFER_SIZE: usize, const KEY_COUNT: usize> CryptoWorkspace<BUFFER_SIZE, KEY_COUNT> {\n    const fn new() -> Self {\n        Self {\n            buffers: [[0; BUFFER_SIZE]; 4],\n            keys: [[0; 32]; KEY_COUNT],\n            nonces: [[0; 12]; KEY_COUNT],\n            in_use: [false; 4],\n        }\n    }\n    \n    fn get_free_buffer(&mut self) -> Option<(usize, &mut [u8; BUFFER_SIZE])> {\n        for (i, in_use) in self.in_use.iter_mut().enumerate() {\n            if !*in_use {\n                *in_use = true;\n                return Some((i, &mut self.buffers[i]));\n            }\n        }\n        None\n    }\n    \n    fn release_buffer(&mut self, index: usize) {\n        if index < 4 {\n            self.in_use[index] = false;\n            // Zeroize buffer on release for security\n            self.buffers[index].zeroize();\n        }\n    }\n}\n\n// Different workspace configurations for different applications\ntype SmallCryptoWorkspace = CryptoWorkspace<256, 2>;   // 2KB buffers, 2 keys\ntype LargeCryptoWorkspace = CryptoWorkspace<4096, 8>;  // 16KB buffers, 8 keys\n\nstatic mut CRYPTO_WS: SmallCryptoWorkspace = SmallCryptoWorkspace::new();",
      "line_number": 1645,
      "section": "No-std Memory Management Patterns",
      "context": "#### No-std Memory Management Patterns\n\n```rust\nuse heapless::{Vec, pool::{Pool, Node, Singleton}};\n"
    },
    {
      "language": "rust",
      "code": "// Custom error types that work in no-std\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CryptoError {\n    InvalidKey,\n    InvalidNonce,\n    EncryptionFailed,\n    DecryptionFailed,\n    AuthenticationFailed,\n    OutOfMemory,\n    BufferTooSmall,\n    DataTooLarge,\n    TooManyKeys,\n    InvalidKeyIndex,\n    HardwareError(u32),\n}\n\n// No-std compatible Result type\npub type CryptoResult<T> = core::result::Result<T, CryptoError>;\n\n// Error handling without std::error::Error trait\nimpl CryptoError {\n    pub fn description(&self) -> &'static str {\n        match self {\n            CryptoError::InvalidKey => \"Invalid cryptographic key\",\n            CryptoError::InvalidNonce => \"Invalid nonce value\",\n            CryptoError::EncryptionFailed => \"Encryption operation failed\",\n            CryptoError::DecryptionFailed => \"Decryption operation failed\",\n            CryptoError::AuthenticationFailed => \"Authentication verification failed\",\n            CryptoError::OutOfMemory => \"Insufficient memory available\",\n            CryptoError::BufferTooSmall => \"Buffer too small for operation\",\n            CryptoError::DataTooLarge => \"Data exceeds maximum size\",\n            CryptoError::TooManyKeys => \"Maximum number of keys exceeded\",\n            CryptoError::InvalidKeyIndex => \"Invalid key index specified\",\n            CryptoError::HardwareError(_) => \"Hardware crypto accelerator error\",\n        }\n    }\n    \n    pub fn is_recoverable(&self) -> bool {\n        match self {\n            CryptoError::OutOfMemory | CryptoError::TooManyKeys => true,\n            _ => false,\n        }\n    }\n}\n\n// No-std compatible formatting\nimpl core::fmt::Display for CryptoError {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"{}\", self.description())\n    }\n}",
      "line_number": 1790,
      "section": "No-std Error Handling and Result Types",
      "context": "#### No-std Error Handling and Result Types\n\n```rust\n// Custom error types that work in no-std\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]"
    },
    {
      "language": "rust",
      "code": "// Direct register access using PAC - consolidated from scattered examples\nuse stm32f4xx_pac as pac;\nuse cortex_m::interrupt;\n\nstruct CryptoPeripheral {\n    cryp: pac::CRYP,\n    dma: Option<pac::DMA2>,\n}\n\nimpl CryptoPeripheral {\n    fn new(cryp: pac::CRYP, dma: Option<pac::DMA2>) -> Self {\n        Self { cryp, dma }\n    }\n    \n    fn configure_aes(&mut self, key: &[u32; 8], mode: AesMode) {\n        // Configure crypto peripheral for AES with different modes\n        self.cryp.cr.write(|w| {\n            match mode {\n                AesMode::ECB => w.algomode().aes_ecb(),\n                AesMode::CBC => w.algomode().aes_cbc(),\n                AesMode::CTR => w.algomode().aes_ctr(),\n                AesMode::GCM => w.algomode().aes_gcm(),\n            }\n            .datatype().bits32()\n            .keysize().bits256()\n        });\n        \n        // Load key into hardware registers (all 8 words for 256-bit key)\n        let key_regs = [\n            &self.cryp.k0lr, &self.cryp.k0rr, &self.cryp.k1lr, &self.cryp.k1rr,\n            &self.cryp.k2lr, &self.cryp.k2rr, &self.cryp.k3lr, &self.cryp.k3rr,\n        ];\n        \n        for (reg, &key_word) in key_regs.iter().zip(key.iter()) {\n            reg.write(|w| unsafe { w.bits(key_word) });\n        }\n        \n        // Enable crypto peripheral\n        self.cryp.cr.modify(|_, w| w.crypen().enabled());\n    }\n    \n    fn encrypt_block(&mut self, input: &[u32; 4]) -> Result<[u32; 4], CryptoError> {\n        // Check if peripheral is ready\n        if self.cryp.sr.read().busy().bit_is_set() {\n            return Err(CryptoError::HardwareBusy);\n        }\n        \n        // Write input data to data input registers\n        let input_regs = [&self.cryp.din, &self.cryp.din, &self.cryp.din, &self.cryp.din];\n        for (reg, &word) in input_regs.iter().zip(input.iter()) {\n            reg.write(|w| unsafe { w.bits(word) });\n        }\n        \n        // Wait for processing complete with timeout\n        let mut timeout = 10000;\n        while self.cryp.sr.read().busy().bit_is_set() && timeout > 0 {\n            timeout -= 1;\n            cortex_m::asm::nop();\n        }\n        \n        if timeout == 0 {\n            return Err(CryptoError::HardwareTimeout);\n        }\n        \n        // Read output data\n        Ok([\n            self.cryp.dout.read().bits(),\n            self.cryp.dout.read().bits(),\n            self.cryp.dout.read().bits(),\n            self.cryp.dout.read().bits(),\n        ])\n    }\n    \n    fn setup_dma_transfer(&mut self, src: &[u8], dst: &mut [u8]) -> Result<(), CryptoError> {\n        if let Some(ref mut dma) = self.dma {\n            // Configure DMA for crypto operations\n            dma.s0cr.write(|w| {\n                w.chsel().bits(2)  // Crypto channel\n                 .mburst().single()\n                 .pburst().single()\n                 .pl().high()\n                 .msize().bits32()\n                 .psize().bits32()\n                 .minc().incremented()\n                 .pinc().fixed()\n                 .dir().memory_to_peripheral()\n            });\n            \n            // Set addresses and count\n            dma.s0par.write(|w| unsafe { w.bits(self.cryp.din.as_ptr() as u32) });\n            dma.s0m0ar.write(|w| unsafe { w.bits(src.as_ptr() as u32) });\n            dma.s0ndtr.write(|w| w.ndt().bits(src.len() as u16 / 4));\n            \n            // Enable DMA stream\n            dma.s0cr.modify(|_, w| w.en().enabled());\n            \n            Ok(())\n        } else {\n            Err(CryptoError::DmaNotAvailable)\n        }\n    }\n}\n\n#[derive(Clone, Copy)]\nenum AesMode {\n    ECB,\n    CBC,\n    CTR,\n    GCM,\n}",
      "line_number": 1850,
      "section": "Peripheral Access Crate (PAC) Usage",
      "context": "#### Peripheral Access Crate (PAC) Usage\n\n```rust\n// Direct register access using PAC - consolidated from scattered examples\nuse stm32f4xx_pac as pac;"
    },
    {
      "language": "rust",
      "code": "// Generic crypto traits for hardware abstraction - consolidated interface\ntrait BlockCipher {\n    type Error;\n    type Block: AsRef<[u8]> + AsMut<[u8]>;\n    \n    fn encrypt_block(&mut self, block: &mut Self::Block) -> Result<(), Self::Error>;\n    fn decrypt_block(&mut self, block: &mut Self::Block) -> Result<(), Self::Error>;\n    fn block_size(&self) -> usize;\n}\n\ntrait StreamCipher {\n    type Error;\n    \n    fn encrypt_stream(&mut self, data: &mut [u8]) -> Result<(), Self::Error>;\n    fn decrypt_stream(&mut self, data: &mut [u8]) -> Result<(), Self::Error>;\n}\n\ntrait AuthenticatedCipher {\n    type Error;\n    type Tag: AsRef<[u8]>;\n    \n    fn encrypt_and_authenticate(&mut self, \n                               plaintext: &[u8], \n                               aad: &[u8]) -> Result<(Vec<u8>, Self::Tag), Self::Error>;\n    fn decrypt_and_verify(&mut self, \n                         ciphertext: &[u8], \n                         aad: &[u8], \n                         tag: &Self::Tag) -> Result<Vec<u8>, Self::Error>;\n}\n\n// Hardware implementation with comprehensive error handling\nstruct HardwareAes {\n    peripheral: CryptoPeripheral,\n    mode: AesMode,\n}\n\nimpl HardwareAes {\n    fn new(peripheral: CryptoPeripheral, mode: AesMode) -> Self {\n        Self { peripheral, mode }\n    }\n    \n    fn set_key(&mut self, key: &[u8; 32]) -> Result<(), CryptoError> {\n        // Convert bytes to words for hardware\n        let mut key_words = [0u32; 8];\n        for (i, chunk) in key.chunks_exact(4).enumerate() {\n            key_words[i] = u32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]);\n        }\n        \n        self.peripheral.configure_aes(&key_words, self.mode);\n        Ok(())\n    }\n}\n\nimpl BlockCipher for HardwareAes {\n    type Error = CryptoError;\n    type Block = [u8; 16];\n    \n    fn encrypt_block(&mut self, block: &mut [u8; 16]) -> Result<(), Self::Error> {\n        // Convert bytes to words for hardware\n        let mut words = [0u32; 4];\n        for (i, chunk) in block.chunks_exact(4).enumerate() {\n            words[i] = u32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]);\n        }\n        \n        // Use hardware encryption\n        let result = self.peripheral.encrypt_block(&words)?;\n        \n        // Convert back to bytes\n        for (i, &word) in result.iter().enumerate() {\n            let bytes = word.to_le_bytes();\n            block[i*4..(i+1)*4].copy_from_slice(&bytes);\n        }\n        \n        Ok(())\n    }\n    \n    fn decrypt_block(&mut self, block: &mut [u8; 16]) -> Result<(), Self::Error> {\n        // Hardware decryption implementation\n        // Similar to encrypt but with decryption mode\n        self.peripheral.cryp.cr.modify(|_, w| w.algodir().decrypt());\n        self.encrypt_block(block)?;\n        self.peripheral.cryp.cr.modify(|_, w| w.algodir().encrypt());\n        Ok(())\n    }\n    \n    fn block_size(&self) -> usize {\n        16\n    }\n}\n\n// Software fallback implementation\nstruct SoftwareAes {\n    key_schedule: [u32; 60],\n    rounds: usize,\n}\n\nimpl SoftwareAes {\n    fn new(key: &[u8; 32]) -> Self {\n        let mut key_schedule = [0u32; 60];\n        let rounds = aes_key_expansion(key, &mut key_schedule);\n        Self { key_schedule, rounds }\n    }\n}\n\nimpl BlockCipher for SoftwareAes {\n    type Error = CryptoError;\n    type Block = [u8; 16];\n    \n    fn encrypt_block(&mut self, block: &mut [u8; 16]) -> Result<(), Self::Error> {\n        aes_encrypt_block(block, &self.key_schedule, self.rounds);\n        Ok(())\n    }\n    \n    fn decrypt_block(&mut self, block: &mut [u8; 16]) -> Result<(), Self::Error> {\n        aes_decrypt_block(block, &self.key_schedule, self.rounds);\n        Ok(())\n    }\n    \n    fn block_size(&self) -> usize {\n        16\n    }\n}\n\n// Unified crypto engine with runtime hardware detection\npub struct CryptoEngine {\n    aes_impl: AesImplementation,\n    hardware_available: bool,\n}\n\nenum AesImplementation {\n    Hardware(HardwareAes),\n    Software(SoftwareAes),\n}\n\nimpl CryptoEngine {\n    pub fn new() -> Self {\n        // Detect hardware crypto availability at runtime\n        let hardware_available = detect_crypto_hardware();\n        \n        if hardware_available {\n            // Initialize hardware crypto\n            let peripheral = initialize_crypto_peripheral();\n            let hw_aes = HardwareAes::new(peripheral, AesMode::ECB);\n            Self {\n                aes_impl: AesImplementation::Hardware(hw_aes),\n                hardware_available: true,\n            }\n        } else {\n            // Fallback to software implementation\n            let sw_aes = SoftwareAes::new(&[0u8; 32]); // Placeholder key\n            Self {\n                aes_impl: AesImplementation::Software(sw_aes),\n                hardware_available: false,\n            }\n        }\n    }\n    \n    pub fn set_key(&mut self, key: &[u8; 32]) -> Result<(), CryptoError> {\n        match &mut self.aes_impl {\n            AesImplementation::Hardware(hw) => hw.set_key(key),\n            AesImplementation::Software(sw) => {\n                *sw = SoftwareAes::new(key);\n                Ok(())\n            }\n        }\n    }\n    \n    pub fn encrypt_block(&mut self, block: &mut [u8; 16]) -> Result<(), CryptoError> {\n        match &mut self.aes_impl {\n            AesImplementation::Hardware(hw) => hw.encrypt_block(block),\n            AesImplementation::Software(sw) => sw.encrypt_block(block),\n        }\n    }\n    \n    pub fn is_hardware_accelerated(&self) -> bool {\n        self.hardware_available\n    }\n}\n\n// Hardware detection and initialization functions\nfn detect_crypto_hardware() -> bool {\n    // Platform-specific hardware detection\n    #[cfg(feature = \"stm32f4\")]\n    {\n        // Check if CRYP peripheral is available\n        true // Simplified for example\n    }\n    #[cfg(feature = \"xilinx_r5\")]\n    {\n        // Check for Xilinx crypto engines\n        true\n    }\n    #[cfg(not(any(feature = \"stm32f4\", feature = \"xilinx_r5\")))]\n    {\n        false\n    }\n}\n\nfn initialize_crypto_peripheral() -> CryptoPeripheral {\n    // Platform-specific peripheral initialization\n    #[cfg(feature = \"stm32f4\")]\n    {\n        let dp = pac::Peripherals::take().unwrap();\n        CryptoPeripheral::new(dp.CRYP, Some(dp.DMA2))\n    }\n    #[cfg(not(feature = \"stm32f4\"))]\n    {\n        panic!(\"Hardware crypto not supported on this platform\")\n    }\n}",
      "line_number": 1965,
      "section": "Hardware Abstraction Layer (HAL) Patterns",
      "context": "#### Hardware Abstraction Layer (HAL) Patterns\n\n```rust\n// Generic crypto traits for hardware abstraction - consolidated interface\ntrait BlockCipher {"
    },
    {
      "language": "rust",
      "code": "// Cross-platform crypto hardware abstraction\npub trait CryptoHardware {\n    type Error;\n    \n    fn aes_encrypt(&mut self, key: &[u8; 32], block: &mut [u8; 16]) -> Result<(), Self::Error>;\n    fn aes_decrypt(&mut self, key: &[u8; 32], block: &mut [u8; 16]) -> Result<(), Self::Error>;\n    fn sha256(&mut self, data: &[u8]) -> Result<[u8; 32], Self::Error>;\n    fn random_bytes(&mut self, buffer: &mut [u8]) -> Result<(), Self::Error>;\n}\n\n// STM32 implementation\n#[cfg(feature = \"stm32\")]\npub struct Stm32CryptoHardware {\n    cryp: pac::CRYP,\n    hash: pac::HASH,\n    rng: pac::RNG,\n}\n\n#[cfg(feature = \"stm32\")]\nimpl CryptoHardware for Stm32CryptoHardware {\n    type Error = CryptoError;\n    \n    fn aes_encrypt(&mut self, key: &[u8; 32], block: &mut [u8; 16]) -> Result<(), Self::Error> {\n        // STM32-specific AES implementation\n        todo!(\"Implement STM32 AES\")\n    }\n    \n    fn sha256(&mut self, data: &[u8]) -> Result<[u8; 32], Self::Error> {\n        // STM32 HASH peripheral implementation\n        todo!(\"Implement STM32 SHA256\")\n    }\n    \n    fn random_bytes(&mut self, buffer: &mut [u8]) -> Result<(), Self::Error> {\n        // STM32 RNG implementation\n        todo!(\"Implement STM32 RNG\")\n    }\n    \n    fn aes_decrypt(&mut self, key: &[u8; 32], block: &mut [u8; 16]) -> Result<(), Self::Error> {\n        todo!(\"Implement STM32 AES decrypt\")\n    }\n}\n\n// Xilinx implementation\n#[cfg(feature = \"xilinx\")]\npub struct XilinxCryptoHardware {\n    aes_engine: XilinxAes,\n    sha_engine: XilinxSha,\n    trng: XilinxTrng,\n}\n\n#[cfg(feature = \"xilinx\")]\nimpl CryptoHardware for XilinxCryptoHardware {\n    type Error = CryptoError;\n    \n    fn aes_encrypt(&mut self, key: &[u8; 32], block: &mut [u8; 16]) -> Result<(), Self::Error> {\n        self.aes_engine.encrypt(key, block)\n    }\n    \n    fn sha256(&mut self, data: &[u8]) -> Result<[u8; 32], Self::Error> {\n        self.sha_engine.hash_sha256(data)\n    }\n    \n    fn random_bytes(&mut self, buffer: &mut [u8]) -> Result<(), Self::Error> {\n        self.trng.fill_bytes(buffer)\n    }\n    \n    fn aes_decrypt(&mut self, key: &[u8; 32], block: &mut [u8; 16]) -> Result<(), Self::Error> {\n        self.aes_engine.decrypt(key, block)\n    }\n}",
      "line_number": 2180,
      "section": "Cross-Platform Hardware Abstraction",
      "context": "#### Cross-Platform Hardware Abstraction\n\n```rust\n// Cross-platform crypto hardware abstraction\npub trait CryptoHardware {"
    },
    {
      "language": "rust",
      "code": "use cortex_m_rt::interrupt;\nuse cortex_m::interrupt::{Mutex, free};\nuse core::cell::RefCell;\nuse heapless::spsc::{Queue, Producer, Consumer};\n\n// Shared state between main code and interrupts - consolidated pattern\ntype SharedCryptoState = Mutex<RefCell<Option<CryptoContext>>>;\nstatic CRYPTO_STATE: SharedCryptoState = Mutex::new(RefCell::new(None));\n\n// Lock-free message queue for crypto operations\nstatic mut CRYPTO_QUEUE_STORAGE: Queue<CryptoMessage, 32> = Queue::new();\nstatic mut CRYPTO_PRODUCER: Option<Producer<CryptoMessage, 32>> = None;\nstatic mut CRYPTO_CONSUMER: Option<Consumer<CryptoMessage, 32>> = None;\n\n// Initialize interrupt-safe communication\nfn init_crypto_interrupts() {\n    let (producer, consumer) = unsafe { CRYPTO_QUEUE_STORAGE.split() };\n    unsafe {\n        CRYPTO_PRODUCER = Some(producer);\n        CRYPTO_CONSUMER = Some(consumer);\n    }\n}\n\n// Comprehensive crypto interrupt messages\n#[derive(Clone, Copy)]\nenum CryptoMessage {\n    EncryptionComplete(CryptoResult),\n    DecryptionComplete(CryptoResult),\n    KeyExpired,\n    HardwareError(u32),\n    DmaTransferComplete,\n    NonceCounterOverflow,\n    AuthenticationFailed,\n}\n\n#[derive(Clone, Copy)]\nstruct CryptoResult {\n    operation_id: u32,\n    status: CryptoStatus,\n    data_length: usize,\n}\n\n#[derive(Clone, Copy)]\nenum CryptoStatus {\n    Success,\n    Failed,\n    Timeout,\n    InvalidInput,\n}\n\n// Hardware crypto interrupt handler\n#[interrupt]\nfn CRYPTO_IRQ() {\n    free(|cs| {\n        if let Some(ref mut ctx) = CRYPTO_STATE.borrow(cs).borrow_mut().as_mut() {\n            // Handle different crypto hardware events\n            let hw_status = ctx.get_hardware_status();\n            \n            match hw_status {\n                HardwareStatus::EncryptionComplete => {\n                    let result = ctx.get_encryption_result();\n                    let message = CryptoMessage::EncryptionComplete(result);\n                    \n                    // Send to main thread via lock-free queue\n                    unsafe {\n                        if let Some(ref mut producer) = CRYPTO_PRODUCER {\n                            let _ = producer.enqueue(message);\n                        }\n                    }\n                }\n                HardwareStatus::DecryptionComplete => {\n                    let result = ctx.get_decryption_result();\n                    let message = CryptoMessage::DecryptionComplete(result);\n                    \n                    unsafe {\n                        if let Some(ref mut producer) = CRYPTO_PRODUCER {\n                            let _ = producer.enqueue(message);\n                        }\n                    }\n                }\n                HardwareStatus::Error(error_code) => {\n                    let message = CryptoMessage::HardwareError(error_code);\n                    unsafe {\n                        if let Some(ref mut producer) = CRYPTO_PRODUCER {\n                            let _ = producer.enqueue(message);\n                        }\n                    }\n                    \n                    // Clear hardware error state\n                    ctx.clear_error_state();\n                }\n                HardwareStatus::Idle => {\n                    // No action needed\n                }\n            }\n        }\n    });\n}\n\n// Timer interrupt for crypto operations timing and key management\n#[interrupt]\nfn TIM2() {\n    free(|cs| {\n        if let Some(ref mut ctx) = CRYPTO_STATE.borrow(cs).borrow_mut().as_mut() {\n            // Check for nonce counter overflow (critical security check)\n            if ctx.is_nonce_counter_near_overflow() {\n                let message = CryptoMessage::NonceCounterOverflow;\n                unsafe {\n                    if let Some(ref mut producer) = CRYPTO_PRODUCER {\n                        let _ = producer.enqueue(message);\n                    }\n                }\n            }\n            \n            // Check for key expiration\n            if ctx.is_key_expired() {\n                let message = CryptoMessage::KeyExpired;\n                unsafe {\n                    if let Some(ref mut producer) = CRYPTO_PRODUCER {\n                        let _ = producer.enqueue(message);\n                    }\n                }\n            }\n            \n            // Update timing-sensitive crypto state\n            ctx.update_timing_state();\n        }\n    });\n}\n\n// DMA interrupt for large crypto operations\n#[interrupt]\nfn DMA1_STREAM0() {\n    free(|cs| {\n        if let Some(ref mut ctx) = CRYPTO_STATE.borrow(cs).borrow_mut().as_mut() {\n            if ctx.is_dma_transfer_complete() {\n                let message = CryptoMessage::DmaTransferComplete;\n                unsafe {\n                    if let Some(ref mut producer) = CRYPTO_PRODUCER {\n                        let _ = producer.enqueue(message);\n                    }\n                }\n                \n                // Process completed DMA crypto operation\n                ctx.process_dma_result();\n            }\n        }\n    });\n}\n\n// Main thread crypto interrupt processing\nfn process_crypto_interrupts() -> Result<(), CryptoError> {\n    unsafe {\n        if let Some(ref mut consumer) = CRYPTO_CONSUMER {\n            while let Some(message) = consumer.dequeue() {\n                match message {\n                    CryptoMessage::EncryptionComplete(result) => {\n                        handle_encryption_result(result)?;\n                    }\n                    CryptoMessage::DecryptionComplete(result) => {\n                        handle_decryption_result(result)?;\n                    }\n                    CryptoMessage::KeyExpired => {\n                        regenerate_session_keys()?;\n                    }\n                    CryptoMessage::HardwareError(error_code) => {\n                        handle_hardware_error(error_code)?;\n                    }\n                    CryptoMessage::DmaTransferComplete => {\n                        finalize_dma_crypto_operation()?;\n                    }\n                    CryptoMessage::NonceCounterOverflow => {\n                        // Critical: Must regenerate keys immediately\n                        emergency_key_regeneration()?;\n                    }\n                    CryptoMessage::AuthenticationFailed => {\n                        handle_authentication_failure()?;\n                    }\n                }\n            }\n        }\n    }\n    Ok(())\n}",
      "line_number": 2259,
      "section": "Safe Interrupt Handling Fundamentals",
      "context": "#### Safe Interrupt Handling Fundamentals\n\n```rust\nuse cortex_m_rt::interrupt;\nuse cortex_m::interrupt::{Mutex, free};"
    },
    {
      "language": "rust",
      "code": "// Advanced real-time crypto using RTIC framework\n#[rtic::app(device = stm32f4xx_hal::pac, peripherals = true, dispatchers = [EXTI0, EXTI1])]\nmod app {\n    use super::*;\n    use rtic::time::duration::*;\n    \n    #[shared]\n    struct Shared {\n        crypto_context: CryptoContext,\n        session_keys: SessionKeys,\n        crypto_statistics: CryptoStatistics,\n    }\n    \n    #[local]\n    struct Local {\n        crypto_hardware: CryptoPeripheral,\n        timer: Timer<TIM2>,\n        dma_controller: DmaController,\n        led: Led,\n    }\n    \n    #[init]\n    fn init(ctx: init::Context) -> (Shared, Local, init::Monotonics) {\n        let dp = ctx.device;\n        \n        // Initialize crypto hardware with comprehensive setup\n        let crypto_hw = CryptoPeripheral::new(dp.CRYP, Some(dp.DMA2));\n        let timer = Timer::new(dp.TIM2);\n        let dma = DmaController::new(dp.DMA1);\n        let led = Led::new(dp.GPIOA.pa5);\n        \n        // Initialize crypto context with secure defaults\n        let crypto_ctx = CryptoContext::new_secure();\n        let session_keys = SessionKeys::generate_initial();\n        let stats = CryptoStatistics::new();\n        \n        // Schedule periodic key rotation\n        key_rotation::spawn_after(Seconds(300u32)).ok(); // Every 5 minutes\n        \n        (\n            Shared {\n                crypto_context: crypto_ctx,\n                session_keys,\n                crypto_statistics: stats,\n            },\n            Local {\n                crypto_hardware: crypto_hw,\n                timer,\n                dma_controller: dma,\n                led,\n            },\n            init::Monotonics(),\n        )\n    }\n    \n    // Highest priority - crypto hardware interrupt\n    #[task(binds = CRYP, priority = 4, shared = [crypto_context, crypto_statistics], local = [crypto_hardware])]\n    fn crypto_interrupt(mut ctx: crypto_interrupt::Context) {\n        let hw = ctx.local.crypto_hardware;\n        \n        (ctx.shared.crypto_context, ctx.shared.crypto_statistics).lock(|crypto_ctx, stats| {\n            if hw.is_encryption_ready() {\n                let result = hw.get_encryption_result();\n                crypto_ctx.process_encryption_result(result);\n                stats.record_encryption_complete();\n                \n                // Spawn low-priority task to handle result\n                crypto_result_handler::spawn(result).ok();\n            }\n            \n            if hw.is_decryption_ready() {\n                let result = hw.get_decryption_result();\n                crypto_ctx.process_decryption_result(result);\n                stats.record_decryption_complete();\n                \n                crypto_result_handler::spawn(result).ok();\n            }\n            \n            if hw.has_error() {\n                let error = hw.get_error();\n                stats.record_error(error);\n                \n                // Handle error immediately at high priority\n                crypto_error_handler::spawn(error).ok();\n            }\n        });\n    }\n    \n    // High priority - DMA completion\n    #[task(binds = DMA1_STREAM0, priority = 3, shared = [crypto_context])]\n    fn dma_interrupt(mut ctx: dma_interrupt::Context) {\n        ctx.shared.crypto_context.lock(|crypto_ctx| {\n            crypto_ctx.handle_dma_completion();\n        });\n        \n        // Spawn task to process DMA result\n        dma_result_handler::spawn().ok();\n    }\n    \n    // Medium priority - key management and security\n    #[task(priority = 2, shared = [session_keys, crypto_context, crypto_statistics])]\n    fn key_rotation(mut ctx: key_rotation::Context) {\n        (ctx.shared.session_keys, ctx.shared.crypto_context, ctx.shared.crypto_statistics).lock(\n            |keys, crypto_ctx, stats| {\n                // Generate new session keys\n                let new_keys = SessionKeys::generate_rotated(&keys);\n                \n                // Update crypto context with new keys\n                crypto_ctx.update_keys(&new_keys);\n                \n                // Securely zeroize old keys\n                *keys = new_keys;\n                \n                stats.record_key_rotation();\n            }\n        );\n        \n        // Schedule next key rotation\n        key_rotation::spawn_after(Seconds(300u32)).ok();\n    }\n    \n    // Medium priority - nonce management\n    #[task(priority = 2, shared = [crypto_context])]\n    fn nonce_overflow_handler(mut ctx: nonce_overflow_handler::Context) {\n        ctx.shared.crypto_context.lock(|crypto_ctx| {\n            // Critical: Reset nonce counter and regenerate keys\n            crypto_ctx.handle_nonce_overflow();\n        });\n        \n        // Force immediate key rotation\n        key_rotation::spawn().ok();\n    }\n    \n    // Low priority - crypto result processing\n    #[task(priority = 1, capacity = 8)]\n    fn crypto_result_handler(_ctx: crypto_result_handler::Context, result: CryptoResult) {\n        // Process crypto results without blocking high-priority operations\n        match result.status {\n            CryptoStatus::Success => {\n                transmit_crypto_result(result);\n            }\n            CryptoStatus::Failed => {\n                log_crypto_failure(result);\n                retry_crypto_operation(result);\n            }\n            CryptoStatus::Timeout => {\n                handle_crypto_timeout(result);\n            }\n            CryptoStatus::InvalidInput => {\n                handle_invalid_input(result);\n            }\n        }\n    }\n    \n    // Medium priority - error handling\n    #[task(priority = 2, shared = [crypto_statistics], local = [led])]\n    fn crypto_error_handler(mut ctx: crypto_error_handler::Context, error: u32) {\n        // Visual indication of crypto error\n        ctx.local.led.set_high();\n        \n        ctx.shared.crypto_statistics.lock(|stats| {\n            stats.record_critical_error(error);\n        });\n        \n        // Handle different error types\n        match error {\n            0x01 => handle_key_error(),\n            0x02 => handle_hardware_fault(),\n            0x03 => handle_dma_error(),\n            _ => handle_unknown_error(error),\n        }\n        \n        // Clear error indication after handling\n        ctx.local.led.set_low();\n    }\n    \n    // Low priority - DMA result processing\n    #[task(priority = 1)]\n    fn dma_result_handler(_ctx: dma_result_handler::Context) {\n        // Process completed DMA crypto operations\n        finalize_dma_crypto_operation();\n    }\n    \n    // Lowest priority - statistics and monitoring\n    #[task(priority = 0, shared = [crypto_statistics])]\n    fn statistics_reporter(mut ctx: statistics_reporter::Context) {\n        ctx.shared.crypto_statistics.lock(|stats| {\n            report_crypto_statistics(stats);\n            stats.reset_periodic_counters();\n        });\n        \n        // Schedule next statistics report\n        statistics_reporter::spawn_after(Seconds(60u32)).ok();\n    }\n}\n\n// Supporting structures for RTIC crypto application\n#[derive(ZeroizeOnDrop)]\nstruct SessionKeys {\n    encryption_key: [u8; 32],\n    mac_key: [u8; 32],\n    key_id: u32,\n    creation_time: u64,\n}\n\nimpl SessionKeys {\n    fn generate_initial() -> Self {\n        Self {\n            encryption_key: generate_random_key(),\n            mac_key: generate_random_key(),\n            key_id: 1,\n            creation_time: get_current_time(),\n        }\n    }\n    \n    fn generate_rotated(&self) -> Self {\n        Self {\n            encryption_key: generate_random_key(),\n            mac_key: generate_random_key(),\n            key_id: self.key_id + 1,\n            creation_time: get_current_time(),\n        }\n    }\n}\n\nstruct CryptoStatistics {\n    encryptions_completed: u32,\n    decryptions_completed: u32,\n    errors_encountered: u32,\n    key_rotations: u32,\n    last_reset_time: u64,\n}\n\nimpl CryptoStatistics {\n    fn new() -> Self {\n        Self {\n            encryptions_completed: 0,\n            decryptions_completed: 0,\n            errors_encountered: 0,\n            key_rotations: 0,\n            last_reset_time: get_current_time(),\n        }\n    }\n    \n    fn record_encryption_complete(&mut self) {\n        self.encryptions_completed += 1;\n    }\n    \n    fn record_decryption_complete(&mut self) {\n        self.decryptions_completed += 1;\n    }\n    \n    fn record_error(&mut self, _error: u32) {\n        self.errors_encountered += 1;\n    }\n    \n    fn record_key_rotation(&mut self) {\n        self.key_rotations += 1;\n    }\n    \n    fn record_critical_error(&mut self, _error: u32) {\n        self.errors_encountered += 1;\n        // Additional critical error handling\n    }\n    \n    fn reset_periodic_counters(&mut self) {\n        self.last_reset_time = get_current_time();\n        // Reset counters that should be periodic\n    }\n}",
      "line_number": 2448,
      "section": "RTIC Framework for Real-Time Crypto",
      "context": "#### RTIC Framework for Real-Time Crypto\n\n```rust\n// Advanced real-time crypto using RTIC framework\n#[rtic::app(device = stm32f4xx_hal::pac, peripherals = true, dispatchers = [EXTI0, EXTI1])]"
    },
    {
      "language": "rust",
      "code": "// Interrupt priority configuration for crypto applications\nconst CRYPTO_HW_PRIORITY: u8 = 0;      // Highest - hardware crypto\nconst DMA_PRIORITY: u8 = 1;             // High - DMA completion\nconst TIMER_PRIORITY: u8 = 2;           // Medium - timing and key management\nconst COMM_PRIORITY: u8 = 3;            // Lower - communication\nconst BACKGROUND_PRIORITY: u8 = 4;      // Lowest - background tasks\n\n// Configure interrupt priorities for optimal crypto performance\nfn configure_crypto_interrupt_priorities() {\n    unsafe {\n        // Set crypto hardware interrupt to highest priority\n        cortex_m::peripheral::NVIC::set_priority(\n            stm32f4xx_pac::Interrupt::CRYP, \n            CRYPTO_HW_PRIORITY\n        );\n        \n        // Set DMA interrupt to high priority\n        cortex_m::peripheral::NVIC::set_priority(\n            stm32f4xx_pac::Interrupt::DMA1_STREAM0, \n            DMA_PRIORITY\n        );\n        \n        // Set timer interrupt for key management\n        cortex_m::peripheral::NVIC::set_priority(\n            stm32f4xx_pac::Interrupt::TIM2, \n            TIMER_PRIORITY\n        );\n    }\n}\n\n// Critical section helpers for crypto operations\nfn with_crypto_interrupts_disabled<F, R>(f: F) -> R \nwhere \n    F: FnOnce() -> R,\n{\n    cortex_m::interrupt::free(|_| f())\n}\n\n// Atomic operations for crypto state\nuse core::sync::atomic::{AtomicU32, AtomicBool, Ordering};\n\nstatic CRYPTO_OPERATION_COUNT: AtomicU32 = AtomicU32::new(0);\nstatic CRYPTO_HARDWARE_BUSY: AtomicBool = AtomicBool::new(false);\n\nfn start_crypto_operation() -> Result<u32, CryptoError> {\n    // Atomically check and set hardware busy flag\n    if CRYPTO_HARDWARE_BUSY.compare_exchange(\n        false, \n        true, \n        Ordering::Acquire, \n        Ordering::Relaxed\n    ).is_err() {\n        return Err(CryptoError::HardwareBusy);\n    }\n    \n    // Increment operation counter\n    let op_id = CRYPTO_OPERATION_COUNT.fetch_add(1, Ordering::Relaxed);\n    Ok(op_id)\n}\n\nfn complete_crypto_operation() {\n    // Clear hardware busy flag\n    CRYPTO_HARDWARE_BUSY.store(false, Ordering::Release);\n}",
      "line_number": 2723,
      "section": "Interrupt Priority and Timing Considerations",
      "context": "#### Interrupt Priority and Timing Considerations\n\n```rust\n// Interrupt priority configuration for crypto applications\nconst CRYPTO_HW_PRIORITY: u8 = 0;      // Highest - hardware crypto"
    },
    {
      "language": "rust",
      "code": "use heapless::pool::{Pool, Node, Singleton};\nuse core::mem::MaybeUninit;\n\n// Comprehensive static memory pools for different crypto operations\nstatic mut TINY_BLOCKS: [Node<[u8; 64]>; 32] = [Node::new(); 32];      // For keys, nonces\nstatic mut SMALL_BLOCKS: [Node<[u8; 256]>; 16] = [Node::new(); 16];    // For small messages\nstatic mut MEDIUM_BLOCKS: [Node<[u8; 1024]>; 8] = [Node::new(); 8];    // For medium messages\nstatic mut LARGE_BLOCKS: [Node<[u8; 4096]>; 4] = [Node::new(); 4];     // For large messages\nstatic mut CRYPTO_CONTEXTS: [Node<CryptoContext>; 8] = [Node::new(); 8]; // For crypto contexts\n\n// Memory pools with different characteristics\nstatic TINY_POOL: Pool<[u8; 64]> = Pool::new();\nstatic SMALL_POOL: Pool<[u8; 256]> = Pool::new();\nstatic MEDIUM_POOL: Pool<[u8; 1024]> = Pool::new();\nstatic LARGE_POOL: Pool<[u8; 4096]> = Pool::new();\nstatic CONTEXT_POOL: Pool<CryptoContext> = Pool::new();\n\n// Singleton for global crypto state management\nstatic mut GLOBAL_CRYPTO_STATE_MEM: MaybeUninit<GlobalCryptoState> = MaybeUninit::uninit();\nstatic GLOBAL_CRYPTO_STATE: Singleton<GlobalCryptoState> = Singleton::new();\n\n// Memory pool initialization with error handling\nfn init_static_memory_pools() -> Result<(), MemoryError> {\n    unsafe {\n        TINY_POOL.grow(&mut TINY_BLOCKS);\n        SMALL_POOL.grow(&mut SMALL_BLOCKS);\n        MEDIUM_POOL.grow(&mut MEDIUM_BLOCKS);\n        LARGE_POOL.grow(&mut LARGE_BLOCKS);\n        CONTEXT_POOL.grow(&mut CRYPTO_CONTEXTS);\n    }\n    \n    // Initialize global crypto state\n    let global_state = GlobalCryptoState::new();\n    GLOBAL_CRYPTO_STATE.spawn(global_state)\n        .map_err(|_| MemoryError::SingletonAlreadyInitialized)?;\n    \n    Ok(())\n}\n\n// Smart memory allocation based on data size and usage pattern\nfn allocate_crypto_buffer(size: usize, usage: BufferUsage) -> Result<CryptoBuffer, MemoryError> {\n    match (size, usage) {\n        (0..=64, BufferUsage::Key | BufferUsage::Nonce) => {\n            let buffer = TINY_POOL.alloc().ok_or(MemoryError::TinyPoolExhausted)?;\n            Ok(CryptoBuffer::Tiny(buffer))\n        }\n        (0..=256, BufferUsage::SmallMessage) => {\n            let buffer = SMALL_POOL.alloc().ok_or(MemoryError::SmallPoolExhausted)?;\n            Ok(CryptoBuffer::Small(buffer))\n        }\n        (257..=1024, BufferUsage::MediumMessage) => {\n            let buffer = MEDIUM_POOL.alloc().ok_or(MemoryError::MediumPoolExhausted)?;\n            Ok(CryptoBuffer::Medium(buffer))\n        }\n        (1025..=4096, BufferUsage::LargeMessage) => {\n            let buffer = LARGE_POOL.alloc().ok_or(MemoryError::LargePoolExhausted)?;\n            Ok(CryptoBuffer::Large(buffer))\n        }\n        _ => Err(MemoryError::SizeNotSupported),\n    }\n}\n\n// Secure crypto buffer with automatic zeroization\nenum CryptoBuffer {\n    Tiny(heapless::pool::Box<[u8; 64]>),\n    Small(heapless::pool::Box<[u8; 256]>),\n    Medium(heapless::pool::Box<[u8; 1024]>),\n    Large(heapless::pool::Box<[u8; 4096]>),\n}\n\nimpl CryptoBuffer {\n    fn as_mut_slice(&mut self) -> &mut [u8] {\n        match self {\n            CryptoBuffer::Tiny(buf) => buf.as_mut(),\n            CryptoBuffer::Small(buf) => buf.as_mut(),\n            CryptoBuffer::Medium(buf) => buf.as_mut(),\n            CryptoBuffer::Large(buf) => buf.as_mut(),\n        }\n    }\n    \n    fn capacity(&self) -> usize {\n        match self {\n            CryptoBuffer::Tiny(_) => 64,\n            CryptoBuffer::Small(_) => 256,\n            CryptoBuffer::Medium(_) => 1024,\n            CryptoBuffer::Large(_) => 4096,\n        }\n    }\n}\n\nimpl Drop for CryptoBuffer {\n    fn drop(&mut self) {\n        // Secure zeroization before returning to pool\n        self.as_mut_slice().zeroize();\n    }\n}\n\n#[derive(Clone, Copy)]\nenum BufferUsage {\n    Key,\n    Nonce,\n    SmallMessage,\n    MediumMessage,\n    LargeMessage,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum MemoryError {\n    TinyPoolExhausted,\n    SmallPoolExhausted,\n    MediumPoolExhausted,\n    LargePoolExhausted,\n    ContextPoolExhausted,\n    SizeNotSupported,\n    SingletonAlreadyInitialized,\n}\n\n// Memory-efficient crypto operations with automatic pool selection\nfn encrypt_with_optimal_memory(plaintext: &[u8]) -> Result<heapless::Vec<u8, 4096>, CryptoError> {\n    // Determine optimal buffer size (add padding for encryption overhead)\n    let required_size = plaintext.len() + 16; // AES block size padding\n    let usage = match plaintext.len() {\n        0..=240 => BufferUsage::SmallMessage,\n        241..=1008 => BufferUsage::MediumMessage,\n        _ => BufferUsage::LargeMessage,\n    };\n    \n    // Allocate appropriate buffer\n    let mut buffer = allocate_crypto_buffer(required_size, usage)\n        .map_err(|_| CryptoError::OutOfMemory)?;\n    \n    // Copy plaintext to buffer\n    let buf_slice = buffer.as_mut_slice();\n    buf_slice[..plaintext.len()].copy_from_slice(plaintext);\n    \n    // Perform in-place encryption\n    let ciphertext_len = encrypt_in_place(&mut buf_slice[..plaintext.len()])?;\n    \n    // Copy result to return vector\n    let mut result = heapless::Vec::new();\n    result.extend_from_slice(&buf_slice[..ciphertext_len])\n        .map_err(|_| CryptoError::BufferTooSmall)?;\n    \n    // Buffer automatically zeroized and returned to pool when dropped\n    Ok(result)\n}",
      "line_number": 2796,
      "section": "Advanced Static Memory Pool Management",
      "context": "#### Advanced Static Memory Pool Management\n\n```rust\nuse heapless::pool::{Pool, Node, Singleton};\nuse core::mem::MaybeUninit;"
    },
    {
      "language": "rust",
      "code": "use zeroize::{Zeroize, ZeroizeOnDrop};\n\n// Advanced compile-time memory layout with security considerations\n#[derive(ZeroizeOnDrop)]\nstruct SecureCryptoWorkspace<const BUFFER_SIZE: usize, const KEY_COUNT: usize, const SESSION_COUNT: usize> {\n    // Data buffers with different access patterns\n    input_buffers: [[u8; BUFFER_SIZE]; 2],     // Double buffering for input\n    output_buffers: [[u8; BUFFER_SIZE]; 2],    // Double buffering for output\n    scratch_buffer: [u8; BUFFER_SIZE],         // Temporary calculations\n    \n    // Key material with automatic zeroization\n    session_keys: [[u8; 32]; KEY_COUNT],\n    nonces: [[u8; 12]; KEY_COUNT],\n    key_schedules: [[u32; 60]; KEY_COUNT],     // Expanded AES keys\n    \n    // Session management\n    active_sessions: [SessionInfo; SESSION_COUNT],\n    session_states: [SessionState; SESSION_COUNT],\n    \n    // Buffer management state\n    input_buffer_active: usize,\n    output_buffer_active: usize,\n    buffer_locks: [bool; 4],                   // Track buffer usage\n    \n    // Security state\n    key_generation_counter: u64,\n    last_key_rotation: u64,\n    security_violations: u32,\n}\n\nimpl<const BUFFER_SIZE: usize, const KEY_COUNT: usize, const SESSION_COUNT: usize> \n    SecureCryptoWorkspace<BUFFER_SIZE, KEY_COUNT, SESSION_COUNT> {\n    \n    const fn new() -> Self {\n        Self {\n            input_buffers: [[0; BUFFER_SIZE]; 2],\n            output_buffers: [[0; BUFFER_SIZE]; 2],\n            scratch_buffer: [0; BUFFER_SIZE],\n            session_keys: [[0; 32]; KEY_COUNT],\n            nonces: [[0; 12]; KEY_COUNT],\n            key_schedules: [[0; 60]; KEY_COUNT],\n            active_sessions: [SessionInfo::new(); SESSION_COUNT],\n            session_states: [SessionState::Idle; SESSION_COUNT],\n            input_buffer_active: 0,\n            output_buffer_active: 0,\n            buffer_locks: [false; 4],\n            key_generation_counter: 0,\n            last_key_rotation: 0,\n            security_violations: 0,\n        }\n    }\n    \n    fn get_input_buffer(&mut self) -> Result<(usize, &mut [u8; BUFFER_SIZE]), WorkspaceError> {\n        let inactive_buffer = 1 - self.input_buffer_active;\n        if !self.buffer_locks[inactive_buffer] {\n            self.buffer_locks[inactive_buffer] = true;\n            Ok((inactive_buffer, &mut self.input_buffers[inactive_buffer]))\n        } else {\n            Err(WorkspaceError::NoBufferAvailable)\n        }\n    }\n    \n    fn get_output_buffer(&mut self) -> Result<(usize, &mut [u8; BUFFER_SIZE]), WorkspaceError> {\n        let inactive_buffer = 1 - self.output_buffer_active;\n        if !self.buffer_locks[inactive_buffer + 2] {\n            self.buffer_locks[inactive_buffer + 2] = true;\n            Ok((inactive_buffer, &mut self.output_buffers[inactive_buffer]))\n        } else {\n            Err(WorkspaceError::NoBufferAvailable)\n        }\n    }\n    \n    fn release_buffer(&mut self, buffer_id: usize) {\n        if buffer_id < 4 {\n            self.buffer_locks[buffer_id] = false;\n            \n            // Zeroize buffer on release for security\n            match buffer_id {\n                0 => self.input_buffers[0].zeroize(),\n                1 => self.input_buffers[1].zeroize(),\n                2 => self.output_buffers[0].zeroize(),\n                3 => self.output_buffers[1].zeroize(),\n                _ => {}\n            }\n        }\n    }\n    \n    fn allocate_session(&mut self) -> Result<usize, WorkspaceError> {\n        for (i, state) in self.session_states.iter_mut().enumerate() {\n            if matches!(state, SessionState::Idle) {\n                *state = SessionState::Allocated;\n                self.active_sessions[i] = SessionInfo::new();\n                return Ok(i);\n            }\n        }\n        Err(WorkspaceError::NoSessionAvailable)\n    }\n    \n    fn setup_session_key(&mut self, session_id: usize, key: &[u8; 32]) -> Result<(), WorkspaceError> {\n        if session_id >= SESSION_COUNT {\n            return Err(WorkspaceError::InvalidSessionId);\n        }\n        \n        // Copy key and expand for AES\n        self.session_keys[session_id].copy_from_slice(key);\n        aes_key_expansion(key, &mut self.key_schedules[session_id]);\n        \n        // Generate unique nonce for this session\n        self.key_generation_counter += 1;\n        let nonce_seed = self.key_generation_counter.to_le_bytes();\n        self.nonces[session_id][..8].copy_from_slice(&nonce_seed);\n        \n        self.session_states[session_id] = SessionState::KeyLoaded;\n        Ok(())\n    }\n    \n    fn encrypt_session_data(&mut self, session_id: usize, data: &[u8]) -> Result<usize, WorkspaceError> {\n        if session_id >= SESSION_COUNT || !matches!(self.session_states[session_id], SessionState::KeyLoaded) {\n            return Err(WorkspaceError::InvalidSessionState);\n        }\n        \n        if data.len() > BUFFER_SIZE - 16 { // Reserve space for authentication tag\n            return Err(WorkspaceError::DataTooLarge);\n        }\n        \n        // Get buffers for operation\n        let (input_id, input_buf) = self.get_input_buffer()?;\n        let (output_id, output_buf) = self.get_output_buffer()?;\n        \n        // Copy data to input buffer\n        input_buf[..data.len()].copy_from_slice(data);\n        \n        // Perform encryption using session key\n        let ciphertext_len = aes_gcm_encrypt(\n            &self.session_keys[session_id],\n            &self.nonces[session_id],\n            &input_buf[..data.len()],\n            &mut output_buf[..data.len() + 16],\n        )?;\n        \n        // Update nonce to prevent reuse\n        increment_nonce(&mut self.nonces[session_id]);\n        \n        // Release input buffer (automatically zeroized)\n        self.release_buffer(input_id);\n        \n        // Keep output buffer locked for caller to retrieve\n        Ok(ciphertext_len)\n    }\n    \n    fn check_security_state(&mut self) -> SecurityStatus {\n        let current_time = get_current_time();\n        \n        // Check if key rotation is needed\n        if current_time - self.last_key_rotation > KEY_ROTATION_INTERVAL {\n            return SecurityStatus::KeyRotationRequired;\n        }\n        \n        // Check for security violations\n        if self.security_violations > MAX_SECURITY_VIOLATIONS {\n            return SecurityStatus::SecurityViolation;\n        }\n        \n        SecurityStatus::Secure\n    }\n}\n\n#[derive(Clone, Copy)]\nstruct SessionInfo {\n    creation_time: u64,\n    message_count: u32,\n    last_activity: u64,\n}\n\nimpl SessionInfo {\n    const fn new() -> Self {\n        Self {\n            creation_time: 0,\n            message_count: 0,\n            last_activity: 0,\n        }\n    }\n}\n\n#[derive(Clone, Copy)]\nenum SessionState {\n    Idle,\n    Allocated,\n    KeyLoaded,\n    Active,\n    Expired,\n}\n\n#[derive(Debug)]\nenum WorkspaceError {\n    NoBufferAvailable,\n    NoSessionAvailable,\n    InvalidSessionId,\n    InvalidSessionState,\n    DataTooLarge,\n    EncryptionFailed,\n}\n\nenum SecurityStatus {\n    Secure,\n    KeyRotationRequired,\n    SecurityViolation,\n}\n\n// Predefined workspace configurations for different applications\ntype MicroCryptoWorkspace = SecureCryptoWorkspace<128, 2, 2>;    // 256B buffers, 2 keys, 2 sessions\ntype SmallCryptoWorkspace = SecureCryptoWorkspace<512, 4, 4>;    // 1KB buffers, 4 keys, 4 sessions  \ntype MediumCryptoWorkspace = SecureCryptoWorkspace<2048, 8, 8>;  // 4KB buffers, 8 keys, 8 sessions\ntype LargeCryptoWorkspace = SecureCryptoWorkspace<8192, 16, 16>; // 16KB buffers, 16 keys, 16 sessions\n\n// Global workspace instance (choose based on application requirements)\nstatic mut CRYPTO_WORKSPACE: MediumCryptoWorkspace = MediumCryptoWorkspace::new();\n\n// Safe wrapper for global workspace access\nfn with_crypto_workspace<F, R>(f: F) -> R \nwhere \n    F: FnOnce(&mut MediumCryptoWorkspace) -> R,\n{\n    cortex_m::interrupt::free(|_| {\n        unsafe { f(&mut CRYPTO_WORKSPACE) }\n    })\n}\n\n// Constants for security policy\nconst KEY_ROTATION_INTERVAL: u64 = 3600; // 1 hour in seconds\nconst MAX_SECURITY_VIOLATIONS: u32 = 5;",
      "line_number": 2947,
      "section": "Compile-Time Memory Layout with Security Features",
      "context": "#### Compile-Time Memory Layout with Security Features\n\n```rust\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n"
    },
    {
      "language": "rust",
      "code": "// Memory layout optimized for crypto operations and cache performance\n#[repr(C, align(32))] // Align to cache line boundary\nstruct OptimizedCryptoLayout {\n    // Hot data - frequently accessed, keep together\n    active_key: [u8; 32],\n    current_nonce: [u8; 12],\n    message_counter: u64,\n    \n    // Padding to next cache line\n    _pad1: [u8; 20],\n    \n    // Working buffers - align to AES block boundaries\n    #[repr(align(16))]\n    aes_input_block: [u8; 16],\n    #[repr(align(16))]\n    aes_output_block: [u8; 16],\n    \n    // Key schedule - used during encryption setup\n    #[repr(align(16))]\n    expanded_key: [u32; 60],\n    \n    // Cold data - less frequently accessed\n    backup_keys: [[u8; 32]; 4],\n    session_metadata: [SessionMetadata; 8],\n    \n    // Statistics and monitoring (coldest data)\n    operation_count: u64,\n    error_count: u32,\n    last_maintenance: u64,\n}\n\nimpl OptimizedCryptoLayout {\n    const fn new() -> Self {\n        Self {\n            active_key: [0; 32],\n            current_nonce: [0; 12],\n            message_counter: 0,\n            _pad1: [0; 20],\n            aes_input_block: [0; 16],\n            aes_output_block: [0; 16],\n            expanded_key: [0; 60],\n            backup_keys: [[0; 32]; 4],\n            session_metadata: [SessionMetadata::new(); 8],\n            operation_count: 0,\n            error_count: 0,\n            last_maintenance: 0,\n        }\n    }\n    \n    // Fast path encryption using optimized layout\n    fn fast_encrypt_block(&mut self, plaintext: &[u8; 16]) -> Result<[u8; 16], CryptoError> {\n        // Input and output blocks are cache-aligned for optimal performance\n        self.aes_input_block.copy_from_slice(plaintext);\n        \n        // Use expanded key (already in cache from previous operations)\n        aes_encrypt_block_optimized(\n            &mut self.aes_input_block,\n            &mut self.aes_output_block,\n            &self.expanded_key,\n        )?;\n        \n        // Increment message counter (hot data, likely in cache)\n        self.message_counter += 1;\n        \n        Ok(self.aes_output_block)\n    }\n}\n\n#[derive(Clone, Copy)]\nstruct SessionMetadata {\n    session_id: u32,\n    creation_time: u64,\n    last_used: u64,\n    message_count: u32,\n}\n\nimpl SessionMetadata {\n    const fn new() -> Self {\n        Self {\n            session_id: 0,\n            creation_time: 0,\n            last_used: 0,\n            message_count: 0,\n        }\n    }\n}\n\n// Static allocation with optimal memory layout\nstatic mut OPTIMIZED_CRYPTO: OptimizedCryptoLayout = OptimizedCryptoLayout::new();",
      "line_number": 3183,
      "section": "Memory Layout Optimization for Crypto Performance",
      "context": "#### Memory Layout Optimization for Crypto Performance\n\n```rust\n// Memory layout optimized for crypto operations and cache performance\n#[repr(C, align(32))] // Align to cache line boundary"
    },
    {
      "language": "rust",
      "code": "use cortex_m::singleton;\nuse core::sync::atomic::{AtomicBool, Ordering};\n\n// DMA-safe buffer allocation with multiple buffer support\nstatic DMA_BUFFER_IN_USE: [AtomicBool; 4] = [\n    AtomicBool::new(false),\n    AtomicBool::new(false),\n    AtomicBool::new(false),\n    AtomicBool::new(false),\n];\n\n// Multiple DMA buffers for concurrent operations\nfn allocate_dma_buffer(size: DmaBufferSize) -> Option<DmaBuffer> {\n    match size {\n        DmaBufferSize::Small => {\n            if DMA_BUFFER_IN_USE[0].compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n                singleton!(: [u8; 256] = [0; 256]).map(|buf| DmaBuffer::Small(buf))\n            } else if DMA_BUFFER_IN_USE[1].compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n                singleton!(: [u8; 256] = [0; 256]).map(|buf| DmaBuffer::Small(buf))\n            } else {\n                None\n            }\n        }\n        DmaBufferSize::Large => {\n            if DMA_BUFFER_IN_USE[2].compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n                singleton!(: [u8; 4096] = [0; 4096]).map(|buf| DmaBuffer::Large(buf))\n            } else if DMA_BUFFER_IN_USE[3].compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n                singleton!(: [u8; 4096] = [0; 4096]).map(|buf| DmaBuffer::Large(buf))\n            } else {\n                None\n            }\n        }\n    }\n}\n\nenum DmaBuffer {\n    Small(&'static mut [u8; 256]),\n    Large(&'static mut [u8; 4096]),\n}\n\nimpl DmaBuffer {\n    fn as_mut_slice(&mut self) -> &mut [u8] {\n        match self {\n            DmaBuffer::Small(buf) => buf.as_mut(),\n            DmaBuffer::Large(buf) => buf.as_mut(),\n        }\n    }\n    \n    fn capacity(&self) -> usize {\n        match self {\n            DmaBuffer::Small(_) => 256,\n            DmaBuffer::Large(_) => 4096,\n        }\n    }\n    \n    fn buffer_id(&self) -> usize {\n        match self {\n            DmaBuffer::Small(_) => 0, // Simplified - would need proper tracking\n            DmaBuffer::Large(_) => 2,\n        }\n    }\n}\n\nimpl Drop for DmaBuffer {\n    fn drop(&mut self) {\n        // Secure zeroization and release buffer\n        self.as_mut_slice().zeroize();\n        let id = self.buffer_id();\n        if id < 4 {\n            DMA_BUFFER_IN_USE[id].store(false, Ordering::Release);\n        }\n    }\n}\n\n#[derive(Clone, Copy)]\nenum DmaBufferSize {\n    Small,  // 256 bytes\n    Large,  // 4096 bytes\n}\n\n// Comprehensive DMA crypto operations\nstruct AdvancedDmaCrypto {\n    dma_tx_channel: DmaChannel,\n    dma_rx_channel: DmaChannel,\n    crypto_peripheral: CryptoPeripheral,\n    active_operations: heapless::Vec<DmaOperation, 8>,\n}\n\n#[derive(Clone, Copy)]\nstruct DmaOperation {\n    operation_id: u32,\n    operation_type: DmaOperationType,\n    buffer_size: usize,\n    status: DmaOperationStatus,\n}\n\n#[derive(Clone, Copy)]\nenum DmaOperationType {\n    Encrypt,\n    Decrypt,\n    Hash,\n    KeyDerivation,\n}\n\n#[derive(Clone, Copy)]\nenum DmaOperationStatus {\n    Pending,\n    InProgress,\n    Complete,\n    Error(u32),\n}\n\nimpl AdvancedDmaCrypto {\n    fn new(dma_tx: DmaChannel, dma_rx: DmaChannel, crypto: CryptoPeripheral) -> Self {\n        Self {\n            dma_tx_channel: dma_tx,\n            dma_rx_channel: dma_rx,\n            crypto_peripheral: crypto,\n            active_operations: heapless::Vec::new(),\n        }\n    }\n    \n    fn encrypt_async(&mut self, data: DmaBuffer, key: &[u8; 32]) -> Result<u32, DmaError> {\n        // Generate unique operation ID\n        static mut OPERATION_COUNTER: u32 = 0;\n        let operation_id = unsafe {\n            OPERATION_COUNTER += 1;\n            OPERATION_COUNTER\n        };\n        \n        // Configure crypto peripheral for encryption\n        self.crypto_peripheral.configure_aes_dma(key, AesMode::GCM)?;\n        \n        // Configure DMA for crypto operation\n        self.dma_tx_channel.configure(\n            data.as_mut_slice().as_ptr() as u32,\n            self.crypto_peripheral.input_data_register(),\n            data.as_mut_slice().len(),\n            DmaDirection::MemoryToPeripheral,\n        )?;\n        \n        self.dma_rx_channel.configure(\n            self.crypto_peripheral.output_data_register(),\n            data.as_mut_slice().as_mut_ptr() as u32,\n            data.as_mut_slice().len() + 16, // Add space for GCM tag\n            DmaDirection::PeripheralToMemory,\n        )?;\n        \n        // Track operation\n        let operation = DmaOperation {\n            operation_id,\n            operation_type: DmaOperationType::Encrypt,\n            buffer_size: data.as_mut_slice().len(),\n            status: DmaOperationStatus::Pending,\n        };\n        \n        self.active_operations.push(operation)\n            .map_err(|_| DmaError::TooManyOperations)?;\n        \n        // Start DMA transfers\n        self.dma_tx_channel.start();\n        self.dma_rx_channel.start();\n        \n        Ok(operation_id)\n    }\n    \n    fn decrypt_async(&mut self, data: DmaBuffer, key: &[u8; 32]) -> Result<u32, DmaError> {\n        // Similar to encrypt_async but for decryption\n        static mut OPERATION_COUNTER: u32 = 0;\n        let operation_id = unsafe {\n            OPERATION_COUNTER += 1;\n            OPERATION_COUNTER\n        };\n        \n        // Configure for decryption\n        self.crypto_peripheral.configure_aes_dma(key, AesMode::GCM)?;\n        self.crypto_peripheral.set_decrypt_mode();\n        \n        // Configure DMA channels\n        self.dma_tx_channel.configure(\n            data.as_mut_slice().as_ptr() as u32,\n            self.crypto_peripheral.input_data_register(),\n            data.as_mut_slice().len(),\n            DmaDirection::MemoryToPeripheral,\n        )?;\n        \n        self.dma_rx_channel.configure(\n            self.crypto_peripheral.output_data_register(),\n            data.as_mut_slice().as_mut_ptr() as u32,\n            data.as_mut_slice().len() - 16, // Remove GCM tag space\n            DmaDirection::PeripheralToMemory,\n        )?;\n        \n        let operation = DmaOperation {\n            operation_id,\n            operation_type: DmaOperationType::Decrypt,\n            buffer_size: data.as_mut_slice().len(),\n            status: DmaOperationStatus::Pending,\n        };\n        \n        self.active_operations.push(operation)\n            .map_err(|_| DmaError::TooManyOperations)?;\n        \n        self.dma_tx_channel.start();\n        self.dma_rx_channel.start();\n        \n        Ok(operation_id)\n    }\n    \n    fn hash_async(&mut self, data: DmaBuffer) -> Result<u32, DmaError> {\n        static mut OPERATION_COUNTER: u32 = 0;\n        let operation_id = unsafe {\n            OPERATION_COUNTER += 1;\n            OPERATION_COUNTER\n        };\n        \n        // Configure crypto peripheral for hashing\n        self.crypto_peripheral.configure_hash_dma(HashAlgorithm::Sha256)?;\n        \n        // Configure DMA for hash operation\n        self.dma_tx_channel.configure(\n            data.as_mut_slice().as_ptr() as u32,\n            self.crypto_peripheral.hash_input_register(),\n            data.as_mut_slice().len(),\n            DmaDirection::MemoryToPeripheral,\n        )?;\n        \n        let operation = DmaOperation {\n            operation_id,\n            operation_type: DmaOperationType::Hash,\n            buffer_size: data.as_mut_slice().len(),\n            status: DmaOperationStatus::Pending,\n        };\n        \n        self.active_operations.push(operation)\n            .map_err(|_| DmaError::TooManyOperations)?;\n        \n        self.dma_tx_channel.start();\n        \n        Ok(operation_id)\n    }\n    \n    fn check_operation_status(&mut self, operation_id: u32) -> Option<DmaOperationStatus> {\n        for operation in &mut self.active_operations {\n            if operation.operation_id == operation_id {\n                // Update status based on DMA and crypto peripheral state\n                if self.dma_tx_channel.has_error() || self.dma_rx_channel.has_error() {\n                    operation.status = DmaOperationStatus::Error(0x01);\n                } else if self.crypto_peripheral.has_error() {\n                    operation.status = DmaOperationStatus::Error(0x02);\n                } else if self.is_operation_complete(operation) {\n                    operation.status = DmaOperationStatus::Complete;\n                } else if self.is_operation_in_progress(operation) {\n                    operation.status = DmaOperationStatus::InProgress;\n                }\n                \n                return Some(operation.status);\n            }\n        }\n        None\n    }\n    \n    fn get_completed_operations(&mut self) -> heapless::Vec<u32, 8> {\n        let mut completed = heapless::Vec::new();\n        \n        // Find completed operations\n        for operation in &self.active_operations {\n            if matches!(operation.status, DmaOperationStatus::Complete) {\n                let _ = completed.push(operation.operation_id);\n            }\n        }\n        \n        // Remove completed operations from active list\n        self.active_operations.retain(|op| !matches!(op.status, DmaOperationStatus::Complete));\n        \n        completed\n    }\n    \n    fn is_operation_complete(&self, operation: &DmaOperation) -> bool {\n        match operation.operation_type {\n            DmaOperationType::Encrypt | DmaOperationType::Decrypt => {\n                self.dma_tx_channel.is_complete() && \n                self.dma_rx_channel.is_complete() && \n                self.crypto_peripheral.is_operation_complete()\n            }\n            DmaOperationType::Hash => {\n                self.dma_tx_channel.is_complete() && \n                self.crypto_peripheral.is_hash_complete()\n            }\n            DmaOperationType::KeyDerivation => {\n                self.crypto_peripheral.is_key_derivation_complete()\n            }\n        }\n    }\n    \n    fn is_operation_in_progress(&self, operation: &DmaOperation) -> bool {\n        match operation.operation_type {\n            DmaOperationType::Encrypt | DmaOperationType::Decrypt => {\n                self.dma_tx_channel.is_active() || \n                self.dma_rx_channel.is_active() || \n                self.crypto_peripheral.is_busy()\n            }\n            DmaOperationType::Hash => {\n                self.dma_tx_channel.is_active() || \n                self.crypto_peripheral.is_busy()\n            }\n            DmaOperationType::KeyDerivation => {\n                self.crypto_peripheral.is_busy()\n            }\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\nenum DmaError {\n    ChannelBusy,\n    InvalidConfiguration,\n    TooManyOperations,\n    HardwareError(u32),\n    BufferAlignment,\n    BufferSize,\n}\n\n#[derive(Clone, Copy)]\nenum HashAlgorithm {\n    Sha256,\n    Sha384,\n    Sha512,\n}\n\n// Interrupt handlers for DMA completion\n#[interrupt]\nfn DMA1_STREAM0() {\n    static mut DMA_CRYPTO: Option<AdvancedDmaCrypto> = None;\n    \n    if let Some(ref mut crypto) = DMA_CRYPTO {\n        // Handle TX DMA completion\n        if crypto.dma_tx_channel.is_complete() {\n            crypto.dma_tx_channel.clear_interrupt_flags();\n            \n            // Check if this completes any operations\n            let completed_ops = crypto.get_completed_operations();\n            for op_id in completed_ops {\n                // Signal completion to main thread\n                signal_operation_complete(op_id);\n            }\n        }\n        \n        if crypto.dma_tx_channel.has_error() {\n            crypto.dma_tx_channel.clear_error_flags();\n            handle_dma_error(DmaError::HardwareError(0x01));\n        }\n    }\n}\n\n#[interrupt]\nfn DMA1_STREAM1() {\n    static mut DMA_CRYPTO: Option<AdvancedDmaCrypto> = None;\n    \n    if let Some(ref mut crypto) = DMA_CRYPTO {\n        // Handle RX DMA completion\n        if crypto.dma_rx_channel.is_complete() {\n            crypto.dma_rx_channel.clear_interrupt_flags();\n            \n            let completed_ops = crypto.get_completed_operations();\n            for op_id in completed_ops {\n                signal_operation_complete(op_id);\n            }\n        }\n        \n        if crypto.dma_rx_channel.has_error() {\n            crypto.dma_rx_channel.clear_error_flags();\n            handle_dma_error(DmaError::HardwareError(0x02));\n        }\n    }\n}\n\n// High-level DMA crypto API\npub struct DmaCryptoManager {\n    dma_crypto: AdvancedDmaCrypto,\n    pending_operations: heapless::FnvIndexMap<u32, DmaBuffer, 8>,\n}\n\nimpl DmaCryptoManager {\n    pub fn new(dma_tx: DmaChannel, dma_rx: DmaChannel, crypto: CryptoPeripheral) -> Self {\n        Self {\n            dma_crypto: AdvancedDmaCrypto::new(dma_tx, dma_rx, crypto),\n            pending_operations: heapless::FnvIndexMap::new(),\n        }\n    }\n    \n    pub fn encrypt_data(&mut self, data: &[u8], key: &[u8; 32]) -> Result<u32, DmaError> {\n        // Allocate appropriate DMA buffer\n        let buffer_size = if data.len() <= 256 { \n            DmaBufferSize::Small \n        } else { \n            DmaBufferSize::Large \n        };\n        \n        let mut buffer = allocate_dma_buffer(buffer_size)\n            .ok_or(DmaError::ChannelBusy)?;\n        \n        // Copy data to DMA buffer\n        if data.len() > buffer.capacity() {\n            return Err(DmaError::BufferSize);\n        }\n        \n        buffer.as_mut_slice()[..data.len()].copy_from_slice(data);\n        \n        // Start async encryption\n        let operation_id = self.dma_crypto.encrypt_async(buffer, key)?;\n        \n        // Track buffer for this operation\n        self.pending_operations.insert(operation_id, buffer)\n            .map_err(|_| DmaError::TooManyOperations)?;\n        \n        Ok(operation_id)\n    }\n    \n    pub fn get_encrypted_data(&mut self, operation_id: u32) -> Option<Result<heapless::Vec<u8, 4096>, DmaError>> {\n        if let Some(status) = self.dma_crypto.check_operation_status(operation_id) {\n            match status {\n                DmaOperationStatus::Complete => {\n                    if let Some(buffer) = self.pending_operations.remove(&operation_id) {\n                        let mut result = heapless::Vec::new();\n                        let _ = result.extend_from_slice(buffer.as_mut_slice());\n                        Some(Ok(result))\n                    } else {\n                        Some(Err(DmaError::InvalidConfiguration))\n                    }\n                }\n                DmaOperationStatus::Error(code) => {\n                    // Clean up failed operation\n                    self.pending_operations.remove(&operation_id);\n                    Some(Err(DmaError::HardwareError(code)))\n                }\n                _ => None, // Still in progress\n            }\n        } else {\n            Some(Err(DmaError::InvalidConfiguration))\n        }\n    }\n}\n\n// Helper functions for interrupt handling\nfn signal_operation_complete(operation_id: u32) {\n    // Implementation would signal main thread about completion\n    // Could use a queue, flag, or other mechanism\n}\n\nfn handle_dma_error(error: DmaError) {\n    // Implementation would handle DMA errors appropriately\n    // Could log, reset, or take other recovery actions\n}",
      "line_number": 3281,
      "section": "Advanced DMA-Safe Memory Management",
      "context": "#### Advanced DMA-Safe Memory Management\n\n```rust\nuse cortex_m::singleton;\nuse core::sync::atomic::{AtomicBool, Ordering};"
    },
    {
      "language": "rust",
      "code": "// Buffer overflow prevention - automatic bounds checking\nfn safe_crypto_buffer_operations() {\n    let mut plaintext = [0u8; 256];\n    let mut ciphertext = [0u8; 256];\n    \n    // This would panic in debug mode, return error in release\n    // No silent buffer overflow like in C\n    let safe_slice = &plaintext[..200]; // Always bounds-checked\n    \n    // Compile-time size verification\n    let key: [u8; 32] = [0; 32];  // Exactly 32 bytes, enforced by type system\n    let nonce: [u8; 12] = [0; 12]; // Exactly 12 bytes for ChaCha20Poly1305\n    \n    // No accidental key/nonce size mismatches\n    encrypt_chacha20poly1305(&key, &nonce, safe_slice, &mut ciphertext[..200]);\n}\n\n// Use-after-free prevention through ownership\nfn secure_key_lifecycle() {\n    let master_key = generate_master_key();\n    let session_keys = derive_session_keys(&master_key);\n    \n    // master_key automatically zeroized when it goes out of scope\n    // No risk of accessing freed key material\n    \n    use_session_keys(session_keys);\n    // session_keys automatically zeroized here\n}\n\n// Double-free prevention - impossible in safe Rust\nfn no_double_free_crypto_contexts() {\n    let crypto_ctx = CryptoContext::new();\n    process_with_context(crypto_ctx); // Ownership transferred\n    // crypto_ctx can't be used again - compile error prevents double-free\n}",
      "line_number": 3770,
      "section": "Memory Safety Advantages for Cryptography",
      "context": "Rust eliminates entire classes of vulnerabilities that plague C cryptographic implementations:\n\n```rust\n// Buffer overflow prevention - automatic bounds checking\nfn safe_crypto_buffer_operations() {"
    },
    {
      "language": "rust",
      "code": "use zeroize::{Zeroize, ZeroizeOnDrop};\n\n// Automatic zeroization for all key material\n#[derive(ZeroizeOnDrop)]\nstruct SessionKeys {\n    encryption_key: [u8; 32],\n    mac_key: [u8; 32],\n    iv: [u8; 16],\n}\n\nimpl SessionKeys {\n    fn derive_from_master(master_key: &[u8; 32], context: &[u8]) -> Self {\n        let mut keys = Self {\n            encryption_key: [0; 32],\n            mac_key: [0; 32],\n            iv: [0; 16],\n        };\n        \n        // HKDF key derivation\n        hkdf_expand(master_key, context, &mut keys.encryption_key, b\"encrypt\");\n        hkdf_expand(master_key, context, &mut keys.mac_key, b\"mac\");\n        hkdf_expand(master_key, context, &mut keys.iv, b\"iv\");\n        \n        keys\n    }\n    \n    fn encrypt_and_mac(&self, plaintext: &[u8]) -> Result<Vec<u8>, CryptoError> {\n        // Encrypt-then-MAC construction\n        let ciphertext = aes_gcm_encrypt(&self.encryption_key, &self.iv, plaintext)?;\n        let mac = hmac_sha256(&self.mac_key, &ciphertext)?;\n        \n        let mut result = Vec::with_capacity(ciphertext.len() + mac.len());\n        result.extend_from_slice(&ciphertext);\n        result.extend_from_slice(&mac);\n        Ok(result)\n    }\n}\n\n// Secure wrapper for sensitive data with automatic cleanup\n#[derive(ZeroizeOnDrop)]\nstruct SecureBuffer<const N: usize> {\n    data: [u8; N],\n    len: usize,\n}\n\nimpl<const N: usize> SecureBuffer<N> {\n    fn new() -> Self {\n        Self {\n            data: [0; N],\n            len: 0,\n        }\n    }\n    \n    fn write(&mut self, bytes: &[u8]) -> Result<(), CryptoError> {\n        if bytes.len() > N - self.len {\n            return Err(CryptoError::BufferTooSmall);\n        }\n        \n        self.data[self.len..self.len + bytes.len()].copy_from_slice(bytes);\n        self.len += bytes.len();\n        Ok(())\n    }\n    \n    fn as_slice(&self) -> &[u8] {\n        &self.data[..self.len]\n    }\n    \n    fn clear(&mut self) {\n        self.data.zeroize();\n        self.len = 0;\n    }\n}\n\n// Usage example - automatic cleanup guaranteed\nfn secure_session_example() {\n    let master_key = [0u8; 32]; // From secure key exchange\n    let session_keys = SessionKeys::derive_from_master(&master_key, b\"session_1\");\n    \n    let mut secure_buffer = SecureBuffer::<1024>::new();\n    secure_buffer.write(b\"secret message\").unwrap();\n    \n    let encrypted = session_keys.encrypt_and_mac(secure_buffer.as_slice()).unwrap();\n    \n    // Both session_keys and secure_buffer automatically zeroized here\n    // No risk of key material remaining in memory\n}",
      "line_number": 3812,
      "section": "Automatic Key Zeroization Patterns",
      "context": "Rust's `Drop` trait provides automatic, guaranteed cleanup of sensitive material:\n\n```rust\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n"
    },
    {
      "language": "rust",
      "code": "use core::marker::PhantomData;\n\n// Protocol states as types\nstruct Uninitialized;\nstruct HandshakeInProgress;\nstruct SessionEstablished;\nstruct Terminated;\n\n// State machine enforced by type system\nstruct SecureChannel<State> {\n    socket: Socket,\n    session_keys: Option<SessionKeys>,\n    sequence_number: u64,\n    state: PhantomData<State>,\n}\n\nimpl SecureChannel<Uninitialized> {\n    fn new(socket: Socket) -> Self {\n        Self {\n            socket,\n            session_keys: None,\n            sequence_number: 0,\n            state: PhantomData,\n        }\n    }\n    \n    // Can only start handshake from uninitialized state\n    fn start_handshake(self) -> SecureChannel<HandshakeInProgress> {\n        SecureChannel {\n            socket: self.socket,\n            session_keys: None,\n            sequence_number: 0,\n            state: PhantomData,\n        }\n    }\n}\n\nimpl SecureChannel<HandshakeInProgress> {\n    // Can only complete handshake from in-progress state\n    fn complete_handshake(self, keys: SessionKeys) -> SecureChannel<SessionEstablished> {\n        SecureChannel {\n            socket: self.socket,\n            session_keys: Some(keys),\n            sequence_number: 0,\n            state: PhantomData,\n        }\n    }\n    \n    // Can abort handshake and return to uninitialized\n    fn abort_handshake(self) -> SecureChannel<Uninitialized> {\n        SecureChannel {\n            socket: self.socket,\n            session_keys: None,\n            sequence_number: 0,\n            state: PhantomData,\n        }\n    }\n}\n\nimpl SecureChannel<SessionEstablished> {\n    // Can only send/receive in established state\n    fn send_encrypted(&mut self, data: &[u8]) -> Result<(), CryptoError> {\n        let keys = self.session_keys.as_ref().unwrap();\n        \n        // Include sequence number to prevent replay attacks\n        let mut message = Vec::with_capacity(data.len() + 8);\n        message.extend_from_slice(&self.sequence_number.to_be_bytes());\n        message.extend_from_slice(data);\n        \n        let encrypted = keys.encrypt_and_mac(&message)?;\n        self.socket.send(&encrypted)?;\n        \n        self.sequence_number += 1;\n        Ok(())\n    }\n    \n    fn receive_encrypted(&mut self) -> Result<Vec<u8>, CryptoError> {\n        let encrypted = self.socket.receive()?;\n        let keys = self.session_keys.as_ref().unwrap();\n        let decrypted = keys.decrypt_and_verify(&encrypted)?;\n        \n        // Verify sequence number\n        if decrypted.len() < 8 {\n            return Err(CryptoError::InvalidMessage);\n        }\n        \n        let received_seq = u64::from_be_bytes(\n            decrypted[..8].try_into().unwrap()\n        );\n        \n        if received_seq != self.sequence_number {\n            return Err(CryptoError::ReplayAttack);\n        }\n        \n        self.sequence_number += 1;\n        Ok(decrypted[8..].to_vec())\n    }\n    \n    // Can terminate session\n    fn terminate(self) -> SecureChannel<Terminated> {\n        SecureChannel {\n            socket: self.socket,\n            session_keys: None, // Keys automatically zeroized\n            sequence_number: 0,\n            state: PhantomData,\n        }\n    }\n}\n\nimpl SecureChannel<Terminated> {\n    // Can only restart from terminated state\n    fn restart(self) -> SecureChannel<Uninitialized> {\n        SecureChannel {\n            socket: self.socket,\n            session_keys: None,\n            sequence_number: 0,\n            state: PhantomData,\n        }\n    }\n}\n\n// Compile-time protocol enforcement example\nfn protocol_state_example() {\n    let socket = Socket::new();\n    let channel = SecureChannel::new(socket);\n    \n    // This compiles - valid state transition\n    let channel = channel.start_handshake();\n    \n    // This would NOT compile - can't send in handshake state\n    // channel.send_encrypted(b\"data\"); // Compile error!\n    \n    let keys = perform_key_exchange();\n    let mut channel = channel.complete_handshake(keys);\n    \n    // Now this compiles - valid in established state\n    channel.send_encrypted(b\"secure data\").unwrap();\n}",
      "line_number": 3905,
      "section": "Type-Safe Protocol State Machines",
      "context": "Rust's type system can enforce protocol correctness at compile time, preventing state machine violations:\n\n```rust\nuse core::marker::PhantomData;\n"
    },
    {
      "language": "rust",
      "code": "// 1. No null pointer dereferences\nfn safe_key_handling(key: Option<&[u8; 32]>) -> Result<Vec<u8>, CryptoError> {\n    // Compiler forces explicit handling of None case\n    let key = key.ok_or(CryptoError::NoKey)?;\n    \n    // No risk of null pointer dereference\n    encrypt_with_key(key)\n}\n\n// 2. Integer overflow protection\nfn safe_buffer_calculations(data_len: usize, overhead: usize) -> Result<Vec<u8>, CryptoError> {\n    // Checked arithmetic prevents integer overflow attacks\n    let total_len = data_len.checked_add(overhead)\n        .ok_or(CryptoError::IntegerOverflow)?;\n    \n    let mut buffer = vec![0u8; total_len];\n    Ok(buffer)\n}\n\n// 3. Initialization safety - no uninitialized memory\nfn safe_crypto_context() -> CryptoContext {\n    // All fields must be explicitly initialized\n    CryptoContext {\n        key_schedule: [0u32; 60],  // Explicitly zeroed\n        rounds: 14,\n        initialized: false,\n    }\n    // No risk of using uninitialized crypto state\n}\n\n// 4. Thread safety for crypto operations\nuse core::sync::atomic::{AtomicU64, Ordering};\n\nstruct ThreadSafeCryptoCounter {\n    counter: AtomicU64,\n}\n\nimpl ThreadSafeCryptoCounter {\n    fn new() -> Self {\n        Self {\n            counter: AtomicU64::new(0),\n        }\n    }\n    \n    // Thread-safe counter for nonces/IVs\n    fn next_nonce(&self) -> u64 {\n        self.counter.fetch_add(1, Ordering::SeqCst)\n    }\n}\n\n// 5. Const generics for compile-time crypto parameters\nstruct CryptoEngine<const KEY_SIZE: usize, const BLOCK_SIZE: usize> {\n    key: [u8; KEY_SIZE],\n    buffer: [u8; BLOCK_SIZE],\n}\n\nimpl<const KEY_SIZE: usize, const BLOCK_SIZE: usize> CryptoEngine<KEY_SIZE, BLOCK_SIZE> {\n    fn new(key: [u8; KEY_SIZE]) -> Self {\n        Self {\n            key,\n            buffer: [0; BLOCK_SIZE],\n        }\n    }\n    \n    // Compile-time verification of buffer sizes\n    fn process_block(&mut self, input: &[u8; BLOCK_SIZE]) -> [u8; BLOCK_SIZE] {\n        // No runtime size checks needed - guaranteed by type system\n        self.buffer.copy_from_slice(input);\n        self.encrypt_buffer();\n        self.buffer\n    }\n    \n    fn encrypt_buffer(&mut self) {\n        // Implementation details...\n    }\n}\n\n// Usage with compile-time size verification\ntype Aes256Engine = CryptoEngine<32, 16>; // AES-256 with 128-bit blocks\ntype ChaCha20Engine = CryptoEngine<32, 64>; // ChaCha20 with 512-bit blocks\n\nfn compile_time_crypto_safety() {\n    let aes_key = [0u8; 32];\n    let mut aes_engine = Aes256Engine::new(aes_key);\n    \n    let plaintext_block = [0u8; 16];\n    let ciphertext = aes_engine.process_block(&plaintext_block);\n    \n    // This would NOT compile - wrong block size\n    // let wrong_block = [0u8; 32];\n    // aes_engine.process_block(&wrong_block); // Compile error!\n}",
      "line_number": 4050,
      "section": "Rust-Specific Security Advantages",
      "context": "Rust provides several unique security advantages over C for cryptographic implementations:\n\n```rust\n// 1. No null pointer dereferences\nfn safe_key_handling(key: Option<&[u8; 32]>) -> Result<Vec<u8>, CryptoError> {"
    },
    {
      "language": "rust",
      "code": "// VULNERABLE: Early return leaks timing information\nfn vulnerable_mac_verify(expected: &[u8], received: &[u8]) -> bool {\n    if expected.len() != received.len() {\n        return false; // Different timing for length mismatch\n    }\n    \n    for (a, b) in expected.iter().zip(received.iter()) {\n        if a != b {\n            return false; // Early return reveals position of first difference\n        }\n    }\n    true\n}\n\n// SECURE: Constant-time comparison\nuse subtle::ConstantTimeEq;\n\nfn secure_mac_verify(expected: &[u8], received: &[u8]) -> bool {\n    if expected.len() != received.len() {\n        return false;\n    }\n    \n    // Always takes same time regardless of input differences\n    expected.ct_eq(received).into()\n}",
      "line_number": 4153,
      "section": "Understanding Side-Channel Vulnerabilities",
      "context": "Side-channel attacks exploit information leaked through execution time, power consumption, or electromagnetic emissions. In embedded systems, timing attacks are particularly dangerous:\n\n```rust\n// VULNERABLE: Early return leaks timing information\nfn vulnerable_mac_verify(expected: &[u8], received: &[u8]) -> bool {"
    },
    {
      "language": "rust",
      "code": "use subtle::{Choice, ConstantTimeEq, ConditionallySelectable, ConstantTimeGreater, ConstantTimeLess};\n\n// Constant-time MAC verification with comprehensive example\nfn verify_hmac_constant_time(\n    key: &[u8; 32],\n    message: &[u8],\n    expected_mac: &[u8; 32],\n    received_mac: &[u8; 32]\n) -> Result<bool, CryptoError> {\n    // Compute expected MAC\n    let computed_mac = hmac_sha256(key, message)?;\n    \n    // Constant-time comparison - always takes same time\n    let mac_valid = computed_mac.ct_eq(received_mac);\n    \n    // Also verify against provided expected MAC\n    let expected_valid = expected_mac.ct_eq(received_mac);\n    \n    // Both must match for verification to succeed\n    Ok((mac_valid & expected_valid).into())\n}\n\n// Constant-time conditional key selection\nfn conditional_key_selection(\n    condition: bool, \n    key_a: &[u8; 32], \n    key_b: &[u8; 32]\n) -> [u8; 32] {\n    let choice = Choice::from(condition as u8);\n    let mut result = [0u8; 32];\n    \n    for i in 0..32 {\n        result[i] = u8::conditional_select(&key_a[i], &key_b[i], choice);\n    }\n    \n    result\n}\n\n// Constant-time table lookup - critical for S-box implementations\nfn constant_time_sbox_lookup(sbox: &[u8; 256], index: u8) -> u8 {\n    let mut result = 0u8;\n    \n    for (i, &value) in sbox.iter().enumerate() {\n        let choice = Choice::from((i as u8 == index) as u8);\n        result = u8::conditional_select(&result, &value, choice);\n    }\n    \n    result\n}\n\n// Constant-time multi-dimensional table lookup\nfn constant_time_matrix_lookup(\n    matrix: &[[u8; 16]; 16], \n    row: u8, \n    col: u8\n) -> u8 {\n    let mut result = 0u8;\n    \n    for (r, row_data) in matrix.iter().enumerate() {\n        let row_choice = Choice::from((r as u8 == row) as u8);\n        \n        for (c, &value) in row_data.iter().enumerate() {\n            let col_choice = Choice::from((c as u8 == col) as u8);\n            let select_choice = row_choice & col_choice;\n            \n            result = u8::conditional_select(&result, &value, select_choice);\n        }\n    }\n    \n    result\n}",
      "line_number": 4185,
      "section": "Using the `subtle` Crate for Constant-Time Operations",
      "context": "The `subtle` crate provides cryptographically secure constant-time operations:\n\n```rust\nuse subtle::{Choice, ConstantTimeEq, ConditionallySelectable, ConstantTimeGreater, ConstantTimeLess};\n"
    },
    {
      "language": "rust",
      "code": "// Constant-time modular arithmetic for ECC operations\nstruct ConstantTimeScalar([u64; 4]); // 256-bit scalar\n\nimpl ConstantTimeScalar {\n    fn new(value: [u64; 4]) -> Self {\n        Self(value)\n    }\n    \n    // Constant-time conditional negation\n    fn conditional_negate(&mut self, choice: Choice) {\n        let mask = u64::conditional_select(&0, &u64::MAX, choice);\n        \n        // XOR with mask (0 or all 1s)\n        for limb in &mut self.0 {\n            *limb ^= mask;\n        }\n        \n        // Add 1 if negating (two's complement)\n        let mut carry = u64::from(choice);\n        for limb in &mut self.0 {\n            let (new_limb, new_carry) = limb.overflowing_add(carry);\n            *limb = new_limb;\n            carry = new_carry as u64;\n        }\n    }\n    \n    // Constant-time conditional addition\n    fn conditional_add(&mut self, other: &Self, choice: Choice) {\n        let mut carry = 0u64;\n        \n        for (a, &b) in self.0.iter_mut().zip(other.0.iter()) {\n            let addend = u64::conditional_select(&0, &b, choice);\n            let (sum, c1) = a.overflowing_add(addend);\n            let (final_sum, c2) = sum.overflowing_add(carry);\n            \n            *a = final_sum;\n            carry = (c1 as u64) + (c2 as u64);\n        }\n    }\n    \n    // Constant-time comparison\n    fn ct_eq(&self, other: &Self) -> Choice {\n        let mut acc = 0u64;\n        for (a, b) in self.0.iter().zip(other.0.iter()) {\n            acc |= a ^ b;\n        }\n        Choice::from((acc == 0) as u8)\n    }\n    \n    // Constant-time greater than comparison\n    fn ct_gt(&self, other: &Self) -> Choice {\n        let mut borrow = 0u64;\n        let mut result = 0u64;\n        \n        for (&a, &b) in self.0.iter().zip(other.0.iter()) {\n            let (diff, b1) = a.overflowing_sub(b);\n            let (final_diff, b2) = diff.overflowing_sub(borrow);\n            \n            result |= final_diff;\n            borrow = (b1 as u64) + (b2 as u64);\n        }\n        \n        Choice::from((borrow == 0 && result != 0) as u8)\n    }\n}\n\n// Constant-time conditional swap for sorting/selection algorithms\nfn conditional_swap_arrays<const N: usize>(\n    condition: Choice,\n    a: &mut [u8; N],\n    b: &mut [u8; N]\n) {\n    for (x, y) in a.iter_mut().zip(b.iter_mut()) {\n        let temp = *x;\n        *x = u8::conditional_select(x, y, condition);\n        *y = u8::conditional_select(y, &temp, condition);\n    }\n}\n\n// Constant-time binary search in sorted array\nfn constant_time_binary_search(\n    sorted_array: &[[u8; 32]],\n    target: &[u8; 32]\n) -> (Choice, usize) {\n    let mut found = Choice::from(0);\n    let mut result_index = 0usize;\n    \n    let mut left = 0;\n    let mut right = sorted_array.len();\n    \n    while left < right {\n        let mid = (left + right) / 2;\n        let mid_value = &sorted_array[mid];\n        \n        let equal = target.ct_eq(mid_value);\n        let less = target.ct_less(mid_value);\n        \n        // Update found flag if equal\n        found = found | equal;\n        \n        // Update result index if equal\n        result_index = usize::conditional_select(&result_index, &mid, equal);\n        \n        // Update search bounds\n        let go_left = less;\n        let go_right = !less & !equal;\n        \n        left = usize::conditional_select(&left, &(mid + 1), go_right);\n        right = usize::conditional_select(&right, &mid, go_left);\n    }\n    \n    (found, result_index)\n}",
      "line_number": 4261,
      "section": "Advanced Constant-Time Patterns",
      "context": "#### Advanced Constant-Time Patterns\n\n```rust\n// Constant-time modular arithmetic for ECC operations\nstruct ConstantTimeScalar([u64; 4]); // 256-bit scalar"
    },
    {
      "language": "rust",
      "code": "// Manual constant-time byte operations\nfn constant_time_memcmp_manual(a: &[u8], b: &[u8]) -> bool {\n    if a.len() != b.len() {\n        return false;\n    }\n    \n    let mut result = 0u8;\n    for (x, y) in a.iter().zip(b.iter()) {\n        result |= x ^ y;\n    }\n    \n    // Convert to bool in constant time\n    result == 0\n}\n\nfn constant_time_select_byte_manual(condition: bool, a: u8, b: u8) -> u8 {\n    // Create mask: true -> 0xFF, false -> 0x00\n    let mask = (condition as u8).wrapping_neg();\n    (a & mask) | (b & !mask)\n}\n\n// Constant-time find maximum without branching\nfn constant_time_max_u32(a: u32, b: u32) -> u32 {\n    let diff = a.wrapping_sub(b);\n    let mask = (diff >> 31).wrapping_neg(); // Extract sign bit\n    \n    // If a >= b, mask is 0x00000000, else 0xFFFFFFFF\n    (a & !mask) | (b & mask)\n}\n\n// Constant-time absolute value\nfn constant_time_abs_i32(x: i32) -> u32 {\n    let mask = (x >> 31) as u32; // Sign extension: 0x00000000 or 0xFFFFFFFF\n    ((x as u32) ^ mask).wrapping_sub(mask)\n}\n\n// Constant-time conditional increment\nfn constant_time_conditional_increment(value: &mut u32, condition: bool) {\n    let increment = condition as u32;\n    *value = value.wrapping_add(increment);\n}",
      "line_number": 4381,
      "section": "Manual Constant-Time Implementations",
      "context": "For cases where the `subtle` crate isn't available or you need custom operations:\n\n```rust\n// Manual constant-time byte operations\nfn constant_time_memcmp_manual(a: &[u8], b: &[u8]) -> bool {"
    },
    {
      "language": "rust",
      "code": "// Disable compiler optimizations that might break constant-time properties\nuse core::hint::black_box;\n\nfn protected_constant_time_operation(secret: &[u8; 32], public: &[u8; 32]) -> [u8; 32] {\n    let mut result = [0u8; 32];\n    \n    // Use black_box to prevent compiler from optimizing away operations\n    for i in 0..32 {\n        let secret_byte = black_box(secret[i]);\n        let public_byte = black_box(public[i]);\n        \n        result[i] = secret_byte ^ public_byte;\n        \n        // Prevent compiler from reordering operations\n        black_box(&result[i]);\n    }\n    \n    result\n}\n\n// Memory access patterns that resist cache timing attacks\nfn cache_resistant_lookup(table: &[u8; 256], index: u8) -> u8 {\n    let mut result = 0u8;\n    \n    // Access every table entry to maintain consistent cache behavior\n    for (i, &value) in table.iter().enumerate() {\n        let mask = ((i as u8 == index) as u8).wrapping_neg();\n        result |= value & mask;\n        \n        // Ensure memory access happens\n        black_box(value);\n    }\n    \n    result\n}\n\n// Constant-time operations with hardware considerations\n#[cfg(feature = \"hw_crypto\")]\nfn hardware_constant_time_aes(key: &[u8; 32], plaintext: &[u8; 16]) -> [u8; 16] {\n    // Use hardware AES if available - inherently constant-time\n    hardware_aes_encrypt(key, plaintext)\n}\n\n#[cfg(not(feature = \"hw_crypto\"))]\nfn software_constant_time_aes(key: &[u8; 32], plaintext: &[u8; 16]) -> [u8; 16] {\n    // Software implementation with constant-time guarantees\n    let mut state = *plaintext;\n    let key_schedule = aes_key_expansion_ct(key);\n    \n    // All operations must be constant-time\n    for round_key in key_schedule.iter() {\n        aes_round_ct(&mut state, round_key);\n    }\n    \n    state\n}\n\n// Timing measurement for validation (debug builds only)\n#[cfg(debug_assertions)]\nfn validate_constant_time_property<F>(operation: F, iterations: usize) \nwhere \n    F: Fn() -> ()\n{\n    use cortex_m::peripheral::DWT;\n    \n    let mut timings = heapless::Vec::<u32, 1000>::new();\n    \n    for _ in 0..iterations {\n        let start = DWT::cycle_count();\n        operation();\n        let end = DWT::cycle_count();\n        \n        timings.push(end.wrapping_sub(start)).ok();\n    }\n    \n    // Analyze timing variance\n    let mean = timings.iter().sum::<u32>() / timings.len() as u32;\n    let variance = timings.iter()\n        .map(|&t| (t as i64 - mean as i64).pow(2))\n        .sum::<i64>() / timings.len() as i64;\n    \n    // Low variance indicates constant-time behavior\n    assert!(variance < 100, \"High timing variance detected: {}\", variance);\n}",
      "line_number": 4427,
      "section": "Embedded-Specific Constant-Time Considerations",
      "context": "#### Embedded-Specific Constant-Time Considerations\n\n```rust\n// Disable compiler optimizations that might break constant-time properties\nuse core::hint::black_box;"
    },
    {
      "language": "rust",
      "code": "use zeroize::{Zeroize, ZeroizeOnDrop};\n\n// Secure key wrapper with automatic cleanup\n#[derive(ZeroizeOnDrop)]\nstruct SecureKey<const N: usize> {\n    key_material: [u8; N],\n    key_id: u32,\n    created_at: u64,\n}\n\nimpl<const N: usize> SecureKey<N> {\n    fn new(key_data: [u8; N], id: u32) -> Self {\n        Self {\n            key_material: key_data,\n            key_id: id,\n            created_at: get_timestamp(),\n        }\n    }\n    \n    fn as_bytes(&self) -> &[u8; N] {\n        &self.key_material\n    }\n    \n    fn key_id(&self) -> u32 {\n        self.key_id\n    }\n    \n    fn age(&self) -> u64 {\n        get_timestamp() - self.created_at\n    }\n    \n    // Manual zeroization if needed before drop\n    fn zeroize_now(&mut self) {\n        self.key_material.zeroize();\n        self.key_id = 0;\n        self.created_at = 0;\n    }\n}\n\n// Usage example - automatic cleanup guaranteed\nfn process_encrypted_message(encrypted_data: &[u8]) -> Result<Vec<u8>, CryptoError> {\n    // Key automatically zeroized when function exits\n    let session_key = SecureKey::<32>::new(derive_session_key()?, 1);\n    \n    // Use key for decryption\n    let plaintext = decrypt_aes_gcm(session_key.as_bytes(), encrypted_data)?;\n    \n    // Verify message integrity\n    if !verify_message_integrity(&plaintext) {\n        return Err(CryptoError::IntegrityCheckFailed);\n    }\n    \n    Ok(plaintext)\n    // session_key automatically zeroized here, even if error occurred\n}",
      "line_number": 4522,
      "section": "Automatic Key Zeroization Patterns",
      "context": "Rust's `Drop` trait ensures that sensitive data is automatically cleared when it goes out of scope, preventing key material from lingering in memory:\n\n```rust\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n"
    },
    {
      "language": "rust",
      "code": "use hkdf::Hkdf;\nuse sha2::Sha256;\nuse heapless::FnvIndexMap;\n\n#[derive(ZeroizeOnDrop)]\nstruct KeyHierarchy {\n    master_key: SecureKey<32>,\n    derived_keys: FnvIndexMap<&'static str, SecureKey<32>, 16>,\n    derivation_counter: u32,\n}\n\nimpl KeyHierarchy {\n    fn new(master_key_data: [u8; 32]) -> Self {\n        Self {\n            master_key: SecureKey::new(master_key_data, 0),\n            derived_keys: FnvIndexMap::new(),\n            derivation_counter: 0,\n        }\n    }\n    \n    fn derive_key(&mut self, purpose: &'static str) -> Result<&SecureKey<32>, CryptoError> {\n        // Check if key already exists\n        if self.derived_keys.contains_key(purpose) {\n            return Ok(&self.derived_keys[purpose]);\n        }\n        \n        // Derive new key using HKDF\n        let hk = Hkdf::<Sha256>::new(None, self.master_key.as_bytes());\n        let mut derived = [0u8; 32];\n        \n        // Include counter to ensure unique derivation\n        let info = format_args!(\"{}:{}\", purpose, self.derivation_counter);\n        let info_bytes = format!(\"{}\", info);\n        \n        hk.expand(info_bytes.as_bytes(), &mut derived)\n            .map_err(|_| CryptoError::KeyDerivationFailed)?;\n        \n        // Store derived key with automatic cleanup\n        self.derivation_counter += 1;\n        let secure_key = SecureKey::new(derived, self.derivation_counter);\n        \n        self.derived_keys.insert(purpose, secure_key)\n            .map_err(|_| CryptoError::TooManyKeys)?;\n        \n        Ok(&self.derived_keys[purpose])\n    }\n    \n    fn get_encryption_key(&mut self) -> Result<&SecureKey<32>, CryptoError> {\n        self.derive_key(\"encryption\")\n    }\n    \n    fn get_mac_key(&mut self) -> Result<&SecureKey<32>, CryptoError> {\n        self.derive_key(\"authentication\")\n    }\n    \n    fn get_key_wrapping_key(&mut self) -> Result<&SecureKey<32>, CryptoError> {\n        self.derive_key(\"key_wrapping\")\n    }\n    \n    fn rotate_master_key(&mut self, new_master: [u8; 32]) {\n        // Clear all derived keys (automatically zeroized)\n        self.derived_keys.clear();\n        \n        // Update master key (old one automatically zeroized)\n        self.master_key = SecureKey::new(new_master, 0);\n        self.derivation_counter = 0;\n    }\n    \n    fn clear_derived_keys(&mut self) {\n        // Explicitly clear derived keys while keeping master\n        self.derived_keys.clear();\n    }\n    \n    fn key_count(&self) -> usize {\n        self.derived_keys.len()\n    }\n}\n\n// Usage example with automatic cleanup\nfn secure_session_example() -> Result<(), CryptoError> {\n    // Master key automatically zeroized when hierarchy is dropped\n    let master_key_data = generate_master_key()?;\n    let mut key_hierarchy = KeyHierarchy::new(master_key_data);\n    \n    // Derive session keys\n    let enc_key = key_hierarchy.get_encryption_key()?;\n    let mac_key = key_hierarchy.get_mac_key()?;\n    \n    // Use keys for secure communication\n    let message = b\"secure message\";\n    let encrypted = encrypt_and_mac(enc_key.as_bytes(), mac_key.as_bytes(), message)?;\n    \n    // Process multiple messages with same keys\n    for i in 0..10 {\n        let msg = format!(\"message {}\", i);\n        let encrypted = encrypt_and_mac(enc_key.as_bytes(), mac_key.as_bytes(), msg.as_bytes())?;\n        transmit_encrypted_message(&encrypted)?;\n    }\n    \n    // All keys automatically zeroized when key_hierarchy is dropped\n    Ok(())\n}",
      "line_number": 4582,
      "section": "Hierarchical Key Derivation with Automatic Cleanup",
      "context": "#### Hierarchical Key Derivation with Automatic Cleanup\n\n```rust\nuse hkdf::Hkdf;\nuse sha2::Sha256;"
    },
    {
      "language": "rust",
      "code": "use rand_core::{RngCore, CryptoRng, Error as RngError};\n\n// Hardware RNG wrapper with error handling and health checks\nstruct HardwareRng {\n    rng_peripheral: RngPeripheral,\n    health_check_counter: u32,\n    last_health_check: u64,\n}\n\nimpl HardwareRng {\n    fn new(rng_peripheral: RngPeripheral) -> Result<Self, CryptoError> {\n        let mut rng = Self {\n            rng_peripheral,\n            health_check_counter: 0,\n            last_health_check: 0,\n        };\n        \n        // Initial health check\n        rng.perform_health_check()?;\n        Ok(rng)\n    }\n    \n    fn perform_health_check(&mut self) -> Result<(), CryptoError> {\n        // Check if hardware RNG is functioning properly\n        if !self.rng_peripheral.is_available() {\n            return Err(CryptoError::RngNotAvailable);\n        }\n        \n        // Perform statistical tests on random output\n        let mut test_data = [0u8; 256];\n        self.fill_bytes_internal(&mut test_data)?;\n        \n        // Simple entropy test - check for obvious patterns\n        let mut zero_count = 0;\n        let mut one_count = 0;\n        \n        for &byte in &test_data {\n            zero_count += (byte == 0) as u32;\n            one_count += byte.count_ones();\n        }\n        \n        // Rough entropy check - should be roughly balanced\n        if zero_count > 20 || one_count < 900 || one_count > 1100 {\n            return Err(CryptoError::RngHealthCheckFailed);\n        }\n        \n        self.last_health_check = get_timestamp();\n        Ok(())\n    }\n    \n    fn fill_bytes_internal(&mut self, dest: &mut [u8]) -> Result<(), CryptoError> {\n        // Periodic health checks\n        self.health_check_counter += 1;\n        if self.health_check_counter % 1000 == 0 {\n            self.perform_health_check()?;\n        }\n        \n        for chunk in dest.chunks_mut(4) {\n            // Wait for hardware RNG to be ready with timeout\n            let mut timeout = 10000;\n            while !self.rng_peripheral.is_ready() && timeout > 0 {\n                cortex_m::asm::nop();\n                timeout -= 1;\n            }\n            \n            if timeout == 0 {\n                return Err(CryptoError::RngTimeout);\n            }\n            \n            let random = self.rng_peripheral.read_random();\n            let bytes = random.to_le_bytes();\n            \n            for (i, &byte) in bytes.iter().enumerate() {\n                if i < chunk.len() {\n                    chunk[i] = byte;\n                }\n            }\n        }\n        \n        Ok(())\n    }\n}\n\nimpl RngCore for HardwareRng {\n    fn next_u32(&mut self) -> u32 {\n        let mut bytes = [0u8; 4];\n        self.fill_bytes(&mut bytes);\n        u32::from_le_bytes(bytes)\n    }\n    \n    fn next_u64(&mut self) -> u64 {\n        let mut bytes = [0u8; 8];\n        self.fill_bytes(&mut bytes);\n        u64::from_le_bytes(bytes)\n    }\n    \n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        self.try_fill_bytes(dest).expect(\"Hardware RNG failure\")\n    }\n    \n    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), RngError> {\n        self.fill_bytes_internal(dest)\n            .map_err(|_| RngError::new(\"Hardware RNG error\"))\n    }\n}\n\nimpl CryptoRng for HardwareRng {}\n\n// Secure key generation with hardware RNG\nfn generate_session_keys(rng: &mut impl CryptoRng) -> Result<SessionKeys, CryptoError> {\n    let mut master_key = [0u8; 32];\n    rng.try_fill_bytes(&mut master_key)\n        .map_err(|_| CryptoError::RngFailed)?;\n    \n    // Derive session keys from master key\n    let session_keys = SessionKeys::derive_from_master(&master_key, b\"session\")?;\n    \n    // Clear master key from stack\n    master_key.zeroize();\n    \n    Ok(session_keys)\n}\n\n// Key generation with entropy mixing\nfn generate_mixed_entropy_key(hw_rng: &mut HardwareRng) -> Result<SecureKey<32>, CryptoError> {\n    // Collect entropy from multiple sources\n    let mut hw_entropy = [0u8; 32];\n    let mut timing_entropy = [0u8; 32];\n    \n    // Hardware entropy\n    hw_rng.try_fill_bytes(&mut hw_entropy)\n        .map_err(|_| CryptoError::RngFailed)?;\n    \n    // Timing-based entropy (less reliable but adds diversity)\n    for i in 0..32 {\n        let start = get_cycle_count();\n        cortex_m::asm::nop();\n        let end = get_cycle_count();\n        timing_entropy[i] = (end.wrapping_sub(start) & 0xFF) as u8;\n    }\n    \n    // Mix entropy sources using HKDF\n    let hk = Hkdf::<Sha256>::new(Some(&timing_entropy), &hw_entropy);\n    let mut mixed_key = [0u8; 32];\n    hk.expand(b\"mixed_entropy_key\", &mut mixed_key)\n        .map_err(|_| CryptoError::KeyDerivationFailed)?;\n    \n    // Clear intermediate entropy\n    hw_entropy.zeroize();\n    timing_entropy.zeroize();\n    \n    Ok(SecureKey::new(mixed_key, 1))\n}",
      "line_number": 4689,
      "section": "Secure Random Number Generation with Hardware Integration",
      "context": "#### Secure Random Number Generation with Hardware Integration\n\n```rust\nuse rand_core::{RngCore, CryptoRng, Error as RngError};\n"
    },
    {
      "language": "rust",
      "code": "use core::time::Duration;\n\n#[derive(ZeroizeOnDrop)]\nstruct ManagedKey<const N: usize> {\n    key: SecureKey<N>,\n    max_age: Duration,\n    max_uses: u32,\n    current_uses: u32,\n    created_at: u64,\n}\n\nimpl<const N: usize> ManagedKey<N> {\n    fn new(key_data: [u8; N], max_age: Duration, max_uses: u32) -> Self {\n        Self {\n            key: SecureKey::new(key_data, 1),\n            max_age,\n            max_uses,\n            current_uses: 0,\n            created_at: get_timestamp(),\n        }\n    }\n    \n    fn is_valid(&self) -> bool {\n        let age = Duration::from_millis(get_timestamp() - self.created_at);\n        age < self.max_age && self.current_uses < self.max_uses\n    }\n    \n    fn use_key(&mut self) -> Result<&[u8; N], CryptoError> {\n        if !self.is_valid() {\n            return Err(CryptoError::KeyExpired);\n        }\n        \n        self.current_uses += 1;\n        Ok(self.key.as_bytes())\n    }\n    \n    fn remaining_uses(&self) -> u32 {\n        self.max_uses.saturating_sub(self.current_uses)\n    }\n    \n    fn time_until_expiry(&self) -> Duration {\n        let age = Duration::from_millis(get_timestamp() - self.created_at);\n        self.max_age.saturating_sub(age)\n    }\n}\n\n// Key rotation manager\n#[derive(ZeroizeOnDrop)]\nstruct KeyRotationManager {\n    current_key: Option<ManagedKey<32>>,\n    next_key: Option<ManagedKey<32>>,\n    rng: HardwareRng,\n}\n\nimpl KeyRotationManager {\n    fn new(mut rng: HardwareRng) -> Result<Self, CryptoError> {\n        let initial_key = Self::generate_new_key(&mut rng)?;\n        \n        Ok(Self {\n            current_key: Some(initial_key),\n            next_key: None,\n            rng,\n        })\n    }\n    \n    fn generate_new_key(rng: &mut HardwareRng) -> Result<ManagedKey<32>, CryptoError> {\n        let mut key_data = [0u8; 32];\n        rng.try_fill_bytes(&mut key_data)\n            .map_err(|_| CryptoError::RngFailed)?;\n        \n        // Keys valid for 1 hour or 10000 uses\n        let max_age = Duration::from_secs(3600);\n        let max_uses = 10000;\n        \n        Ok(ManagedKey::new(key_data, max_age, max_uses))\n    }\n    \n    fn get_current_key(&mut self) -> Result<&[u8; 32], CryptoError> {\n        // Check if current key needs rotation\n        if let Some(ref current) = self.current_key {\n            if !current.is_valid() {\n                self.rotate_keys()?;\n            }\n        } else {\n            return Err(CryptoError::NoValidKey);\n        }\n        \n        // Prepare next key if needed\n        if self.next_key.is_none() {\n            self.next_key = Some(Self::generate_new_key(&mut self.rng)?);\n        }\n        \n        self.current_key.as_mut().unwrap().use_key()\n    }\n    \n    fn rotate_keys(&mut self) -> Result<(), CryptoError> {\n        // Move next key to current\n        if let Some(next_key) = self.next_key.take() {\n            self.current_key = Some(next_key);\n        } else {\n            // Generate new key if no next key available\n            self.current_key = Some(Self::generate_new_key(&mut self.rng)?);\n        }\n        \n        // Generate new next key\n        self.next_key = Some(Self::generate_new_key(&mut self.rng)?);\n        \n        Ok(())\n    }\n    \n    fn force_rotation(&mut self) -> Result<(), CryptoError> {\n        self.current_key = None; // Force rotation on next access\n        self.get_current_key().map(|_| ())\n    }\n}\n\n// Usage example with automatic key management\nfn managed_encryption_example() -> Result<(), CryptoError> {\n    let hw_rng = HardwareRng::new(get_rng_peripheral())?;\n    let mut key_manager = KeyRotationManager::new(hw_rng)?;\n    \n    // Process messages with automatic key rotation\n    for i in 0..15000 {\n        let message = format!(\"message {}\", i);\n        \n        // Key automatically rotated when needed\n        let key = key_manager.get_current_key()?;\n        let encrypted = encrypt_message(key, message.as_bytes())?;\n        \n        transmit_encrypted_message(&encrypted)?;\n        \n        // Force rotation every 5000 messages for testing\n        if i % 5000 == 0 {\n            key_manager.force_rotation()?;\n        }\n    }\n    \n    // All keys automatically zeroized when key_manager is dropped\n    Ok(())\n}",
      "line_number": 4847,
      "section": "Key Lifecycle Management",
      "context": "#### Key Lifecycle Management\n\n```rust\nuse core::time::Duration;\n"
    },
    {
      "language": "rust",
      "code": "// Generic trait for crypto acceleration\ntrait CryptoAccelerator {\n    type Error;\n    \n    fn aes_encrypt(&mut self, key: &[u8; 32], plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), Self::Error>;\n    fn aes_decrypt(&mut self, key: &[u8; 32], ciphertext: &[u8], plaintext: &mut [u8]) -> Result<(), Self::Error>;\n    fn sha256(&mut self, data: &[u8], hash: &mut [u8; 32]) -> Result<(), Self::Error>;\n}\n\n// Hardware implementation for Xilinx\nstruct XilinxCryptoAccel {\n    aes_engine: XilinxAesEngine,\n    hash_engine: XilinxHashEngine,\n}\n\nimpl CryptoAccelerator for XilinxCryptoAccel {\n    type Error = HardwareError;\n    \n    fn aes_encrypt(&mut self, key: &[u8; 32], plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), Self::Error> {\n        self.aes_engine.load_key(key)?;\n        self.aes_engine.encrypt(plaintext, ciphertext)?;\n        Ok(())\n    }\n    \n    fn sha256(&mut self, data: &[u8], hash: &mut [u8; 32]) -> Result<(), Self::Error> {\n        self.hash_engine.hash_sha256(data, hash)\n    }\n    \n    // ... other implementations\n}\n\n// Software fallback\nstruct SoftwareCrypto;\n\nimpl CryptoAccelerator for SoftwareCrypto {\n    type Error = CryptoError;\n    \n    fn aes_encrypt(&mut self, key: &[u8; 32], plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), Self::Error> {\n        // Use software AES implementation\n        software_aes_encrypt(key, plaintext, ciphertext)\n    }\n    \n    fn sha256(&mut self, data: &[u8], hash: &mut [u8; 32]) -> Result<(), Self::Error> {\n        use sha2::{Sha256, Digest};\n        let mut hasher = Sha256::new();\n        hasher.update(data);\n        hash.copy_from_slice(&hasher.finalize());\n        Ok(())\n    }\n    \n    // ... other implementations\n}\n\n// Adaptive crypto engine\nenum CryptoEngine {\n    Hardware(XilinxCryptoAccel),\n    Software(SoftwareCrypto),\n}\n\nimpl CryptoEngine {\n    fn new() -> Self {\n        // Try to initialize hardware acceleration\n        if let Ok(hw_accel) = XilinxCryptoAccel::new() {\n            CryptoEngine::Hardware(hw_accel)\n        } else {\n            CryptoEngine::Software(SoftwareCrypto)\n        }\n    }\n    \n    fn encrypt_aes(&mut self, key: &[u8; 32], plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), Box<dyn core::error::Error>> {\n        match self {\n            CryptoEngine::Hardware(hw) => hw.aes_encrypt(key, plaintext, ciphertext).map_err(|e| Box::new(e) as Box<dyn core::error::Error>),\n            CryptoEngine::Software(sw) => sw.aes_encrypt(key, plaintext, ciphertext).map_err(|e| Box::new(e) as Box<dyn core::error::Error>),\n        }\n    }\n}",
      "line_number": 4996,
      "section": "Generic Hardware Abstraction",
      "context": "#### Generic Hardware Abstraction\n\n```rust\n// Generic trait for crypto acceleration\ntrait CryptoAccelerator {"
    },
    {
      "language": "rust",
      "code": "// Randomized execution timing\nfn randomized_delay(rng: &mut impl RngCore) {\n    let delay_cycles = rng.next_u32() & 0xFF; // 0-255 cycles\n    for _ in 0..delay_cycles {\n        cortex_m::asm::nop();\n    }\n}\n\n// Blinded operations\nfn blinded_scalar_multiply(scalar: &[u8; 32], point: &EccPoint, rng: &mut impl RngCore) -> EccPoint {\n    // Generate random blinding factor\n    let mut blind = [0u8; 32];\n    rng.fill_bytes(&mut blind);\n    \n    // Blind the scalar\n    let blinded_scalar = scalar_add(scalar, &blind);\n    \n    // Perform blinded operation\n    let blinded_result = scalar_multiply(&blinded_scalar, point);\n    \n    // Remove blinding\n    let blind_point = scalar_multiply(&blind, point);\n    point_subtract(&blinded_result, &blind_point)\n}\n\n// Constant-time table lookups with dummy operations\nfn protected_table_lookup(table: &[[u8; 32]], index: usize, rng: &mut impl RngCore) -> [u8; 32] {\n    let mut result = [0u8; 32];\n    \n    // Perform dummy operations to mask the real lookup\n    let dummy_index = rng.next_u32() as usize % table.len();\n    let mut dummy_result = [0u8; 32];\n    \n    for (i, entry) in table.iter().enumerate() {\n        let real_choice = Choice::from((i == index) as u8);\n        let dummy_choice = Choice::from((i == dummy_index) as u8);\n        \n        // Real lookup\n        for j in 0..32 {\n            result[j] = u8::conditional_select(&result[j], &entry[j], real_choice);\n        }\n        \n        // Dummy lookup (result discarded)\n        for j in 0..32 {\n            dummy_result[j] = u8::conditional_select(&dummy_result[j], &entry[j], dummy_choice);\n        }\n    }\n    \n    result\n}",
      "line_number": 5081,
      "section": "Power Analysis Protection",
      "context": "#### Power Analysis Protection\n\n```rust\n// Randomized execution timing\nfn randomized_delay(rng: &mut impl RngCore) {"
    },
    {
      "language": "rust",
      "code": "// Step 2a: Create Rust implementation of AES\n// Original C: aes.c, aes.h\n// New Rust: crypto/aes.rs\n\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n\n#[derive(ZeroizeOnDrop)]\npub struct AesContext {\n    key_schedule: [u32; 60],\n    rounds: usize,\n}\n\nimpl AesContext {\n    pub fn new(key: &[u8]) -> Result<Self, CryptoError> {\n        let mut ctx = Self {\n            key_schedule: [0; 60],\n            rounds: match key.len() {\n                16 => 10,\n                24 => 12,\n                32 => 14,\n                _ => return Err(CryptoError::InvalidKeySize),\n            },\n        };\n        \n        aes_key_expansion(key, &mut ctx.key_schedule, ctx.rounds)?;\n        Ok(ctx)\n    }\n    \n    pub fn encrypt_block(&self, input: &[u8; 16]) -> [u8; 16] {\n        let mut output = [0u8; 16];\n        aes_encrypt_block(input, &mut output, &self.key_schedule, self.rounds);\n        output\n    }\n    \n    pub fn decrypt_block(&self, input: &[u8; 16]) -> [u8; 16] {\n        let mut output = [0u8; 16];\n        aes_decrypt_block(input, &mut output, &self.key_schedule, self.rounds);\n        output\n    }\n}\n\n// Step 2b: Create C-compatible interface for gradual migration\n#[no_mangle]\npub extern \"C\" fn aes_context_new(key: *const u8, key_len: usize) -> *mut AesContext {\n    if key.is_null() || key_len == 0 {\n        return core::ptr::null_mut();\n    }\n    \n    let key_slice = unsafe { core::slice::from_raw_parts(key, key_len) };\n    \n    match AesContext::new(key_slice) {\n        Ok(ctx) => Box::into_raw(Box::new(ctx)),\n        Err(_) => core::ptr::null_mut(),\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn aes_context_free(ctx: *mut AesContext) {\n    if !ctx.is_null() {\n        unsafe {\n            let _ = Box::from_raw(ctx); // Automatic zeroization via Drop\n        }\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn aes_encrypt_block_c(\n    ctx: *const AesContext,\n    input: *const u8,\n    output: *mut u8,\n) -> i32 {\n    if ctx.is_null() || input.is_null() || output.is_null() {\n        return -1;\n    }\n    \n    unsafe {\n        let ctx = &*ctx;\n        let input_block = core::slice::from_raw_parts(input, 16);\n        let output_block = core::slice::from_raw_parts_mut(output, 16);\n        \n        let input_array: [u8; 16] = match input_block.try_into() {\n            Ok(arr) => arr,\n            Err(_) => return -1,\n        };\n        \n        let result = ctx.encrypt_block(&input_array);\n        output_block.copy_from_slice(&result);\n    }\n    \n    0 // Success\n}\n\n// Step 2c: Update C code to use new Rust implementation\n// In your C files, replace direct AES calls:\n/*\n// Old C code:\nAES_KEY aes_key;\nAES_set_encrypt_key(key, 256, &aes_key);\nAES_encrypt(plaintext, ciphertext, &aes_key);\n\n// New C code using Rust backend:\nvoid* aes_ctx = aes_context_new(key, 32);\nif (aes_ctx) {\n    aes_encrypt_block_c(aes_ctx, plaintext, ciphertext);\n    aes_context_free(aes_ctx);\n}\n*/",
      "line_number": 5173,
      "section": "Step 2: Module-by-Module Migration",
      "context": "**Starting with Crypto Primitives (Lowest Risk)**\n\n```rust\n// Step 2a: Create Rust implementation of AES\n// Original C: aes.c, aes.h"
    },
    {
      "language": "rust",
      "code": "// Step 3a: Define external C crypto functions still in use\nextern \"C\" {\n    fn c_aes_gcm_encrypt(\n        key: *const u8, key_len: usize,\n        iv: *const u8, iv_len: usize,\n        plaintext: *const u8, plaintext_len: usize,\n        ciphertext: *mut u8,\n        tag: *mut u8\n    ) -> i32;\n    \n    fn c_hmac_sha256(\n        key: *const u8, key_len: usize,\n        data: *const u8, data_len: usize,\n        mac: *mut u8\n    ) -> i32;\n    \n    fn c_ecdsa_sign(\n        private_key: *const u8,\n        message_hash: *const u8,\n        signature: *mut u8\n    ) -> i32;\n}\n\n// Step 3b: Implement protocol logic in Rust using C crypto\n#[derive(Debug)]\npub enum TlsError {\n    EncryptionFailed,\n    MacFailed,\n    SignatureFailed,\n    InvalidState,\n}\n\npub struct HybridTlsConnection {\n    state: TlsState,\n    session_keys: SessionKeys,\n    sequence_number: u64,\n}\n\nimpl HybridTlsConnection {\n    pub fn new(master_secret: &[u8; 48]) -> Result<Self, TlsError> {\n        let session_keys = derive_session_keys(master_secret)?;\n        \n        Ok(Self {\n            state: TlsState::Connected,\n            session_keys,\n            sequence_number: 0,\n        })\n    }\n    \n    pub fn encrypt_record(&mut self, record_type: u8, data: &[u8]) -> Result<Vec<u8>, TlsError> {\n        // Step 3c: Use Rust for protocol logic, C for crypto operations\n        let sequence_bytes = self.sequence_number.to_be_bytes();\n        let mut iv = [0u8; 12];\n        iv[4..].copy_from_slice(&sequence_bytes);\n        \n        let mut ciphertext = vec![0u8; data.len()];\n        let mut tag = [0u8; 16];\n        \n        // Use C crypto function temporarily during migration\n        let result = unsafe {\n            c_aes_gcm_encrypt(\n                self.session_keys.encryption_key.as_ptr(),\n                self.session_keys.encryption_key.len(),\n                iv.as_ptr(),\n                iv.len(),\n                data.as_ptr(),\n                data.len(),\n                ciphertext.as_mut_ptr(),\n                tag.as_mut_ptr(),\n            )\n        };\n        \n        if result != 0 {\n            return Err(TlsError::EncryptionFailed);\n        }\n        \n        // Rust-based record formatting (gradually migrating)\n        let mut record = Vec::with_capacity(5 + ciphertext.len() + tag.len());\n        record.push(record_type);\n        record.extend_from_slice(&[0x03, 0x03]); // TLS 1.2\n        record.extend_from_slice(&((ciphertext.len() + tag.len()) as u16).to_be_bytes());\n        record.extend_from_slice(&ciphertext);\n        record.extend_from_slice(&tag);\n        \n        self.sequence_number += 1;\n        Ok(record)\n    }\n    \n    pub fn decrypt_record(&mut self, record: &[u8]) -> Result<Vec<u8>, TlsError> {\n        if record.len() < 21 { // Minimum record size\n            return Err(TlsError::InvalidState);\n        }\n        \n        let payload_len = u16::from_be_bytes([record[3], record[4]]) as usize;\n        let ciphertext = &record[5..5 + payload_len - 16];\n        let tag = &record[5 + payload_len - 16..5 + payload_len];\n        \n        // Implementation continues with C crypto calls...\n        // This allows testing new protocol logic with proven crypto\n        \n        Ok(vec![]) // Placeholder\n    }\n}\n\n// Step 3d: Session key derivation in pure Rust (lower risk)\nfn derive_session_keys(master_secret: &[u8; 48]) -> Result<SessionKeys, TlsError> {\n    use sha2::{Sha256, Digest};\n    \n    let mut hasher = Sha256::new();\n    hasher.update(b\"key expansion\");\n    hasher.update(master_secret);\n    let key_material = hasher.finalize();\n    \n    Ok(SessionKeys {\n        encryption_key: key_material[0..32].try_into().unwrap(),\n        mac_key: key_material[32..64].try_into().unwrap(),\n    })\n}\n\n#[derive(ZeroizeOnDrop)]\nstruct SessionKeys {\n    encryption_key: [u8; 32],\n    mac_key: [u8; 32],\n}\n\n#[derive(Debug, PartialEq)]\nenum TlsState {\n    Handshake,\n    Connected,\n    Closed,\n}",
      "line_number": 5287,
      "section": "Step 3: Protocol-Level Migration",
      "context": "**Migrating Higher-Level Protocols While Keeping Proven Crypto**\n\n```rust\n// Step 3a: Define external C crypto functions still in use\nextern \"C\" {"
    },
    {
      "language": "rust",
      "code": "// Step 4a: Create high-level application interface\npub struct SecureCommunicationManager {\n    connections: heapless::FnvIndexMap<u32, HybridTlsConnection, 16>,\n    next_connection_id: u32,\n}\n\nimpl SecureCommunicationManager {\n    pub fn new() -> Self {\n        Self {\n            connections: heapless::FnvIndexMap::new(),\n            next_connection_id: 1,\n        }\n    }\n    \n    pub fn create_connection(&mut self, master_secret: &[u8; 48]) -> Result<u32, TlsError> {\n        let connection = HybridTlsConnection::new(master_secret)?;\n        let connection_id = self.next_connection_id;\n        \n        self.connections.insert(connection_id, connection)\n            .map_err(|_| TlsError::InvalidState)?;\n        \n        self.next_connection_id += 1;\n        Ok(connection_id)\n    }\n    \n    pub fn send_data(&mut self, connection_id: u32, data: &[u8]) -> Result<Vec<u8>, TlsError> {\n        let connection = self.connections.get_mut(&connection_id)\n            .ok_or(TlsError::InvalidState)?;\n        \n        connection.encrypt_record(0x17, data) // Application data\n    }\n    \n    pub fn receive_data(&mut self, connection_id: u32, record: &[u8]) -> Result<Vec<u8>, TlsError> {\n        let connection = self.connections.get_mut(&connection_id)\n            .ok_or(TlsError::InvalidState)?;\n        \n        connection.decrypt_record(record)\n    }\n}\n\n// Step 4b: C interface for existing application code\n#[no_mangle]\npub extern \"C\" fn secure_comm_manager_new() -> *mut SecureCommunicationManager {\n    Box::into_raw(Box::new(SecureCommunicationManager::new()))\n}\n\n#[no_mangle]\npub extern \"C\" fn secure_comm_create_connection(\n    manager: *mut SecureCommunicationManager,\n    master_secret: *const u8,\n) -> i32 {\n    if manager.is_null() || master_secret.is_null() {\n        return -1;\n    }\n    \n    unsafe {\n        let manager = &mut *manager;\n        let secret_slice = core::slice::from_raw_parts(master_secret, 48);\n        let secret_array: [u8; 48] = match secret_slice.try_into() {\n            Ok(arr) => arr,\n            Err(_) => return -1,\n        };\n        \n        match manager.create_connection(&secret_array) {\n            Ok(id) => id as i32,\n            Err(_) => -1,\n        }\n    }\n}\n\n// Step 4c: Update existing C application code\n/*\n// Old C application code:\nstatic tls_context_t* tls_ctx;\n\nvoid app_init() {\n    tls_ctx = tls_context_create();\n}\n\nint app_send_message(uint8_t* data, size_t len) {\n    return tls_encrypt_and_send(tls_ctx, data, len);\n}\n\n// New C application code using Rust backend:\nstatic void* secure_manager;\nstatic int connection_id;\n\nvoid app_init() {\n    secure_manager = secure_comm_manager_new();\n    uint8_t master_secret[48] = {...};\n    connection_id = secure_comm_create_connection(secure_manager, master_secret);\n}\n\nint app_send_message(uint8_t* data, size_t len) {\n    return secure_comm_send_data(secure_manager, connection_id, data, len);\n}\n*/",
      "line_number": 5425,
      "section": "Step 4: Application Integration Migration",
      "context": "**Migrating Application Logic to Use New Rust Interfaces**\n\n```rust\n// Step 4a: Create high-level application interface\npub struct SecureCommunicationManager {"
    },
    {
      "language": "rust",
      "code": "// Step 5a: Create Rust HAL for crypto hardware\npub struct CryptoHardware {\n    base_addr: *mut u32,\n}\n\nimpl CryptoHardware {\n    pub unsafe fn new(base_addr: usize) -> Self {\n        Self {\n            base_addr: base_addr as *mut u32,\n        }\n    }\n    \n    pub fn aes_hardware_encrypt(&self, key: &[u8; 32], plaintext: &[u8; 16]) -> [u8; 16] {\n        unsafe {\n            // Load key into hardware registers\n            for (i, chunk) in key.chunks(4).enumerate() {\n                let key_word = u32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]);\n                core::ptr::write_volatile(self.base_addr.offset(i as isize), key_word);\n            }\n            \n            // Load plaintext\n            for (i, chunk) in plaintext.chunks(4).enumerate() {\n                let data_word = u32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]);\n                core::ptr::write_volatile(self.base_addr.offset(8 + i as isize), data_word);\n            }\n            \n            // Start encryption\n            core::ptr::write_volatile(self.base_addr.offset(16), 0x01);\n            \n            // Wait for completion\n            while core::ptr::read_volatile(self.base_addr.offset(17)) & 0x01 == 0 {\n                cortex_m::asm::nop();\n            }\n            \n            // Read result\n            let mut result = [0u8; 16];\n            for (i, chunk) in result.chunks_mut(4).enumerate() {\n                let word = core::ptr::read_volatile(self.base_addr.offset(18 + i as isize));\n                chunk.copy_from_slice(&word.to_le_bytes());\n            }\n            \n            result\n        }\n    }\n}\n\n// Step 5b: Integration with existing crypto implementations\nimpl AesContext {\n    pub fn encrypt_block_hw(&self, input: &[u8; 16], hw: &CryptoHardware) -> [u8; 16] {\n        // Use hardware acceleration when available\n        if let Some(key_bytes) = self.key_schedule_as_bytes() {\n            hw.aes_hardware_encrypt(&key_bytes, input)\n        } else {\n            // Fallback to software implementation\n            self.encrypt_block(input)\n        }\n    }\n    \n    fn key_schedule_as_bytes(&self) -> Option<[u8; 32]> {\n        // Convert key schedule back to original key if possible\n        // This is a simplified example - real implementation would be more complex\n        None // Placeholder\n    }\n}",
      "line_number": 5529,
      "section": "Step 5: Hardware Abstraction Layer Migration",
      "context": "**Final Step: Migrating Hardware-Specific Code**\n\n```rust\n// Step 5a: Create Rust HAL for crypto hardware\npub struct CryptoHardware {"
    },
    {
      "language": "rust",
      "code": "use rtt_target::{rprintln, rtt_init_print};\n\nfn debug_crypto_operations() {\n    rtt_init_print!();\n    \n    let key = [0u8; 32];\n    let plaintext = b\"debug message\";\n    \n    rprintln!(\"Starting encryption with key: {:02x?}\", &key[..8]);\n    \n    let start_time = get_cycle_count();\n    let ciphertext = encrypt_aes(&key, plaintext).unwrap();\n    let end_time = get_cycle_count();\n    \n    rprintln!(\"Encryption completed in {} cycles\", end_time - start_time);\n    rprintln!(\"Ciphertext: {:02x?}\", &ciphertext[..16]);\n    \n    // Verify decryption\n    let decrypted = decrypt_aes(&key, &ciphertext).unwrap();\n    rprintln!(\"Decryption successful: {}\", decrypted == plaintext);\n}\n\n// Timing analysis for side-channel detection\nfn analyze_crypto_timing() {\n    const NUM_SAMPLES: usize = 1000;\n    let mut timings = [0u32; NUM_SAMPLES];\n    \n    for i in 0..NUM_SAMPLES {\n        let key = [i as u8; 32]; // Different keys\n        let plaintext = [0u8; 16];\n        \n        let start = get_cycle_count();\n        let _ = encrypt_aes(&key, &plaintext);\n        let end = get_cycle_count();\n        \n        timings[i] = end - start;\n    }\n    \n    // Basic statistical analysis\n    let min_time = timings.iter().min().unwrap();\n    let max_time = timings.iter().max().unwrap();\n    let avg_time = timings.iter().sum::<u32>() / NUM_SAMPLES as u32;\n    \n    rprintln!(\"Timing analysis:\");\n    rprintln!(\"  Min: {} cycles\", min_time);\n    rprintln!(\"  Max: {} cycles\", max_time);\n    rprintln!(\"  Avg: {} cycles\", avg_time);\n    rprintln!(\"  Variation: {} cycles\", max_time - min_time);\n    \n    if max_time - min_time > avg_time / 10 {\n        rprintln!(\"WARNING: High timing variation detected!\");\n    }\n}",
      "line_number": 7068,
      "section": "RTT Debugging for Crypto",
      "context": "#### RTT Debugging for Crypto\n\n```rust\nuse rtt_target::{rprintln, rtt_init_print};\n"
    },
    {
      "language": "rust",
      "code": "// Cycle-accurate benchmarking\nfn benchmark_crypto_operations() {\n    const ITERATIONS: usize = 1000;\n    \n    // Benchmark AES encryption\n    let key = [0u8; 32];\n    let mut plaintext = [0u8; 16];\n    \n    let start = get_cycle_count();\n    for i in 0..ITERATIONS {\n        plaintext[0] = i as u8; // Vary input slightly\n        let _ = encrypt_aes_block(&key, &plaintext);\n    }\n    let end = get_cycle_count();\n    \n    let cycles_per_block = (end - start) / ITERATIONS as u32;\n    let throughput_mbps = (16 * 8 * SYSTEM_CLOCK_HZ) / (cycles_per_block * 1_000_000);\n    \n    rprintln!(\"AES-256 Performance:\");\n    rprintln!(\"  {} cycles per block\", cycles_per_block);\n    rprintln!(\"  {} Mbps throughput\", throughput_mbps);\n}\n\n// Memory usage analysis\nfn analyze_memory_usage() {\n    extern \"C\" {\n        static mut _heap_start: u8;\n        static mut _heap_end: u8;\n        static mut _stack_start: u8;\n    }\n    \n    let heap_size = unsafe {\n        &_heap_end as *const u8 as usize - &_heap_start as *const u8 as usize\n    };\n    \n    let stack_ptr = cortex_m::register::msp::read() as usize;\n    let stack_usage = unsafe {\n        &_stack_start as *const u8 as usize - stack_ptr\n    };\n    \n    rprintln!(\"Memory Usage:\");\n    rprintln!(\"  Heap size: {} bytes\", heap_size);\n    rprintln!(\"  Stack usage: {} bytes\", stack_usage);\n    \n    // Crypto-specific memory analysis\n    let crypto_ctx_size = core::mem::size_of::<CryptoContext>();\n    let session_keys_size = core::mem::size_of::<SessionKeys>();\n    \n    rprintln!(\"Crypto Memory:\");\n    rprintln!(\"  CryptoContext: {} bytes\", crypto_ctx_size);\n    rprintln!(\"  SessionKeys: {} bytes\", session_keys_size);\n}",
      "line_number": 7130,
      "section": "Benchmarking and Profiling",
      "context": "#### Benchmarking and Profiling\n\n```rust\n// Cycle-accurate benchmarking\nfn benchmark_crypto_operations() {"
    }
  ],
  "cross_references": [
    {
      "source_line": 9,
      "source_section": "\ud83d\ude80 Quick Start Navigation",
      "target_anchor": "quick-reference",
      "link_text": "Quick Reference",
      "link_type": "internal"
    },
    {
      "source_line": 11,
      "source_section": "\ud83d\ude80 Quick Start Navigation",
      "target_anchor": "environment-setup",
      "link_text": "Environment Setup",
      "link_type": "internal"
    },
    {
      "source_line": 11,
      "source_section": "\ud83d\ude80 Quick Start Navigation",
      "target_anchor": "core-language-concepts",
      "link_text": "Core Concepts",
      "link_type": "internal"
    },
    {
      "source_line": 11,
      "source_section": "\ud83d\ude80 Quick Start Navigation",
      "target_anchor": "embedded-specific-patterns",
      "link_text": "Embedded Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 11,
      "source_section": "\ud83d\ude80 Quick Start Navigation",
      "target_anchor": "cryptography-implementation",
      "link_text": "Crypto Implementation",
      "link_type": "internal"
    },
    {
      "source_line": 11,
      "source_section": "\ud83d\ude80 Quick Start Navigation",
      "target_anchor": "core-language-concepts",
      "link_text": "Core Concepts",
      "link_type": "section"
    },
    {
      "source_line": 11,
      "source_section": "\ud83d\ude80 Quick Start Navigation",
      "target_anchor": "embedded-specific-patterns",
      "link_text": "Embedded Patterns",
      "link_type": "section"
    },
    {
      "source_line": 11,
      "source_section": "\ud83d\ude80 Quick Start Navigation",
      "target_anchor": "cryptography-implementation",
      "link_text": "Crypto Implementation",
      "link_type": "section"
    },
    {
      "source_line": 31,
      "source_section": "Document Usage Modes",
      "target_anchor": "environment-setup",
      "link_text": "Environment Setup",
      "link_type": "internal"
    },
    {
      "source_line": 32,
      "source_section": "Document Usage Modes",
      "target_anchor": "core-language-concepts",
      "link_text": "Core Concepts",
      "link_type": "internal"
    },
    {
      "source_line": 33,
      "source_section": "Document Usage Modes",
      "target_anchor": "embedded-specific-patterns",
      "link_text": "Embedded Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 34,
      "source_section": "Document Usage Modes",
      "target_anchor": "cryptography-implementation",
      "link_text": "Crypto Implementation",
      "link_type": "internal"
    },
    {
      "source_line": 51,
      "source_section": "[1. Quick Reference](#quick-reference)",
      "target_anchor": "quick-reference",
      "link_text": "1. Quick Reference",
      "link_type": "internal"
    },
    {
      "source_line": 52,
      "source_section": "[1. Quick Reference](#quick-reference)",
      "target_anchor": "c-to-rust-syntax-mapping",
      "link_text": "1.1 C to Rust Syntax Mapping",
      "link_type": "internal"
    },
    {
      "source_line": 53,
      "source_section": "[1. Quick Reference](#quick-reference)",
      "target_anchor": "memory-and-pointer-patterns",
      "link_text": "1.2 Memory and Pointer Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 54,
      "source_section": "[1. Quick Reference](#quick-reference)",
      "target_anchor": "control-flow-and-functions",
      "link_text": "1.3 Control Flow and Functions",
      "link_type": "internal"
    },
    {
      "source_line": 55,
      "source_section": "[1. Quick Reference](#quick-reference)",
      "target_anchor": "error-handling-patterns",
      "link_text": "1.4 Error Handling Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 56,
      "source_section": "[1. Quick Reference](#quick-reference)",
      "target_anchor": "crypto-specific-quick-reference",
      "link_text": "1.5 Crypto-Specific Quick Reference",
      "link_type": "internal"
    },
    {
      "source_line": 57,
      "source_section": "[1. Quick Reference](#quick-reference)",
      "target_anchor": "embedded-specific-patterns",
      "link_text": "1.6 Embedded-Specific Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 58,
      "source_section": "[1. Quick Reference](#quick-reference)",
      "target_anchor": "critical-differences-and-gotchas",
      "link_text": "1.7 Critical Differences and Gotchas",
      "link_type": "internal"
    },
    {
      "source_line": 60,
      "source_section": "[2. Environment Setup](#environment-setup)",
      "target_anchor": "environment-setup",
      "link_text": "2. Environment Setup",
      "link_type": "internal"
    },
    {
      "source_line": 61,
      "source_section": "[2. Environment Setup](#environment-setup)",
      "target_anchor": "rust-installation-and-toolchain",
      "link_text": "2.1 Rust Installation and Toolchain",
      "link_type": "internal"
    },
    {
      "source_line": 62,
      "source_section": "[2. Environment Setup](#environment-setup)",
      "target_anchor": "target-configuration",
      "link_text": "2.2 Target Configuration",
      "link_type": "internal"
    },
    {
      "source_line": 63,
      "source_section": "[2. Environment Setup](#environment-setup)",
      "target_anchor": "xilinx-ultrascale-cortex-r5",
      "link_text": "2.2.1 Xilinx Ultrascale+ (Cortex-R5)",
      "link_type": "internal"
    },
    {
      "source_line": 64,
      "source_section": "[2. Environment Setup](#environment-setup)",
      "target_anchor": "arm-cortex-m-series",
      "link_text": "2.2.2 ARM Cortex-M Series",
      "link_type": "internal"
    },
    {
      "source_line": 65,
      "source_section": "[2. Environment Setup](#environment-setup)",
      "target_anchor": "other-embedded-targets",
      "link_text": "2.2.3 Other Embedded Targets",
      "link_type": "internal"
    },
    {
      "source_line": 66,
      "source_section": "[2. Environment Setup](#environment-setup)",
      "target_anchor": "project-structure-and-dependencies",
      "link_text": "2.3 Project Structure and Dependencies",
      "link_type": "internal"
    },
    {
      "source_line": 67,
      "source_section": "[2. Environment Setup](#environment-setup)",
      "target_anchor": "build-configuration",
      "link_text": "2.4 Build Configuration",
      "link_type": "internal"
    },
    {
      "source_line": 68,
      "source_section": "[2. Environment Setup](#environment-setup)",
      "target_anchor": "verification-and-testing",
      "link_text": "2.5 Verification and Testing",
      "link_type": "internal"
    },
    {
      "source_line": 70,
      "source_section": "[3. Core Language Concepts](#core-language-concepts)",
      "target_anchor": "core-language-concepts",
      "link_text": "3. Core Language Concepts",
      "link_type": "internal"
    },
    {
      "source_line": 71,
      "source_section": "[3. Core Language Concepts](#core-language-concepts)",
      "target_anchor": "ownership-and-memory-management",
      "link_text": "3.1 Ownership and Memory Management",
      "link_type": "internal"
    },
    {
      "source_line": 72,
      "source_section": "[3. Core Language Concepts](#core-language-concepts)",
      "target_anchor": "error-handling-without-exceptions",
      "link_text": "3.2 Error Handling Without Exceptions",
      "link_type": "internal"
    },
    {
      "source_line": 73,
      "source_section": "[3. Core Language Concepts](#core-language-concepts)",
      "target_anchor": "type-system-advantages",
      "link_text": "3.3 Type System Advantages",
      "link_type": "internal"
    },
    {
      "source_line": 74,
      "source_section": "[3. Core Language Concepts](#core-language-concepts)",
      "target_anchor": "memory-model-differences",
      "link_text": "3.4 Memory Model Differences",
      "link_type": "internal"
    },
    {
      "source_line": 75,
      "source_section": "[3. Core Language Concepts](#core-language-concepts)",
      "target_anchor": "safety-guarantees-for-crypto",
      "link_text": "3.5 Safety Guarantees for Crypto",
      "link_type": "internal"
    },
    {
      "source_line": 77,
      "source_section": "[4. Embedded-Specific Patterns](#embedded-specific-patterns)",
      "target_anchor": "embedded-specific-patterns",
      "link_text": "4. Embedded-Specific Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 78,
      "source_section": "[4. Embedded-Specific Patterns](#embedded-specific-patterns)",
      "target_anchor": "no-std-programming-essentials",
      "link_text": "4.1 No-std Programming Essentials",
      "link_type": "internal"
    },
    {
      "source_line": 79,
      "source_section": "[4. Embedded-Specific Patterns](#embedded-specific-patterns)",
      "target_anchor": "hardware-abstraction-patterns",
      "link_text": "4.2 Hardware Abstraction Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 80,
      "source_section": "[4. Embedded-Specific Patterns](#embedded-specific-patterns)",
      "target_anchor": "interrupt-handling",
      "link_text": "4.3 Interrupt Handling",
      "link_type": "internal"
    },
    {
      "source_line": 81,
      "source_section": "[4. Embedded-Specific Patterns](#embedded-specific-patterns)",
      "target_anchor": "static-memory-management",
      "link_text": "4.4 Static Memory Management",
      "link_type": "internal"
    },
    {
      "source_line": 82,
      "source_section": "[4. Embedded-Specific Patterns](#embedded-specific-patterns)",
      "target_anchor": "dma-and-hardware-integration",
      "link_text": "4.5 DMA and Hardware Integration",
      "link_type": "internal"
    },
    {
      "source_line": 84,
      "source_section": "[5. Cryptography Implementation](#cryptography-implementation)",
      "target_anchor": "cryptography-implementation",
      "link_text": "5. Cryptography Implementation",
      "link_type": "internal"
    },
    {
      "source_line": 85,
      "source_section": "[5. Cryptography Implementation](#cryptography-implementation)",
      "target_anchor": "secure-coding-patterns",
      "link_text": "5.1 Secure Coding Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 86,
      "source_section": "[5. Cryptography Implementation](#cryptography-implementation)",
      "target_anchor": "constant-time-implementations",
      "link_text": "5.2 Constant-Time Implementations",
      "link_type": "internal"
    },
    {
      "source_line": 87,
      "source_section": "[5. Cryptography Implementation](#cryptography-implementation)",
      "target_anchor": "key-management-and-zeroization",
      "link_text": "5.3 Key Management and Zeroization",
      "link_type": "internal"
    },
    {
      "source_line": 88,
      "source_section": "[5. Cryptography Implementation](#cryptography-implementation)",
      "target_anchor": "hardware-crypto-acceleration",
      "link_text": "5.4 Hardware Crypto Acceleration",
      "link_type": "internal"
    },
    {
      "source_line": 89,
      "source_section": "[5. Cryptography Implementation](#cryptography-implementation)",
      "target_anchor": "side-channel-mitigations",
      "link_text": "5.5 Side-Channel Mitigations",
      "link_type": "internal"
    },
    {
      "source_line": 91,
      "source_section": "[6. Migration and Integration](#migration-and-integration)",
      "target_anchor": "migration-and-integration",
      "link_text": "6. Migration and Integration",
      "link_type": "internal"
    },
    {
      "source_line": 92,
      "source_section": "[6. Migration and Integration](#migration-and-integration)",
      "target_anchor": "incremental-migration-strategies",
      "link_text": "6.1 Incremental Migration Strategies",
      "link_type": "internal"
    },
    {
      "source_line": 93,
      "source_section": "[6. Migration and Integration](#migration-and-integration)",
      "target_anchor": "ffi-integration-with-c-libraries",
      "link_text": "6.2 FFI Integration with C Libraries",
      "link_type": "internal"
    },
    {
      "source_line": 94,
      "source_section": "[6. Migration and Integration](#migration-and-integration)",
      "target_anchor": "testing-and-validation",
      "link_text": "6.3 Testing and Validation",
      "link_type": "internal"
    },
    {
      "source_line": 95,
      "source_section": "[6. Migration and Integration](#migration-and-integration)",
      "target_anchor": "debugging-and-tooling",
      "link_text": "6.4 Debugging and Tooling",
      "link_type": "internal"
    },
    {
      "source_line": 96,
      "source_section": "[6. Migration and Integration](#migration-and-integration)",
      "target_anchor": "performance-considerations",
      "link_text": "6.5 Performance Considerations",
      "link_type": "internal"
    },
    {
      "source_line": 612,
      "source_section": "\u26a0\ufe0f Common Migration Pitfalls",
      "target_anchor": "environment-setup",
      "link_text": "Environment Setup",
      "link_type": "internal"
    },
    {
      "source_line": 857,
      "source_section": "Minimal Verification Application",
      "target_anchor": "core-language-concepts",
      "link_text": "Core Language Concepts",
      "link_type": "internal"
    },
    {
      "source_line": 867,
      "source_section": "Learning Path",
      "target_anchor": "ownership-and-memory-management",
      "link_text": "Ownership and Memory Management",
      "link_type": "internal"
    },
    {
      "source_line": 868,
      "source_section": "Learning Path",
      "target_anchor": "error-handling-without-exceptions",
      "link_text": "Error Handling",
      "link_type": "internal"
    },
    {
      "source_line": 869,
      "source_section": "Learning Path",
      "target_anchor": "type-system-advantages",
      "link_text": "Type System",
      "link_type": "internal"
    },
    {
      "source_line": 870,
      "source_section": "Learning Path",
      "target_anchor": "safety-guarantees-for-crypto",
      "link_text": "Safety Guarantees",
      "link_type": "internal"
    },
    {
      "source_line": 879,
      "source_section": "Quick Reference Links",
      "target_anchor": "critical-differences-and-gotchas",
      "link_text": "Critical Differences and Gotchas",
      "link_type": "internal"
    },
    {
      "source_line": 879,
      "source_section": "Quick Reference Links",
      "target_anchor": "critical-differences-and-gotchas",
      "link_text": "Critical Differences and Gotchas",
      "link_type": "section"
    },
    {
      "source_line": 880,
      "source_section": "Quick Reference Links",
      "target_anchor": "embedded-specific-patterns",
      "link_text": "Embedded-Specific Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 880,
      "source_section": "Quick Reference Links",
      "target_anchor": "embedded-specific-patterns",
      "link_text": "Embedded-Specific Patterns",
      "link_type": "section"
    },
    {
      "source_line": 881,
      "source_section": "Quick Reference Links",
      "target_anchor": "cryptography-implementation",
      "link_text": "Cryptography Implementation",
      "link_type": "internal"
    },
    {
      "source_line": 881,
      "source_section": "Quick Reference Links",
      "target_anchor": "cryptography-implementation",
      "link_text": "Cryptography Implementation",
      "link_type": "section"
    },
    {
      "source_line": 1551,
      "source_section": "Newtype Pattern for Domain-Specific Security",
      "target_anchor": "embedded-specific-patterns",
      "link_text": "Embedded-Specific Patterns",
      "link_type": "internal"
    },
    {
      "source_line": 3738,
      "source_section": "Advanced DMA-Safe Memory Management",
      "target_anchor": "cryptography-implementation",
      "link_text": "Cryptography Implementation",
      "link_type": "internal"
    },
    {
      "source_line": 3744,
      "source_section": "Advanced DMA-Safe Memory Management",
      "target_anchor": "cryptography-implementation",
      "link_text": "Cryptography Implementation",
      "link_type": "internal"
    }
  ],
  "compilation_results": {
    "Result Type Usage:194": false,
    "Secure Key Management Example:231": false,
    "No-std Complete Template:293": false,
    "\u26a0\ufe0f Memory Management Gotchas:381": false,
    "\u26a0\ufe0f Crypto-Specific Gotchas:419": false,
    "\u26a0\ufe0f Crypto-Specific Gotchas:444": false,
    "\u26a0\ufe0f Embedded-Specific Gotchas:477": false,
    "\u26a0\ufe0f Embedded-Specific Gotchas:521": false,
    "\u26a0\ufe0f Common Migration Pitfalls:557": false,
    "\u26a0\ufe0f Common Migration Pitfalls:577": false,
    "\u26a0\ufe0f Common Migration Pitfalls:595": false,
    ".cargo/config.toml - ZynqMP/Versal configuration:696": false,
    "2.4 Build Configuration:779": false,
    "Minimal Verification Application:827": false,
    "Ownership in Embedded Crypto Context:909": false,
    "Borrowing Rules for Crypto Operations:956": false,
    "Memory Management Patterns for Embedded:1012": false,
    "Comprehensive Crypto Error Types:1066": false,
    "Error Propagation in Crypto Pipelines:1114": false,
    "Option Types for Safe Nullable Crypto State:1187": false,
    "Error Recovery Patterns for Embedded Crypto:1226": false,
    "Type-Safe Protocol State Machines:1270": false,
    "Const Generics for Compile-Time Crypto Parameters:1381": false,
    "Newtype Pattern for Domain-Specific Security:1471": false,
    "Complete No-std Project Template:1565": false,
    "No-std Memory Management Patterns:1645": false,
    "No-std Error Handling and Result Types:1790": false,
    "Peripheral Access Crate (PAC) Usage:1850": false,
    "Hardware Abstraction Layer (HAL) Patterns:1965": false,
    "Cross-Platform Hardware Abstraction:2180": false,
    "Safe Interrupt Handling Fundamentals:2259": false,
    "RTIC Framework for Real-Time Crypto:2448": false,
    "Interrupt Priority and Timing Considerations:2723": false,
    "Advanced Static Memory Pool Management:2796": false,
    "Compile-Time Memory Layout with Security Features:2947": false,
    "Memory Layout Optimization for Crypto Performance:3183": false,
    "Advanced DMA-Safe Memory Management:3281": false,
    "Memory Safety Advantages for Cryptography:3770": false,
    "Automatic Key Zeroization Patterns:3812": false,
    "Type-Safe Protocol State Machines:3905": false,
    "Rust-Specific Security Advantages:4050": false,
    "Understanding Side-Channel Vulnerabilities:4153": false,
    "Using the `subtle` Crate for Constant-Time Operations:4185": false,
    "Advanced Constant-Time Patterns:4261": false,
    "Manual Constant-Time Implementations:4381": false,
    "Embedded-Specific Constant-Time Considerations:4427": false,
    "Automatic Key Zeroization Patterns:4522": false,
    "Hierarchical Key Derivation with Automatic Cleanup:4582": false,
    "Secure Random Number Generation with Hardware Integration:4689": false,
    "Key Lifecycle Management:4847": false,
    "Generic Hardware Abstraction:4996": false,
    "Power Analysis Protection:5081": false,
    "Step 2: Module-by-Module Migration:5173": false,
    "Step 3: Protocol-Level Migration:5287": false,
    "Step 4: Application Integration Migration:5425": false,
    "Step 5: Hardware Abstraction Layer Migration:5529": false,
    "RTT Debugging for Crypto:7068": false,
    "Benchmarking and Profiling:7130": false
  },
  "broken_links": [
    {
      "source_line": 74,
      "source_section": "[3. Core Language Concepts](#core-language-concepts)",
      "target_anchor": "memory-model-differences",
      "link_text": "3.4 Memory Model Differences",
      "link_type": "internal"
    },
    {
      "source_line": 75,
      "source_section": "[3. Core Language Concepts](#core-language-concepts)",
      "target_anchor": "safety-guarantees-for-crypto",
      "link_text": "3.5 Safety Guarantees for Crypto",
      "link_type": "internal"
    },
    {
      "source_line": 870,
      "source_section": "Learning Path",
      "target_anchor": "safety-guarantees-for-crypto",
      "link_text": "Safety Guarantees",
      "link_type": "internal"
    }
  ],
  "duplicate_content": [
    {
      "block1": {
        "content": "**\u2192 Next:** [Cryptography Implementation](#cryptography-implementation) - Secure coding patterns and crypto-specific implementations",
        "hash": "886031036ccdc18c4708bef5eab35481",
        "line_start": 3738,
        "line_end": 3738,
        "section": "Advanced DMA-Safe Memory Management",
        "word_count": 11
      },
      "block2": {
        "content": "**\u2192 Next:** [Cryptography Implementation](#cryptography-implementation) - Secure coding patterns and crypto-specific implementations",
        "hash": "886031036ccdc18c4708bef5eab35481",
        "line_start": 3744,
        "line_end": 3744,
        "section": "Advanced DMA-Safe Memory Management",
        "word_count": 11
      },
      "similarity": 1.0
    }
  ]
}