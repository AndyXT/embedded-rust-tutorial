# Introduction

As an experienced embedded cryptography engineer, you understand the critical importance of correctness and security in cryptographic implementations. A single buffer overflow, timing leak, or use-after-free can compromise an entire system. Traditional C development requires constant vigilance against these threats while managing the complexities of embedded systems.

Rust addresses these challenges while maintaining the performance and control essential for cryptographic operations. This tutorial is specifically designed for experienced C programmers who need to become productive in Rust quickly, without wading through basic programming concepts.

**Why this tutorial is different:**
- **Assumes C expertise** - No basic programming explanations
- **Crypto-focused examples** - All examples relevant to cryptographic engineering
- **Quick reference first** - Immediate productivity through comprehensive lookup tables
- **Embedded-specific** - Covers no-std, hardware integration, and real-time constraints
- **Streamlined organization** - Eliminates redundancy, focuses on practical differences

**What you'll gain:**
- Memory safety without performance overhead
- Automatic key material zeroization
- Type-safe protocol state machines
- Compile-time prevention of common crypto vulnerabilities
- Clear boundaries between safe and unsafe code

---